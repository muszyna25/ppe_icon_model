require 'minitest/autorun'
require 'open3'
require 'jobqueue'
require 'facets'
require 'iconPlot'
require 'rake/clean'
require 'test/unit/assertions'
include Test::Unit::Assertions

# ============================================================================
# Please copy this file to the opt directory of you main working copy and 
# adjust the remote and local settings
# usage with the given configuration:
# * parallel build with gcc (locally) and nag (remotely)
#   rake parX localGcc_build remoteNag_build
# * synchronization of several remote build locations
#   rake par remoteDef_sync remoteIntel_sync remoteGccHi_sync
# * print our the commands before executing:
#   DEBUG=1 rake remoteGccHi_conf
# * print the commands without executing them
#   DRYRUN=1 rake remoteGccHi_conf
# ============================================================================
# AUTHOR: Ralf Mueller, ralf.mueller@zmaw.de
# REQUIREMENTS: 
# * ruby-1.9.* or higher (use with 'module load ruby')
# * jobQueue (rubygem, install with 'gem install jobQueue --user-install)
# ============================================================================
# user account on all remote machines
REMOTE_USER = 'm300064'

# local master source code directory
SRCDIR      = ENV.has_key?('SRCDIR')? ENV['SRCDIR'] : '.'
WORKDIR     = File.expand_path('.')
# remote runscripts
DEFAULT_EXP = 'test_oce_default'
#plotter
@plotter = IconPlot.new

# basic host setup
$hosts = {
  # local port forwarding setup for thunder4 and 5
  # cat .ssh/config
  #Host thunder
  #HostName login.zmaw.de
  #LocalForward 50022 thunder5.zmaw.de:22
  #LocalForward 40022 thunder4.zmaw.de:22

  :thunder4 => {
    :user     => REMOTE_USER,
    :hostname => 'localhost',
    :port     => 40022,
   #:hostname => 'thunder4.zmaw.de', # use from internal net if login node is down
    :dir      => '/scratch/mpi/mh0287/users/m300064/builds/remote/icon' },
  :thunder5 => {
    :user     => REMOTE_USER,
    :hostname => 'localhost',
    :port     => 50022,
   #:hostname => 'thunder5.zmaw.de',# use from internal net if login node is down 
    :dir      => '/scratch/mpi/mh0287/users/m300064/builds/remote/icon' },
  :passat => {
    :user     => REMOTE_USER,
    :hostname => 'passat.dkrz.de',
    :dir      => '/work/mh0287/users/ram/builds'},
  :wizard => {
    :user     => REMOTE_USER,
    :hostname => 'wizard.dkrz.de',
    :dir      => '/work/mh0287/users/ram/builds'},
  # laptop on my desk
  :thingol => {
    :dir => '/home/ram/builds/icon' }
}
# naming conventions:
# * local builds start with 'local'
# * remote builds start with 'remote'
$builds = {
  :localGcc          => {:host => :thingol , :subdir => 'gcc'}     ,
  :localGccHi        => {:host => :thingol , :subdir => 'gcc-hiopt', :CC => 'gcc'      , :FLAGS => 'hiopt'},
  :localGprof        => {:host => :thingol , :subdir => 'gprof'}   ,
  :localOpenMP       => {:host => :thingol , :subdir => 'openmp'   ,                     :FLAGS => 'hiopt' , :openmp => true}  ,
  :localNag          => {:host => :thingol , :subdir => 'nag'      , :CC => 'nag'}     ,
  :localSun          => {:host => :thingol , :subdir => 'sun'      , :CC => 'sun'      ,:preConf => 'PATH=$HOME/local/solarisstudio12.3/bin:$PATH', :preBuild => 'PATH=$HOME/local/solarisstudio12.3/bin:$PATH'},
  :localTest         => {:host => :thingol , :subdir => 'test'     , :CC => 'nag'}     ,
  :remoteSerial      => {:host => :thunder4, :subdir => 'serial'   ,                    :confOpts => '--without-mpi'}    ,
  :remoteGccHi       => {:host => :thunder5, :subdir => 'gcc'      , :CC => 'gcc'      , :FLAGS => 'hiopt'},
  :remoteGccHiOpenMP => {:host => :thunder5, :subdir => 'gcc-opemp', :CC => 'gcc'      , :FLAGS => 'hiopt' , :openmp => true},
  :remoteNag         => {:host => :thunder4, :subdir => 'nag'      , :CC => 'nag'}     ,
  :remoteIntel       => {:host => :thunder4, :subdir => 'intel'    , :CC => 'intel'}   ,
  :remotePgi         => {:host => :thunder4, :subdir => 'pgi'      , :CC => 'pgi'}     ,
  :remoteXlf         => {:host => :wizard  , :subdir => 'default'} ,
  :remoteXlfHi       => {:host => :passat  , :subdir => 'hiopt'    , :FLAGS => 'hiopt'}
}
# ============================================================================

# run the commands and try to get back stdout or possible error messages
def call(cmd,unthreadded=false)
  unless ENV['DRYRUN'].nil?
    puts cmd
    return
  end
  dbg(cmd)
  if unthreadded then
    puts IO.popen(cmd).read
  else
    Open3.popen3(cmd) do |stdin, stdout, stderr, external|
      # read from stdout and stderr in parallel
      { :out => stdout, :err => stderr }.each {|key, stream|
        Thread.new do
          until (line = stream.gets).nil? do
            puts line
          end
        end
      }

      # Don't exit until the external process is done
      external.join
    end
  end
end

# debug output for any type of object
def dbg(msg)
  pp msg unless ENV['DEBUG'].nil?
end

# check for the naming convention to distinguish remote from local builds
def isLocal?(build);  true if 'local' == build.to_s[0,5]; end
def isRemote?(build); not isLocal?(build); end

# hide some complex hash accesses
# {
$hostOf = lambda {|build| 
  host = $builds[build][:host]
}
$hostnameOf = lambda {|build|
  host = $hostOf[build]
  $hosts[host][:hostname].nil? ? host.to_s : $hosts[host][:hostname]
}
# }

# compute the directory where to (possible remote) code is
$targetDir = lambda {|build,withHost=true,revision=nil|
  dir      = ''
  host     = $hostOf[build]
  hostname = $hostnameOf[build]
  dir << "m300064@#{hostname}:" if isRemote?(build) and withHost
  dir << $hosts[host][:dir] + '/' + $builds[build][:subdir]
  dir << "/r#{revision.to_s}" unless revision.nil?

  dir
}

# ssh connection command line
$remoteConnection = lambda {|build|
  hostname  = $hostnameOf[build]
  portSpec  = $hosts[$hostOf[build]][:port].nil? ? '' : "-p #{$hosts[$hostOf[build]][:port]}"
  "ssh #{portSpec}"
}

# configure for a given build call wrt. to given options
$configureCall = lambda {|build|
  configureCall = ''
  configureCall << "#{$builds[build][:preConf]};" unless $builds[build][:preConf].nil?
  configureCall << "COMPILER=#{$builds[build][:CC]} "
  configureCall << './configure'
  configureCall << " --with-fortran=#{$builds[build][:CC]}" unless $builds[build][:CC].nil?
  configureCall << " --with-flags=#{$builds[build][:FLAGS]}" unless $builds[build][:FLAGS].nil?
  configureCall << " --with-openmp" unless $builds[build][:openmp].nil?
  configureCall << " " << $builds[build][:confOpts] if $builds[build].has_key?(:confOpts)
  configureCall << " ;"
  configureCall
}

# build call
$buildCall = lambda {|build|
  buildCall = ''
  buildCall << $builds[build][:preBuild]  << ';' unless $builds[build][:preBuild].nil?
  buildCall << './build_command;'
}

# exclude files for a build
$excludeFiles = lambda {|build|
  list =  " --exclude='.git/*'"
  list << " --exclude='experiments/**/*nc*' --exclude='**/*.o'  --exclude='build/*' --exclude='**/*.run' --exclude=config/mh-config-use --exclude=config.log --exclude=Makefile --exclude=build_command"
  list << " --exclude=config/mh-override --exclude=config/mh-config-use" if isRemote?(build)
  list << " --exclude='.svn/*'" << " --exclude=config/set-up.info" << " --exclude='**/*.ps'" << " --exclude='**/*.pdf'" << " --exclude='**/*.png'"
  list
}

# synchronization call for given build
def sync(build)
  excludes = $excludeFiles[build]
  dir      = $targetDir[build]
  rsyncOpts = "--delete-excluded --delete"
  rsyncOpts = ""

  if isLocal?(build)
    syncCmd = "rsync #{rsyncOpts} -avz #{SRCDIR}/ #{dir} #{excludes}"
  else
    syncCmd = "rsync #{rsyncOpts} -avz -e '#{$remoteConnection[build]}' #{SRCDIR}/ #{dir} #{excludes}"
  end
  syncCmd
end

# optional connection command
def connect(build,command,targetDir=$targetDir[build,false])
  cmd      = ''
  hostname = $hostnameOf[build]
  cmd << $remoteConnection[build] + " m300064@#{hostname} " if isRemote?(build)
  cmd << "'" if isRemote?(build)
  cmd << "source /etc/profile; [[ -f .profile ]] && source .profile; " if isRemote?(build)
  cmd << "cd #{targetDir};"

  # add module command - needed by ICONs configure
  cmd << command
  cmd << "'" if isRemote?(build)

  cmd
end

# caller for sync, config, build and run
def doSync(build)
  call(sync(build))
end
def doCheckoutRev(build,rev,url)
  dir  = $targetDir[build]+'/'+rev.to_s
  revTag = rev == 'HEAD' ? '' : "-r#{rev}"
  call(connect(build,<<-EOS
      [[ ! -d r#{rev} ]] && mkdir -p r#{rev};
      cd r#{rev}; 
      if [[ -d .svn ]];then
        svn revert -R .;
        svn update #{revTag};
      else
        svn checkout #{url} #{revTag} .;
      fi;
               EOS
              ))
end
def doConfig(build,rev=nil)
  call(connect(build,$configureCall[build],$targetDir[build,false,rev]))
end
def doBuild(build,rev=nil)
  call(connect(build,$buildCall[build],$targetDir[build,false,rev]))
end
def doClean(build)
  call(connect(build,"make clean"))
end
def doCleanSync(build)
  call(connect(build,"rm -rf src support build"))
end
def doRunExp(build,exp,post=false)
  runScript = (post) ? 'post' : 'exp'
  runScript << '.' + exp +'.run'
  call(connect(build,"cd experiments/#{exp}; test -f $(echo #{exp}*.nc | cut -d ' ' -f 1) && rm #{exp}*.nc"))
  call(connect(build,<<-EOS
      cd experiments/#{exp};
      test -f $(echo #{exp}*.nc | cut -d \' \' -f 1) && rm #{exp}*.nc
               EOS
              ))
              call(connect(build,<<-EOS
      ./make_runscripts #{exp};
      cd run;
      perl -pi.bak -e 's/submit=.*/submit=""/' #{runScript} ;
      ./exp.#{exp}.run;
                           EOS
                          ),true)
end
def doSubmit(build,exp,post=false)
  runScript = (post) ? 'post' : 'exp'
  runScript << '.' + exp +'.run'
  call(connect(build,<<-EOS
      cd run;
      perl -pi.bak -e 's/partition=mpi-compute/partition=mpi-develop/' #{runScript} ;
      sbatch ./#{runScript}
      EOS
              ))
end
def doSubmitExp(build,exp)
  doSubmit(build,exp)
end
def doSubmitPost(build,exp)
  doSubmit(build,exp,true)
end
def doRunPost(build,exp)
  call(connect(build,"./make_runscripts ; cd run;./post.#{exp}.run;"))
end
def doCheckExp(build,exp)
  call(connect(build,<<-EOS
      cd experiments/#{exp};
      for file in #{exp}*001.nc #{exp}*001_TEST.nc; do
        if [ -f $file ]; then
          echo '#===========================================================================';
          echo " $file";echo
          cdo showname  $file
          cdo infov -selname,t $file
          #cdo -infov -merge -div -expr,'t_diff=t_acc-t' $file -selname,wet_c $file
          #cdo -infov -merge -div -expr,'s_diff=s_acc-s' $file -selname,wet_c $file
          cdo -infov -subc,16.0 -div -selname,t,t_acc $file -selname,wet_c $file
        fi;
      done
               EOS
              ),true)
  diagFile    = 'oce_diagnostics.txt'
  diagPlotter = 'scripts/postprocessing/tools/oceDiag.gp'
  call(connect(build,<<-EOS
      cd experiments/#{exp};
      if test -f #{diagFile}; then
        LD_LIBRARY_PATH=/usr/lib SHOW=1 FILE=#{diagFile} gnuplot ../../#{diagPlotter};
      else echo 'No diagnostics avialable!';
      fi
   EOS
  )) unless ENV['SHOW'].nil?
#ifile="#{$targetDir[build,false]}/experiments/#{exp}/#{exp}_R2B02_oce_DOM01_ML_0001.nc"
#varName='matrix_vert_diff_c_1'
#image = @plotter.plot(ifile,'test_'+exp,'matrix_vert_diff_c_1','scalar',:maskName => 'wet_c',:timeStep => 3)
end
def doCheckPost(build,exp,ext)
  pattern = "*_#{exp}_*.#{ext}"
  displayWith = 'eps' == ext ? 'evince' : 'display'
  call(connect(build,<<-EOS
      cd experiments/#{exp}/plots;
      if test -f $(ls -1 #{pattern} | head -1) ; then
               #{displayWith} #{pattern};
      else
        echo 'No postprocessing avialable!';
      fi
               EOS
              ))
end

$builds.each_key {|build|
  # regular tasks with all dependencies {
  desc "sync for build #{build.to_s}"
  task "#{build.to_s}_sync".to_sym do
    doSync(build)
  end
  desc "Configure for build #{build.to_s}"
  task "#{build.to_s}_conf".to_sym => ["#{build.to_s}_sync".to_sym] do
    doConfig(build)
  end
  desc "Build for build #{build.to_s}"
  task "#{build.to_s}_build".to_sym => ["#{build.to_s}_conf".to_sym] do
    doBuild(build)
  end
  desc "Clean repository for build #{build.to_s}"
  task "#{build.to_s}_clean".to_sym do
    doClean(build)
  end
  desc "Run for build #{build.to_s}"
  task "#{build.to_s}_run".to_sym , [:exp] => ["#{build.to_s}_build".to_sym] do |t, args|
    doRunExp(build,args.exp || DEFAULT_EXP)
  end

  #special thunder submits
  if /thunder/.match($builds[build][:host].to_s) then
    desc "Submit experiment on thunder for build #{build.to_s} (incl. preq.)"
    task "#{build.to_s}_submit".to_sym , [:exp] => ["#{build.to_s}_build".to_sym] do |t, args|
      doSubmitExp(build,args.exp || DEFAULT_EXP)
    end
    desc "Submit experiment on thunder for build #{build.to_s}"
    task "#{build.to_s}_submitOnly".to_sym , :exp, :post do |t, args|
      performPostproc = args.post.to_s.to_b || false
      if performPostproc then
        doSubmitPost(build,args.exp || DEFAULT_EXP)
      else
        doSubmitExp(build,args.exp || DEFAULT_EXP)
      end
    end
  end
  desc "Check output files"
  task "#{build.to_s}_check".to_sym , [:exp] => ["#{build.to_s}_run".to_sym] do |t, args|
    doCheckExp(build,args.exp || DEFAULT_EXP)
  end
  # post processing
  desc "Run post-processing on given exp (build:#{build.to_s})"
  task "#{build.to_s}_post".to_sym, [:exp] => ["#{build.to_s}_sync".to_sym] do |t, args|
    doRunPost(build,args.exp || DEFAULT_EXP)
  end
  # check post processing
  desc "Display post-processing output for given exp (build:#{build.to_s})"
  task "#{build.to_s}_checkPost".to_sym, :exp, :ext  do |t, args|
    doCheckPost(build,
                args.exp || DEFAULT_EXP,
                args.ext || 'eps')
  end
  # }
  # TASKS FOR ONLY DO ONE SINGLE THING {
  desc "Configure for build #{build.to_s}"
  task "#{build.to_s}_confOnly".to_sym do
    doConfig(build)
  end
  desc "Build for build #{build.to_s}"
  task "#{build.to_s}_buildOnly".to_sym => ["#{build.to_s}_sync".to_sym] do
    doBuild(build)
  end
  desc "Run for build #{build.to_s}"
  task "#{build.to_s}_runOnly".to_sym, [:exp] => ["#{build.to_s}_sync".to_sym] do |t,args|
    doRunExp(build,args.exp || DEFAULT_EXP)
  end
  desc "Check output files"
  task "#{build.to_s}_checkOnly".to_sym , [:exp] => ["#{build.to_s}_sync".to_sym] do |t, args|
    doCheckExp(build,args.exp || DEFAULT_EXP)
  end
  # }

  desc "remove old source trees and sync"
  task "#{build.to_s}_cleanSync".to_sym do
    doCleanSync(build)
    doSync(build)
  end

  desc "build special revision"
  task "#{build.to_s}_buildRev".to_sym, [:rev,:url] do |t,args|
    doCheckoutRev(build,args.rev,args.url)
    doConfig(build,args.rev)
    doBuild(build,args.rev)
  end
}
desc "Sync source codes for all builds"
task :allSync do
  q = JobQueue.new
  $builds.each_key {|build| q.push { doSync(build) } }
  q.run
end
desc "Remove and Sync source codes for all builds"
task :allCleanSync do
  q = JobQueue.new
  $builds.each_key {|build| q.push { doCleanSync(build) } }
  q.run
end

# tasks for parallel run of other tasks in an Xtra terminal
[
  :par,      # execute everything in the calling terminal
  :parX,     # shut the terminal when finished
  :parXWait  # keep the terminal open when finished (shut with ENTER)
].each {|parTaskName|
  terminalEmulators = ['gnome-terminal','xterm']
  help = case parTaskName
         when :par then
           "execute all tasks in parallel"
         when :parX then
           "parallel run of other tasks in an Xtra terminal - shut when finished"
         when :parXWait then
           "parallel run of other tasks in an Xtra terminal - keep open when finished"
         else
           warn "Unknown task"
           exit 1
         end
  desc help
  task parTaskName do
    dbg(Rake.application.top_level_tasks)

    # remote the task from the internal task list because they will be started in a sub-thread
    Rake.application.top_level_tasks.clear

    # create a task list from the command line
    ARGV.shift
    taskList = ARGV
    dbg(taskList)

    # parallel execution queue
    q = JobQueue.new

    # execute everything from the cmldline, which has a corresponding task
    taskList.each {|taskName|
      dbg(taskName)

      case parTaskName
      when :par then
        task = Rake::Task.tasks.find {|t| taskName == t.name }
        if task.nil? then
          warn "Unkown task: #{taskName}"
          exit 2
        else
          q.push { task.invoke }
        end

      when :parX,:parXWait
        cmd     = "#{terminalEmulators[1]} -T 'rake #{taskName}' -e 'rake #{taskName};'"
        cmd[-1] = "read'" if :parXWait == parTaskName
        q.push { call(cmd) }

      end
    }
    q.run
  end
}

desc "Check variables an user input"
task :check ,[:p] do |t,args|
  pp args
  {
    'SRCDIR' => SRCDIR,
    'REMOTE_USER' => REMOTE_USER,
    'WORKDIR' => WORKDIR,
    'RAKEFILE' => __FILE__,
  }.each {|k,v|
    puts [k.rjust(16,' '),v.ljust(20,' ')].join(': ')
  }
end

# vim:ft=ruby
