require 'open3'
require 'jobqueue'
require 'facets'
require 'rake/clean'
require 'test/unit/assertions'
include Test::Unit::Assertions

# ============================================================================
# Please copy this file to the opt directory of you main working copy and 
# adjust the remote and local settings
# usage with the given configuration:
# * parallel build with gcc (locally) and nag (remotely)
#   rake parX localGcc_build remoteNag_build
# * synchronization of several remote build locations
#   rake par remoteDef_sync remoteIntel_sync remoteGccHi_sync
# * print our the commands before executing:
#   DEBUG=1 rake remoteGccHi_conf
# * print the commands without executing them
#   DRYRUN=1 rake remoteGccHi_conf
# ============================================================================
# AUTHOR: Ralf Mueller, ralf.mueller@zmaw.de
# REQUIREMENTS: 
# * ruby-1.9.* or higher (use with 'module load ruby')
# * jobQueue (rubygem, install with 'gem install jobQueue --user-install)
# ============================================================================
# user account on all remote machines
REMOTE_USER = 'm300064'

# local master source code directory
SRCDIR      = ENV.has_key?('SRCDIR')? ENV['SRCDIR'] : '.'
WORKDIR     = File.expand_path('.')
# remote runscripts
DEFAULT_EXP = 'test_oce_default'

# basic host setup
$hosts = {
  # local port forwarding setup for thunder4 and 5
  # cat .ssh/config
  #Host thunder
  #HostName login.zmaw.de
  #LocalForward 50022 thunder5.zmaw.de:22
  #LocalForward 40022 thunder4.zmaw.de:22

  :thunder4 => {
    :user     => REMOTE_USER,
    :hostname => 'localhost',
    :port     => 40022,
   #:hostname => 'thunder4.zmaw.de', # use from internal net if login node is down
    :dir      => '/scratch/mpi/mh0287/users/m300064/builds/remote/icon' },
  :thunder5 => {
    :user     => REMOTE_USER,
    :hostname => 'localhost',
    :port     => 50022,
   #:hostname => 'thunder5.zmaw.de',# use from internal net if login node is down 
    :dir      => '/scratch/mpi/mh0287/users/m300064/builds/remote/icon' },
  :passat => {
    :user     => REMOTE_USER,
    :hostname => 'passat.dkrz.de',
    :dir      => '/work/mh0287/users/ram/builds'},
  # laptop on my desk
  :thingol => {
    :dir => '/home/ram/builds/icon' }
}

# naming conventions:
# * local builds start with 'local'
# * remote builds start with 'remote'
$builds = {
  :localGcc          => {:host => :thingol , :subdir => 'gcc'}     ,
  :localGccHi        => {:host => :thingol , :subdir => 'gcc-hiopt', :CC => 'gcc'      , :FLAGS => 'hiopt'},
  :localGprof        => {:host => :thingol , :subdir => 'gprof'}   ,
  :localOpenMP       => {:host => :thingol , :subdir => 'openmp'   ,                     :FLAGS => 'hiopt' , :openmp => true}  ,
  :localNag          => {:host => :thingol , :subdir => 'nag'      , :CC => 'nag'}     ,
  :localSun          => {:host => :thingol , :subdir => 'sun'      , :CC => 'sun'      ,:preConf => 'PATH=$HOME/local/solarisstudio12.3/bin:$PATH', :preBuild => 'PATH=$HOME/local/solarisstudio12.3/bin:$PATH'},
  :localTest         => {:host => :thingol , :subdir => 'test'     , :CC => 'nag'}     ,
  :remoteSerial      => {:host => :thunder4, :subdir => 'serial'   ,                    :confOpts => '--without-mpi'}    ,
  :remoteGccHi       => {:host => :thunder5, :subdir => 'gcc'      , :CC => 'gcc'      , :FLAGS => 'hiopt'},
  :remoteGccHiOpenMP => {:host => :thunder5, :subdir => 'gcc-opemp', :CC => 'gcc'      , :FLAGS => 'hiopt' , :openmp => true},
  :remoteNag         => {:host => :thunder4, :subdir => 'nag'      , :CC => 'nag'}     ,
  :remoteIntel       => {:host => :thunder4, :subdir => 'intel'    , :CC => 'intel'}   ,
  :remotePgi         => {:host => :thunder5, :subdir => 'pgi'      , :CC => 'pgi'}     ,
  :remoteXlf         => {:host => :passat  , :subdir => 'default'} ,
  :remoteXlfHi       => {:host => :passat  , :subdir => 'hiopt'    , :FLAGS => 'hiopt'}
}
# ============================================================================

# run the commands and try to get back stdout or possible error messages
def call(cmd)
  unless ENV['DRYRUN'].nil?
    puts cmd
    return
  end
  dbg(cmd)
  Open3.popen3(cmd) do |stdin, stdout, stderr, external|
    # read from stdout and stderr in parallel
    { :out => stdout, :err => stderr }.each {|key, stream|
      Thread.new do
        until (line = stream.gets).nil? do
          puts line
        end
      end
    }

    # Don't exit until the external process is done
    external.join
  end
end

# debug output for any type of object
def dbg(msg)
  pp msg unless ENV['DEBUG'].nil?
end

# check for the naming convention to distinguish remote from local builds
def isLocal?(build);  true if 'local' == build.to_s[0,5]; end
def isRemote?(build); not isLocal?(build); end

# hide some complex hash accesses
# {
$hostOf = lambda {|build| 
  host = $builds[build][:host]
}
$hostnameOf = lambda {|build|
  host = $hostOf[build]
  $hosts[host][:hostname].nil? ? host.to_s : $hosts[host][:hostname]
}
# }

# compute the directory where to (possible remote) code is
$targetDir = lambda {|build,withHost=true|
  dir      = ''
  host     = $hostOf[build]
  hostname = $hostnameOf[build]
  dir << "m300064@#{hostname}:" if isRemote?(build) and withHost
  dir << $hosts[host][:dir] + '/' + $builds[build][:subdir]

  dir
}

# ssh connection command line
$remoteConnection = lambda {|build|
  hostname  = $hostnameOf[build]
  portSpec  = $hosts[$hostOf[build]][:port].nil? ? '' : "-p #{$hosts[$hostOf[build]][:port]}"
  "ssh #{portSpec}"
}

# configure for a given build call wrt. to given options
$configureCall = lambda {|build|
  configureCall = ''
  configureCall << "#{$builds[build][:preConf]};" unless $builds[build][:preConf].nil?
  configureCall << "COMPILER=#{$builds[build][:CC]} "
  configureCall << './configure'
  configureCall << " --with-fortran=#{$builds[build][:CC]}" unless $builds[build][:CC].nil?
  configureCall << " --with-flags=#{$builds[build][:FLAGS]}" unless $builds[build][:FLAGS].nil?
  configureCall << " --with-openmp" unless $builds[build][:openmp].nil?
  configureCall << " " << $builds[build][:confOpts] if $builds[build].has_key?(:confOpts)
  configureCall << " ;"
  configureCall
}

# build call
$buildCall = lambda {|build|
  buildCall = ''
  buildCall << $builds[build][:preBuild]  << ';' unless $builds[build][:preBuild].nil?
  buildCall << './build_command;'
}

# exclude files for a build
$excludeFiles = lambda {|build|
  list =  " --exclude='.git/*'"
  list << " --exclude='experiments/**/*nc*' --exclude='**/*.o'  --exclude='build/*' --exclude='**/*.run' --exclude=config/mh-config-use --exclude=config.log --exclude=Makefile --exclude=build_command"
  list << " --exclude=config/mh-override --exclude=config/mh-config-use" if isRemote?(build)
  list << " --exclude='.svn/*'" << " --exclude=config/set-up.info" << " --exclude='**/*.ps'" << " --exclude='**/*.pdf'" << " --exclude='**/*.png'"
  list
}

# synchronization call for given build
def sync(build)
  excludes = $excludeFiles[build]
  dir      = $targetDir[build]

  if isLocal?(build)
    syncCmd = "rsync -avz #{SRCDIR}/ #{dir} #{excludes}"
  else
    syncCmd = "rsync -avz -e '#{$remoteConnection[build]}' #{SRCDIR}/ #{dir} #{excludes}"
  end
  syncCmd
end

# optional connection command
def connect(build,command)
  cmd      = ''
  hostname = $hostnameOf[build]
  cmd << $remoteConnection[build] + " m300064@#{hostname} " if isRemote?(build)
  cmd << "'" if isRemote?(build)
  cmd << "source /etc/profile; [[ -f .profile ]] && source .profile; " if isRemote?(build)
  cmd << "cd #{$targetDir[build,false]};"

  # add module command - needed by ICONs configure
  cmd << command
  cmd << "'" if isRemote?(build)

  cmd
end

# caller for sync, config, build and run
def doSync(build)
  call(sync(build))
end
def doConfig(build)
  call(connect(build,$configureCall[build]))
end
def doBuild(build)
  call(connect(build,$buildCall[build]))
end
def doClean(build)
  call(connect(build,"make clean"))
end
def doCleanSync(build)
  call(connect(build,"rm -rf src support build"))
end
def doRunExp(build,exp,post=false)
  runScript = (post) ? 'post' : 'exp'
  runScript << '.' + exp +'.run'
  call(connect(build,"cd experiments/#{exp}; test -f #{exp}*.nc && rm #{exp}*.nc"))
  call(connect(build,<<-EOS
    ./make_runscripts #{exp}; 
    cd run;
    perl -pi.bak -e 's/submit=.*/submit=""/' #{runScript} ;
    ./exp.#{exp}.run;
    EOS
  ))
end
def doSubmit(build,exp,post=false)
  runScript = (post) ? 'post' : 'exp'
  runScript << '.' + exp +'.run'
  call(connect(build,<<-EOS
    cd run;
    perl -pi.bak -e 's/partition=mpi-compute/partition=mpi-develop/' #{runScript} ;
    sbatch ./#{runScript}
    EOS
  ))
end
def doSubmitExp(build,exp)
  doSubmit(build,exp)
end
def doSubmitPost(build,exp)
  doSubmit(build,exp,true)
end
def doRunPost(build,exp)
  call(connect(build,"./make_runscripts ; cd run;./post.#{exp}.run;"))
end
def doCheckExp(build,exp)
  call(connect(build,<<-EOS
    cd experiments/#{exp}; 
    for file in #{exp}*001.nc; do 
      echo '#==========================================================================='; 
      echo " $file";echo
      cdo sinfov $file;
    done
    EOS
  ))
  diagFile    = 'oce_diagnostics.txt'
  diagPlotter = 'scripts/postprocessing/tools/oceDiag.gp'
  call(connect(build,<<-EOS
    cd experiments/#{exp}; 
    if test -f #{diagFile}; then 
      LD_LIBRARY_PATH=/usr/lib SHOW=1 FILE=#{diagFile} gnuplot ../../#{diagPlotter}; 
    else echo 'No diagnostics avialable!';
    fi
    EOS
  ))
end
def doCheckPost(build,exp,ext)
  pattern = "*_#{exp}_*.#{ext}"
  displayWith = 'eps' == ext ? 'evince' : 'display'
  call(connect(build,"cd experiments/#{exp}/plots; if test -f $(ls -1 #{pattern} | head -1) ; then #{displayWith} #{pattern}; else echo 'No postprocessing avialable!';fi"))
end

$builds.each_key {|build|
  # regular tasks with all dependencies {
  desc "sync for build #{build.to_s}"
  task "#{build.to_s}_sync".to_sym do
    doSync(build)
  end
  desc "Configure for build #{build.to_s}"
  task "#{build.to_s}_conf".to_sym => ["#{build.to_s}_sync".to_sym] do
    doConfig(build)
  end
  desc "Build for build #{build.to_s}"
  task "#{build.to_s}_build".to_sym => ["#{build.to_s}_conf".to_sym] do
    doBuild(build)
  end
  desc "Clean repository for build #{build.to_s}"
  task "#{build.to_s}_clean".to_sym do
    doClean(build)
  end
  desc "Run for build #{build.to_s}"
  task "#{build.to_s}_run".to_sym , [:exp] => ["#{build.to_s}_build".to_sym] do |t, args|
    doRunExp(build,args.exp || DEFAULT_EXP)
  end

  #special thunder submits
  if /thunder/.match($builds[build][:host].to_s) then
    desc "Submit experiment on thunder for build #{build.to_s} (incl. preq.)"
    task "#{build.to_s}_submit".to_sym , [:exp] => ["#{build.to_s}_build".to_sym] do |t, args|
      doSubmitExp(build,args.exp || DEFAULT_EXP)
    end
    desc "Submit experiment on thunder for build #{build.to_s}"
    task "#{build.to_s}_submitOnly".to_sym , :exp, :post do |t, args|
      performPostproc = args.post.to_s.to_b || false
      if performPostproc then
        doSubmitPost(build,args.exp || DEFAULT_EXP)
      else
        doSubmitExp(build,args.exp || DEFAULT_EXP)
      end
    end
  end
  desc "Check output files"
  task "#{build.to_s}_check".to_sym , [:exp] => ["#{build.to_s}_run".to_sym] do |t, args|
    doCheckExp(build,args.exp || DEFAULT_EXP)
  end
  # post processing
  desc "Run post-processing on given exp (build:#{build.to_s})"
  task "#{build.to_s}_post".to_sym, [:exp]  do |t, args|
    doRunPost(build,args.exp || DEFAULT_EXP)
  end
  # check post processing
  desc "Display post-processing output for given exp (build:#{build.to_s})"
  task "#{build.to_s}_checkPost".to_sym, :exp, :ext  do |t, args|
    doCheckPost(build,
                args.exp || DEFAULT_EXP,
                args.ext || 'eps')
  end
  # }
  # TASKS FOR ONLY DO ONE SINGLE THING {
  desc "Configure for build #{build.to_s}"
  task "#{build.to_s}_confOnly".to_sym do
    doConfig(build)
  end
  desc "Build for build #{build.to_s}"
  task "#{build.to_s}_buildOnly".to_sym => ["#{build.to_s}_sync".to_sym] do
    doBuild(build)
  end
  desc "Run for build #{build.to_s}"
  task "#{build.to_s}_runOnly".to_sym, [:exp] => ["#{build.to_s}_sync".to_sym] do |t,args|
    doRunExp(build,args.exp || DEFAULT_EXP)
  end
  desc "Check output files"
  task "#{build.to_s}_checkOnly".to_sym , [:exp] => ["#{build.to_s}_sync".to_sym] do |t, args|
    doCheckExp(build,args.exp || DEFAULT_EXP)
  end
  # }

  desc "remove old source trees and sync"
  task "#{build.to_s}_cleanSync".to_sym do
    doCleanSync(build)
    doSync(build)
  end
}
desc "Sync source codes for all builds"
task :allSync do
  q = JobQueue.new
  $builds.each_key {|build| q.push { doSync(build) } }
  q.run
end
desc "Remove and Sync source codes for all builds"
task :allCleanSync do
  q = JobQueue.new
  $builds.each_key {|build| q.push { doCleanSync(build) } }
  q.run
end

# tasks for parallel run of other tasks
parTaskName = :par
desc "tasks for parallel run of other tasks"
task parTaskName do
  dbg(Rake.application.top_level_tasks)
  Rake.application.top_level_tasks.clear
  dbg(Rake::Task.tasks.find_all {|t| (ARGV - [parTaskName.to_s]).include?(t.name)})
  q = JobQueue.new
  (Rake::Task.tasks.find_all {|t| (ARGV - [parTaskName.to_s]).include?(t.name)}).each {|task|
    q.push { task.invoke }
  }
  q.run
end
# tasks for parallel run of other tasks in an Xtra terminal
[
  :parX,     # shut the terminal when finished
  :parXWait  # keep the terminal open when finished (shut with ENTER)
].each {|parTaskName|
  terminalEmulators = ['gnome-terminal','xterm']
  help = "parallel run of other tasks in an Xtra terminal"
  help += (parTaskName == :parX) ? " - shut at finish" : " - keep open at finish"
  desc help
  task parTaskName do
    dbg(Rake.application.top_level_tasks)

    # remote the task from the internal task list because they will be started in a sub-thread
    Rake.application.top_level_tasks.clear

    # create a task list from the command line
    ARGV.shift
    taskList = ARGV
    dbg(taskList)

    # parallel execution queue
    q = JobQueue.new

    # execute everything from the cmldline, which has a corresponding task
    (Rake::Task.tasks.find_all {|t| ARGV.include?(t.name)}).each {|t|
      cmd = (parTaskName == :parX) \
        ? "#{terminalEmulators[1]} -T 'rake #{t.name}' -e 'rake #{t.name};'" \
        : "#{terminalEmulators[1]} -T 'rake #{t.name}' -e 'rake #{t.name};read'"
      q.push {
        call(cmd)
      }
    }
    q.run
  end
}

desc "Check variables an user input"
task :check do
  {
    'SRCDIR' => SRCDIR,
    'REMOTE_USER' => REMOTE_USER,
    'WORKDIR' => WORKDIR,
    'RAKEFILE' => __FILE__,
  }.each {|k,v|
    puts [k.rjust(16,' '),v.ljust(20,' ')].join(': ')
  }
end

# vim:ft=ruby
