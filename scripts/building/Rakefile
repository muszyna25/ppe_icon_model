require 'minitest/autorun'
require 'open3'
require 'jobqueue'
require 'facets'
require 'iconPlot'
require 'rake/clean'
require 'tempfile'
require 'test/unit/assertions'
include Test::Unit::Assertions

# ============================================================================
# Please copy this file to the opt directory of you main working copy and 
# adjust the remote and local settings
# usage with the given configuration:
# * parallel build with gcc (locally) and nag (remotely)
#   rake parX localGcc_build remoteNag_build
# * synchronization of several remote build locations
#   rake par remoteDef_sync remoteIntel_sync remoteGccHi_sync
# * print our the commands before executing:
#   DEBUG=1 rake remoteGccHi_conf
# * print the commands without executing them
#   DRYRUN=1 rake remoteGccHi_conf
# ============================================================================
# AUTHOR: Ralf Mueller, ralf.mueller@zmaw.de
# REQUIREMENTS: 
# * ruby-1.9.* or higher (use with 'module load ruby')
# * jobQueue (rubygem, install with 'gem install jobQueue --user-install)
# ============================================================================
# user account on all remote machines
REMOTE_USER = 'm300064'

# local master source code directory
SRCDIR      = ENV.has_key?('SRCDIR')? ENV['SRCDIR'] : '.'
WORKDIR     = File.expand_path('.')
# remote runscripts
DEFAULT_EXP = 'test_oce_default'
#plotter
@plotter = IconPlot.new

# basic host setup
$hosts = {
  # local port forwarding setup for thunder4 and 5
  # cat .ssh/config
  #Host thunder
  #HostName login.zmaw.de
  #LocalForward 50022 thunder5.zmaw.de:22
  #LocalForward 40022 thunder4.zmaw.de:22

  :thunder4 => {
    :user     => REMOTE_USER,
    :hostname => 'localhost',
    :port     => 40022,
   #:hostname => 'thunder4.zmaw.de', # use from internal net if login node is down
    :dir      => '/scratch/mpi/mh0287/users/m300064/builds/remote/icon' },
  :thunder5 => {
    :user     => REMOTE_USER,
    :hostname => 'localhost',
    :port     => 50022,
   #:hostname => 'thunder5.zmaw.de',# use from internal net if login node is down 
    :dir      => '/scratch/mpi/mh0287/users/m300064/builds/remote/icon' },
  :passat => {
    :user     => REMOTE_USER,
    :hostname => 'passat.dkrz.de',
    :dir      => '/work/mh0287/users/ram/builds'},
  :wizard => {
    :user     => REMOTE_USER,
    :hostname => 'wizard.dkrz.de',
    :dir      => '/work/mh0287/users/ram/builds'},
  # laptop on my desk
  :thingol => {
    :dir => '/home/ram/builds/icon' }
}
# naming conventions:
# * local builds start with 'local'
# * remote builds start with 'remote'
$builds = {
  :localGcc          => {:host => :thingol , :subdir => 'gcc'}     ,
  :localIntel        => {:host => :thingol , :subdir => 'intel',:CC => 'intel'}     ,
  :localIntelHi      => {:host => :thingol , :subdir => 'intel-hiopt',:CC => 'intel'}     ,
  :localCmake        => {:host => :thingol , :subdir => 'cmake'}     ,
  :localGccHi        => {:host => :thingol , :subdir => 'gcc-hiopt', :CC => 'gcc'      , :FLAGS => 'hiopt'},
  :localGprof        => {:host => :thingol , :subdir => 'gprof'}   ,
  :localOpenMP       => {:host => :thingol , :subdir => 'openmp'   ,                     :FLAGS => 'hiopt' , :openmp => true}  ,
  :localNag          => {:host => :thingol , :subdir => 'nag'      , :CC => 'nag'}     ,
  :localSun          => {:host => :thingol , :subdir => 'sun'      , :CC => 'sun'      ,:preConf => 'PATH=$HOME/local/solarisstudio12.3/bin:$PATH', :preBuild => 'PATH=$HOME/local/solarisstudio12.3/bin:$PATH'},
  :localTest         => {:host => :thingol , :subdir => 'test'     , :CC => 'nag'}     ,
  :remoteSerial      => {:host => :thunder4, :subdir => 'serial'   ,                    :confOpts => '--without-mpi'}    ,
  :remoteCmake       => {:host => :thunder4, :subdir => 'cmake'}   ,
  :remoteGccHi       => {:host => :thunder5, :subdir => 'gcc'      , :CC => 'gcc'      , :FLAGS => 'hiopt'},
  :remoteGccHiOpenMP => {:host => :thunder5, :subdir => 'gcc-opemp', :CC => 'gcc'      , :FLAGS => 'hiopt' , :openmp => true},
  :remoteNag         => {:host => :thunder4, :subdir => 'nag'      , :CC => 'nag'}     ,
  :remoteIntel       => {:host => :thunder4, :subdir => 'intel'    , :CC => 'intel'}   ,
  :remotePgi         => {:host => :thunder4, :subdir => 'pgi'      , :CC => 'pgi'}     ,
  :remoteXlf         => {:host => :wizard  , :subdir => 'default'} ,
  :remoteIntelW      => {:host => :wizard  , :subdir => 'intel', :CC => 'intel' } ,
  :remoteXlfHi       => {:host => :passat  , :subdir => 'hiopt'    , :FLAGS => 'hiopt'}
}
# ============================================================================

# run the commands and try to get back stdout or possible error messages
def call(cmd,unthreadded=false)
  unless ENV['DRYRUN'].nil?
    puts cmd
    return
  end
  dbg(cmd)
  if unthreadded then
    puts IO.popen(cmd).read
  else
    Open3.popen3(cmd) do |stdin, stdout, stderr, external|
      # read from stdout and stderr in parallel
      { :out => stdout, :err => stderr }.each {|key, stream|
        Thread.new do
          until (line = stream.gets).nil? do
            puts line
          end
        end
      }

      # Don't exit until the external process is done
      external.join
    end
  end
end

# debug output for any type of object
def dbg(msg)
  pp msg unless ENV['DEBUG'].nil?
end

# check for the naming convention to distinguish remote from local builds
def isLocal?(build);  true if 'local' == build.to_s[0,5]; end
def isRemote?(build); not isLocal?(build); end

# hide some complex hash accesses
# {
$hostOf = lambda {|build| 
  host = $builds[build][:host]
}
$hostnameOf = lambda {|build|
  host = $hostOf[build]
  $hosts[host][:hostname].nil? ? host.to_s : $hosts[host][:hostname]
}
# }

# compute the directory where to (possible remote) code is
$targetDir = lambda {|build,withHost=true,revision=nil|
  dir      = ''
  host     = $hostOf[build]
  hostname = $hostnameOf[build]
  dir << "m300064@#{hostname}:" if isRemote?(build) and withHost
  dir << $hosts[host][:dir] + '/' + $builds[build][:subdir]
  dir << "/r#{revision.to_s}" unless revision.nil?

  dir
}

# ssh connection command line
$remoteConnection = lambda {|build|
  hostname  = $hostnameOf[build]
  portSpec  = $hosts[$hostOf[build]][:port].nil? ? '' : "-p #{$hosts[$hostOf[build]][:port]}"
  "ssh #{portSpec}"
}

# configure for a given build call wrt. to given options
$configureCall = lambda {|build|
  configureCall = ''
  if /cmake/i.match(build.to_s) then
  configureCall << './cmake.configure'
  else
  configureCall << "#{$builds[build][:preConf]};" unless $builds[build][:preConf].nil?
  configureCall << "COMPILER=#{$builds[build][:CC].nil? ? 'gcc' : $builds[build][:CC]} "
  configureCall << './configure'
  configureCall << " --with-fortran=#{$builds[build][:CC]}" unless $builds[build][:CC].nil?
  configureCall << " --with-flags=#{$builds[build][:FLAGS]}" unless $builds[build][:FLAGS].nil?
  configureCall << " --with-openmp" unless $builds[build][:openmp].nil?
  configureCall << " " << $builds[build][:confOpts] if $builds[build].has_key?(:confOpts)
  configureCall << " ;"
  end
  configureCall
}

# build call
$buildCall = lambda {|build|
  procs = ENV.has_key?('PROCS') ? ENV['PROCS'] : 1
  buildCall = ''
  if /cmake/i.match(build.to_s) then
  buildCall << "make -j #{procs};"
  else
  buildCall << $builds[build][:preBuild]  << ';' unless $builds[build][:preBuild].nil?
  buildCall << './build_command;'
  end
  buildCall
}

# ============================================================================
# global tempfile array: little hack because the call generator does not really
# call the system command
$_temps = []
# synchronization call for given build
def sync(build)
  dir      = $targetDir[build]
  rsyncOpts = "--delete-excluded --delete"
  rsyncOpts = ""

  file = Tempfile.new("rsyncIconTempfiles2Transfer")
  $_temps << file
  myFile = file.path
  file.write(`git ls-files | grep -v -E '^(data|doc)'`)
  file.write("\n")
  file.write(`find src/lnd_phy_jsbach -name "*.f90"`)
  # add non-added runscripts
  file.write(Dir.glob("run/{exp,post}*").delete_if {|v| /\.run$/.match(v)}.join("\n"))
  # add grids directory for local external data
  file.write(Dir.glob("grids/*.nc").join("\n") + "\n")
  file.write("config/mh-override\n") if isLocal?(build)
  file.close
  system("cat #{file.path}") if  ENV.has_key?('DEBUG')

  if isLocal?(build)
    syncCmd = "rsync #{rsyncOpts} -avz --files-from=#{myFile} . #{dir}"
  else
    syncCmd = "rsync #{rsyncOpts} -avz --files-from=#{myFile}  -e '#{$remoteConnection[build]}' . #{dir}"
  end
  syncCmd
end

# optional connection command
def connect(build,command,targetDir=$targetDir[build,false])
  cmd      = ''
  hostname = $hostnameOf[build]
  cmd << $remoteConnection[build] + " m300064@#{hostname} " if isRemote?(build)
  cmd << "'" if isRemote?(build)
  cmd << "source /etc/profile; [[ -f .profile ]] && source .profile; " if isRemote?(build)
  cmd << "cd #{targetDir};"

  # add module command - needed by ICONs configure
  cmd << command
  cmd << "'" if isRemote?(build)

  cmd
end

# check all possible accumulated variables
def checkAcc(build,exp,var)
  call(connect(build,<<-EOS
      cd experiments/#{exp};
      var=#{var} ruby -rcdo <<-EOR
      ofiles        = Dir.glob("#{exp}*.nc")
      names         = Cdo.showname(input: ofiles[0])[0].split
      acc_names     = names.grep(/_acc/)
      non_acc_names = acc_names.map {|n| n[0..-5]}
      # collect variable with have acc and spot values in the output file
      vars2check    = non_acc_names.select {|name| names.include?(name) }
      vars2check    = vars2check.grep(/\#{ENV["var"]}/) if ENV["var"] != "__ALL"
      vars2check.each {|var2check|
        ofiles.each {|ofile|
          result = Cdo.diffv(input: " -selname," + var2check + " " + ofile +
                              " -selname," + var2check + "_acc" + " " + ofile)
          unless result.empty? then
            puts "CHECK ACCUMULATION in FILE:" + ofile + " with VAR:" + var2check
            pp result
          else
            puts "ZERO diff for " + var2check + " (file:" + ofile + ")"
          end
      }}
EOR
   EOS
  ))
end

# simple varnames check
def checkNames(build,exp)
  call(connect(build,<<-EOS
      cd experiments/#{exp};
      for file in $(ls -rc #{exp}*.nc*); do
        echo '#===========================================================================';
        echo " $file";echo
        cdo showname  $file
      done
      EOS
      ),true)
end

# check a single variable with infov
def checkVar(build,exp,varname,timestep,level)
  call(connect(build,<<-EOS
      cd experiments/#{exp};
      for file in $(ls -rc #{exp}*.nc*); do
         selectOP='';
         if [ #{timestep} -ne 0 ]; then
           selectOP="$selectOP -seltimestep,#{timestep}";
         fi
         if [ #{level} -ne 0 ]; then
           selectOP="$selectOP -sellevidx,#{level}";
         fi
         cdo infov -selname,#{varname} $selectOP $file
      done
      EOS
  ))
end

# plot a plot from output file
def showPlot(build,exp,var='t',timestep=0,level=0)
  call(connect(build,<<-EOS
      cd experiments/#{exp};
      var=#{var} timestep=#{timestep} level=#{level} ruby -rcdo -riconPlot <<-EOR
      ofiles        = Dir.glob("#{exp}*.nc")
      names         = Cdo.showname(input: ofiles[0])[0].split
      var          = ENV["var"]
      timestep     = ENV["timestep"]
      level        = ENV["level"]
      plotter      = IconPlot.new()
      plotter.display = "display"
      plotter.debug = true
      ofiles.each {|ofile|
        puts "Check file " +ofile
        plotter.show(plotter.scalarPlot(ofile,ofile,var,mapType: "ortho",timeStep: timestep,levIndex: level))
      }
EOR
   EOS
  ))
end

# display the online diagnostics
def showOnlineDiag(build,exp)
  diagFile    = 'oce_diagnostics.txt'
  diagPlotter = 'scripts/postprocessing/tools/oceDiag.gp'
  call(connect(build,<<-EOS
      cd experiments/#{exp};
      if test -f #{diagFile}; then
        LD_LIBRARY_PATH=/usr/lib SHOW=1 FILE=#{diagFile} gnuplot ../../#{diagPlotter};
      else echo 'No diagnostics avialable!';
      fi
   EOS
  ))
end

# show diff between two files
def doDiffThis(build,fA,fB,tool='meld')
  dbg("tool=#{tool}")
  dbg("fA=#{fA}")
  dbg("fB=#{fB}")
  call(connect(build,<<-EOS
     #{[tool,fA,fB].join(' ')}
   EOS
  ))
end

# caller for sync, config, build and run
def doSync(build)
  call(sync(build))
end
def doCheckoutRev(build,rev,url)
  dir  = $targetDir[build]+'/'+rev.to_s
  revTag = rev == 'HEAD' ? '' : "-r#{rev}"
  call(connect(build,<<-EOS
      [[ ! -d r#{rev} ]] && mkdir -p r#{rev};
      cd r#{rev}; 
      if [[ -d .svn ]];then
        svn revert -R .;
        svn update #{revTag};
      else
        svn checkout #{url} #{revTag} .;
      fi;
               EOS
              ))
end
def doConfig(build,rev=nil)
  call(connect(build,$configureCall[build],$targetDir[build,false,rev]))
end
def doBuild(build,rev=nil)
  call(connect(build,$buildCall[build],$targetDir[build,false,rev]))
end
def doClean(build)
  call(connect(build,"make clean"))
end
def doCleanSync(build)
  call(connect(build,"rm -rf src support build"))
end
def doRunExp(build,exp,post=false)
  runScript = (post) ? 'post' : 'exp'
  runScript << '.' + exp +'.run'
  call(connect(build,"cd experiments/#{exp}; test -f $(echo #{exp}*.nc* | cut -d ' ' -f 1) && rm #{exp}*.nc*"))
  call(connect(build,<<-EOS
      cd experiments/#{exp};
      test -f $(echo #{exp}*.nc | cut -d \' \' -f 1) && rm #{exp}*.nc
               EOS
              ))
              call(connect(build,<<-EOS
      ./make_runscripts #{exp};
      cd run;
      perl -pi.bak -e 's/submit=.*/submit=""/' #{runScript} ;
      ./exp.#{exp}.run;
                           EOS
                          ),true)
end
def doSubmit(build,exp,post=false)
  runScript = (post) ? 'post' : 'exp'
  runScript << '.' + exp +'.run'
  call(connect(build,<<-EOS
      cd run;
      perl -pi.bak -e 's/partition=mpi-compute/partition=mpi-develop/' #{runScript} ;
      sbatch ./#{runScript}
      EOS
              ))
end
def doSubmitExp(build,exp)
  doSubmit(build,exp)
end
def doSubmitPost(build,exp)
  doSubmit(build,exp,true)
end
def doRunPost(build,exp)
  call(connect(build,"./make_runscripts ; cd run;./post.#{exp}.run;"))
end
def doCmpExps(build,expA,expB)
  call(connect(build,<<-EOS
      cd experiments/;
      fileA=$(ls -1 #{expA}/#{expA}*.nc | head -1);
      fileB=$(ls -1 #{expA}/#{expA}*.nc | head -1);
      cdo diffv $fileA $fileB
               EOS
              ),true)
end
def doCheckExp(build,exp)
  var = ENV.has_key?('VAR') ? ENV['VAR']      : '__ALL'
  ts  = ENV.has_key?('TS')  ? ENV['TS'].to_i  : 0
  lev = ENV.has_key?('LEV') ? ENV['LEV'].to_i : 0
  if ENV.has_key?('CHECK') then
    checks = ENV['CHECK'].split(',')
    checks.each {|check|
      case check
      when 'acc' then
        checkAcc(build,exp,var)
      when 'plot' then
        var = 't' if '__ALL' == var
        showPlot(build,exp,var,ts,lev)
      when 'diag'
        showOnlineDiag(build,exp)
      when 'var'
	checkVar(build,exp,var,ts,lev)
      else
        checkNames(build,exp)
      end
    }
  else
    checkNames(build,exp)
    showOnlineDiag(build,exp) if ENV.has_key?('SHOW')
    checkAcc(build,exp,var)
  end
end
def doCheckPost(build,exp,ext)
  pattern = "*_#{exp}_*.#{ext}"
  displayWith = 'eps' == ext ? 'evince' : 'display'
  call(connect(build,<<-EOS
      cd experiments/#{exp}/plots;
      if test -f $(ls -1 #{pattern} | head -1) ; then
               #{displayWith} #{pattern};
      else
        echo 'No postprocessing avialable!';
      fi
               EOS
              ))
end

$builds.each_key {|build|
  # regular tasks with all dependencies {
  desc "sync for build #{build.to_s}"
  task "#{build.to_s}_sync".to_sym do
    doSync(build)
  end
  desc "Configure for build #{build.to_s}"
  task "#{build.to_s}_conf".to_sym => ["#{build.to_s}_sync".to_sym] do
    doConfig(build)
  end
  desc "Build for build #{build.to_s}"
  task "#{build.to_s}_build".to_sym => ["#{build.to_s}_conf".to_sym] do
    doBuild(build)
  end
  desc "Clean repository for build #{build.to_s}"
  task "#{build.to_s}_clean".to_sym do
    doClean(build)
  end
  desc "Run for build #{build.to_s}"
  task "#{build.to_s}_run".to_sym , [:exp] => ["#{build.to_s}_build".to_sym] do |t, args|
    doRunExp(build,args.exp || DEFAULT_EXP)
  end

  #special thunder submits
  if /thunder/.match($builds[build][:host].to_s) then
    desc "Submit experiment on thunder for build #{build.to_s} (incl. preq.)"
    task "#{build.to_s}_submit".to_sym , [:exp] => ["#{build.to_s}_build".to_sym] do |t, args|
      doSubmitExp(build,args.exp || DEFAULT_EXP)
    end
    desc "Submit experiment on thunder for build #{build.to_s}"
    task "#{build.to_s}_submitOnly".to_sym , :exp, :post do |t, args|
      performPostproc = args.post.to_s.to_b || false
      if performPostproc then
        doSubmitPost(build,args.exp || DEFAULT_EXP)
      else
        doSubmitExp(build,args.exp || DEFAULT_EXP)
      end
    end
  end
  desc "Check output files"
  task "#{build.to_s}_check".to_sym , [:exp] => ["#{build.to_s}_run".to_sym] do |t, args|
    doCheckExp(build,args.exp || DEFAULT_EXP)
  end
  desc "Compare outputs of two experiments"
  task "#{build.to_s}_cmp".to_sym, [:expA,:expB] => ["#{build.to_s}_run".to_sym] do |t, args|
    doCmpExps(build,args.expA,args.expB)
  end

  # post processing
  desc "Run post-processing on given exp (build:#{build.to_s})"
  task "#{build.to_s}_post".to_sym, [:exp] => ["#{build.to_s}_sync".to_sym] do |t, args|
    doRunPost(build,args.exp || DEFAULT_EXP)
  end
  # check post processing
  desc "Display post-processing output for given exp (build:#{build.to_s})"
  task "#{build.to_s}_checkPost".to_sym, :exp, :ext  do |t, args|
    doCheckPost(build,
                args.exp || DEFAULT_EXP,
                args.ext || 'eps')
  end
  # diff two text files with (option) tool
  desc "diff two text files with (option) tool"
  task "#{build.to_s}_diff".to_sym, :fA, :fB, :tool  do |t, args|
    tool =  'meld' if args.tool.nil?
    doDiffThis(build,args.fA, args.fB, tool)
  end

  # }
  # TASKS FOR ONLY DO ONE SINGLE THING {
  desc "Configure for build #{build.to_s}"
  task "#{build.to_s}_confOnly".to_sym do
    doConfig(build)
  end
  desc "Build for build #{build.to_s}"
  task "#{build.to_s}_buildOnly".to_sym => ["#{build.to_s}_sync".to_sym] do
    doBuild(build)
  end
  desc "Run for build #{build.to_s}"
  task "#{build.to_s}_runOnly".to_sym, [:exp] => ["#{build.to_s}_sync".to_sym] do |t,args|
    doRunExp(build,args.exp || DEFAULT_EXP)
  end
  desc "Check output files"
  task "#{build.to_s}_checkOnly".to_sym , [:exp] => ["#{build.to_s}_sync".to_sym] do |t, args|
    doCheckExp(build,args.exp || DEFAULT_EXP)
  end
  desc "Compare outputs of two experiments"
  task "#{build.to_s}_cmpOnly".to_sym, [:expA,:expB] => ["#{build.to_s}_sync".to_sym] do |t, args|
    doCmpExps(build,args.expA,args.expB)
  end
  # }

  desc "remove old source trees and sync"
  task "#{build.to_s}_cleanSync".to_sym do
    doCleanSync(build)
    doSync(build)
  end

  desc "build special revision"
  task "#{build.to_s}_buildRev".to_sym, [:rev,:url] do |t,args|
    doCheckoutRev(build,args.rev,args.url)
    doConfig(build,args.rev)
    doBuild(build,args.rev)
  end
}
desc "Sync source codes for all builds"
task :allSync do
  q = JobQueue.new
  $builds.each_key {|build| q.push { doSync(build) } }
  q.run
end
desc "Remove and Sync source codes for all builds"
task :allCleanSync do
  q = JobQueue.new
  $builds.each_key {|build| q.push { doCleanSync(build) } }
  q.run
end

# tasks for parallel run of other tasks in an Xtra terminal
[
  :par,      # execute everything in the calling terminal
  :parX,     # shut the terminal when finished
  :parXWait  # keep the terminal open when finished (shut with ENTER)
].each {|parTaskName|
  terminalEmulators = ['gnome-terminal','xterm']
  help = case parTaskName
         when :par then
           "execute all tasks in parallel"
         when :parX then
           "parallel run of other tasks in an Xtra terminal - shut when finished"
         when :parXWait then
           "parallel run of other tasks in an Xtra terminal - keep open when finished"
         else
           warn "Unknown task"
           exit 1
         end
  desc help
  task parTaskName do
    dbg(Rake.application.top_level_tasks)

    # remote the task from the internal task list because they will be started in a sub-thread
    Rake.application.top_level_tasks.clear

    # create a task list from the command line
    ARGV.shift
    taskList = ARGV
    dbg(taskList)

    # parallel execution queue
    q = JobQueue.new

    # execute everything from the cmldline, which has a corresponding task
    taskList.each {|taskName|
      dbg(taskName)

      case parTaskName
      when :par then
        task = Rake::Task.tasks.find {|t| taskName == t.name }
        if task.nil? then
          warn "Unkown task: #{taskName}"
          exit 2
        else
          q.push { task.invoke }
        end

      when :parX,:parXWait
        cmd     = "#{terminalEmulators[1]} -T 'rake #{taskName}' -e 'rake #{taskName};'"
        cmd[-1] = "read'" if :parXWait == parTaskName
        q.push { call(cmd) }

      end
    }
    q.run
  end
}

desc "Check variables an user input"
task :check ,[:p] do |t,args|
  pp args
  {
    'SRCDIR' => SRCDIR,
    'REMOTE_USER' => REMOTE_USER,
    'WORKDIR' => WORKDIR,
    'RAKEFILE' => __FILE__,
  }.each {|k,v|
    puts [k.rjust(16,' '),v.ljust(20,' ')].join(': ')
  }
end

# vim:ft=ruby
