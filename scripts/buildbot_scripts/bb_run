#!/bin/ksh
#------------------------------------------------------------------------------
# This script is called on all buildbot slaves and should be used to call
# test jobs or performance jobs.
# The buildbot server sets the two environment variable BB_SYSTEM and BB_SLAVE
#
# +---------------+-----------+---------------+
# | builder       | BB_SYSTEM |   BB_SLAVE    |
# +---------------+-----------+---------------+
# | BLIZZ_nMnO    | blizzard  | blizz_nMnO    |
# | BLIZZ_nMyO    | blizzard  | blizz_nMyO    |
# | BLIZZ_yMnO    | blizzard  | blizz_yMnO    |
# | BLIZZ_yMyO    | blizzard  | blizz_yMyO    |
# |               |           |               |
# | SQUALL_gcc    | squall    | squall_gcc    |
# | SQUALL_nag    | squall    | squall_nag    |
# | SQUALL_intel  | squall    | squall_intel  |
# | SQUALL_pgi    | squall    | squall_pgi    |
# | SQUALL_sun    | squall    | squall_sun    |
# |               |           |               |
# | TORNADO_gcc   | tornado   | tornado_gcc   |
# | TORNADO_nag   | tornado   | tornado_nag   |
# | TORNADO_intel | tornado   | tornado_intel |
# | TORNADO_pgi   | tornado   | tornado_pgi   |
# | TORNADO_sun   | tornado   | tornado_sun   |
# |               |           |               |
# +---------------+-----------+---------------+
#
# More info for 'builder' can be find on 
#	http://buildbot.zmaw.de:8011/buildslaves
# or
# 	http://buildbot.zmaw.de:8011/waterfall
#
#------------------------------------------------------------------------------
# First version by Walter Sauf (MPI-M, 2009-10-22)
#
# $Rev$:     Revision of last commit
# $Author$:  Author of last commit
# $Date$:    Date of last commit
#------------------------------------------------------------------------------

#Define of the text which is written in case of a script fail or OK run

TEXT_RUN_FAILED="FAILED"
TEXT_RUN_OK="OK"
use_exp_list="false"
build_post_file="true"
RUN_POST=""
RUN_POST_COMP=""

#==============================================================================
#
# With this function it is possible to stop or continue this script after an 
# error  The function has two parameter. The first one must be a return status. 
# The second one has to be 'TRUE' or 'FALSE'. If the second parameter is 'TRUE'
# and the return status is unequal '0' the script exit with the return status.
# In all other cases the script continues running the script.
# Because on the blizzard machine llsubmit returns allways "OK" we are using
# the helpfile .status 
#
#==============================================================================
#==============================================================================
stop_on_error()
{
# Check if the first parameter (return status) is not OK
    echo STATUS_IN_FILE ${STATUS_IN_FILE}
    if [[ $1 -ne 0 || ${STATUS_IN_FILE} -ne 0 ]] 
    then
      if [[ $1 -ne 0 ]] 
      then
        printf '%-50s : %s \n' $2 ${TEXT_RUN_FAILED} >> ../${LOOP_STATUS_FILE}
        exit $1
      else
        printf '%-50s : %s\n' $2 ${TEXT_RUN_FAILED} >> ../${LOOP_STATUS_FILE}
        exit ${STATUS_IN_FILE}
      fi
    fi

    printf '%-50s : %s\n' $2 ${TEXT_RUN_OK} >> ../${LOOP_STATUS_FILE}
}

#------------------------------------------------------------------------------------

warning_on_error()
{
# Check if the first parameter (return status) is not OK
    if [[ $1 -ne 0 || ${STATUS_IN_FILE} -ne 0 ]] 
    then
      if [[ $1 -ne 0 ]] 
      then
        printf '%-50s : %s \n' $2 ${TEXT_RUN_FAILED} >> ../${LOOP_STATUS_FILE}
        echo "*********** WARNING: script failed  $1 ****************"
      else
        printf '%-50s : %s \n' $2 ${TEXT_RUN_FAILED} >> ../${LOOP_STATUS_FILE}
        echo "*********** WARNING: script failed  ${STATUS_IN_FILE} ****************"
      fi
    else
      printf '%-50s : %s\n' $2 ${TEXT_RUN_OK} >> ../${LOOP_STATUS_FILE}
      if [ "${build_post_file}" == "true" ]
      then
        name="`echo $2 | cut -d '.' -f2`"
        RUN_POST="${RUN_POST} post.${name}.run"
        echo "${RUN_POST}" > ./run_post_list
        
        RUN_POST_COMP="${RUN_POST_COMP} post.${name}_compare-restart.run"
        if [  -a ./${RUN_POST_COMP} ] ; then
          echo "${RUN_POST_COMP}" > ./run_post_comp_list
        fi
      fi
    fi
}

#------------------------------------------------------------------------------------

return_ok()
{
    # Exit with status = 0 = OK
    # Arguments:
    #   $1 =  message
    echo "return_ok()"
    echo "$1"

    exit 0
}

#------------------------------------------------------------------------------------
set_section_info ()
{
  lists=`echo $1 | sed s/,/\ /g`
  lists=`echo $lists | sed s/:/\ /g`

  for s in $lists
  do
    case ${s} in
      grid)
         run_GRID=1
         run_ALL=0
         ;;
      all)
         run_ALL=1
         ;;
      exp)
         run_EXP=1
         run_ALL=0
         ;;
      post)
         run_POST=1
         run_ALL=0
         ;;

        *)
          echo "Wrong Parameter(s) in -section part"
          echo "!!! Please some examples below:"
          echo " "
          echo "bb_run  [-section=grid]"
          echo "bb_run  [-section=grid,exp]"
          echo "bb_run  [-section=grid,exp,post]"
          echo "bb_run  [-section=all]"
          echo " "
          exit 1
          ;;
      esac
  done

}
#------------------------------------------------------------------------------------
set_test_list ()
{
  use_exp_list="true"

  lists=`echo $1 | sed s/,/\ /g`
  lists=`echo $lists | sed s/:/\ /g`

  if [ -a ./run_exp_list ]
  then
    rm -f ./run_exp_list
  fi

  touch ./run_exp_list

  for list in ${lists}
  do
   echo "exp.${list}.run " >> ./run_exp_list
  done
}
#==============================================================================


#==============================================================================
# runs the scrpits ./$1/$2
run_scripts()
{
  if [ "x${submit}" == "x" ] ; then
    run_scripts_nosubmit $1 $2
  else
    run_scripts_submit $1 $2
  fi
}


#==============================================================================
# runs the scrpits ./$1/$2
run_scripts_nosubmit()
{
# Change to directory 'run' 
  echo "run_scripts $1"
  cd $1

  
  for EXP_FILE in $EXP_FILES
  do 
    echo "---------------------------------------------------------"
    echo " "
    echo " Start new Script: ${EXP_FILE} at $(date)"
    echo " "
    echo "---------------------------------------------------------"
    echo "Start. ./$EXP_FILE"
    ./$EXP_FILE > LOG.${EXP_FILE}.o 2>&1
    STATUS=$?
    cat LOG.${EXP_FILE}.o
    echo "---------------------------------------------------------"
    echo " "
    echo " Script: ${EXP_FILE} stops at $(date)"
    echo " "
    echo "---------------------------------------------------------"

    if [ x${STATUS_FILE} != "x" ]
    then
      if [ -r ${STATUS_FILE} ]
      then
        STATUS_IN_FILE=`cat ${STATUS_FILE}`
      else
        STATUS_IN_FILE=""
      fi
    else
      STATUS_IN_FILE=""
    fi

    $stop_check $STATUS $EXP_FILE
  
  done

  cd ..

}


#==============================================================================
# runs the scrpits ./$1/$2
run_scripts_submit()
{

  if [ $submit = "nqsub" ] 
  then
    echo "====================================================================================== "
    echo "                  "
    echo "The job is not send to the SX9 because of problems in "
    echo "synchronizing jobs by using nqsub "
    echo "                  "
    echo "====================================================================================== "
    STATUS=1
    return
  fi

# Change to directory 'run' 
  echo "run_scripts $1"
  cd $1

  for EXP_FILE in $EXP_FILES
  do 
    run_command="$submit $sync ./$EXP_FILE"

    echo "---------------------------------------------------------"
    echo " Submit new Script: ${EXP_FILE} at $(date)"
    echo " $run_command "
    echo "---------------------------------------------------------"

    echo $run_command > submit.$EXP_FILE
    chmod +x submit.$EXP_FILE        
    ./submit.$EXP_FILE &    
  
  done

  # wait for all jobs to finish
  wait
  sleep 10
  
  # print and check the results
  for EXP_FILE in $EXP_FILES
  do
    
    echo "---------------------------------------------------------"
    echo " "
    echo " Start of ${EXP_FILE}"
    echo " "
    echo "---------------------------------------------------------"
    cat LOG.$EXP_FILE.*
    echo "---------------------------------------------------------"
    echo " "
    echo " End of ${EXP_FILE}"
    echo " "
    echo "---------------------------------------------------------"

    STATUS_IN_FILE=""
    if [ -r $EXP_FILE.status ]
    then
     STATUS_IN_FILE=`cat ${EXP_FILE}.status`
    fi

    $stop_check 0 $EXP_FILE
  done
  
  cd ..

}


#==============================================================================
#
#  Start of script
#
#==============================================================================

# Set default values
run_ALL=1
run_GRID=0
run_EXP=0
run_POST=0
target="NotSet"
use_list=0

scriptname="bb_run.ksh"

echo "$scriptname: start"

#------------------------------------------------------------------------------

# Set target variable, which is used to select case specific parameters from a
# built in data base.

if   [ "x$1" != "x" ]          # --> from argument
then
  paras=`echo $@`
  for para in $paras
  do     
    p=`echo $para | cut -d '-' -f2 | cut -d '=' -f1`
    v=`echo $para | cut -d '=' -f2`
#    echo "p: $p v: $v"
    case ${p} in
      section)
        set_section_info "$v"
        ;;
      target)
        target="$v"
        source="argument"
        ;;
      test)
        if [ "x$v" != "xall" ]
        then
          set_test_list "$v"
        fi
        ;;
      *)
        echo "Wrong Parameter(s) $@"
        echo "!!! Please use:"
        echo " "
        echo "bb_run [-target=tornado_nag] [-section=grid,exp,post] -test=exp1,exp2"
        echo " "
        exit 1
        ;;
      esac
    done

fi

if [ "x$BB_SLAVE" != "x"  ]   # --> from environment variable BB_SLAVE
then

    target="$BB_SLAVE"
    source='$BB_SLAVE'

else                         # --> as default
  if [ "$target" == "NotSet" ]
  then
    target="default"
    source="$scriptname"
  else
    source="bb_run parameter"
  fi
fi

echo "$scriptname: target          = $target (source = $source)"



#------------------------------------------------------------------------------
# grids will be created by create_global_grids.run
# ln -s ../../../buildbot.grids grids

#------------------------------------------------------------------------------
# define which account to use, and recreate run scripts
# only effective on blizzard
echo "use_account_no=mh0287" >> ./config/set-up.info
./make_runscripts

#------------------------------------------------------------------------------\
# read set-up info
. ./config/set-up.info
submit=$use_submit

# define different parameter for SGE sync
# MPI -sync y
# DWD -W block=true

if   [ "x${submit}" != "x" ]
then
  case ${submit} in

    qsub)
      case ${use_site} in
        dwd.de)
          sync="-W block=true"
        ;;
        *)
          sync="-sync y"
        ;;
      esac
    ;;

    llsubmit)
      sync="-s"
    ;;

    qsubw)
      sync=""
    ;;

    nqsub)
      echo "====================================================================================== "
      echo "                  "
      echo "The job is not send to the SX9 because of problems in "
      echo "synchronizing jobs by using nqsub "
      echo "                  "
      echo "====================================================================================== "
      stop_on_error 1
      exit 1
      ;;

    *)
      echo "Unkown submit : $submit"
      stop_on_error 1
      exit 1
    ;;
  esac
fi

#-----------------------------------------------------------------------------
# load ../setting if exists  
if [ -a ./setting ]
then
  . ./setting
fi
#-----------------------------------------------------------------------------

#==============================================================
# create ICON grids

if [ "${run_ALL}" == "1" -o "${run_GRID}" -eq "1" ]
then

  echo "|======================================================|" 
  echo "|                                                      |"
  echo "|         Running grid-scripts                         |"
  echo "|                                                      |"
  echo "|======================================================|"

  LOOP_STATUS_FILE="LOOP_STATUS_GRID_FILE"
  rm -f ${LOOP_STATUS_FILE}


  stop_check="warning_on_error"
  build_post_file="false"
#   EXP_FILES="grid.create_nested_grids.run"
#   run_scripts run 
  EXP_FILES="grid.create_bb_grids.run"
  run_scripts run

# Check if a 'NOT successful' is in the status file?

  ALL_RUNS_OK=`grep ${TEXT_RUN_FAILED} ${LOOP_STATUS_FILE}`

  if [ $? == 0 ]
  then
    echo "One or more Grid-Runs were not successful"
    RETURN_STATUS=1
    exit 1
  else
    echo "All Grid-Runs were successful"
    RETURN_STATUS=0
  fi
fi

# if we run on the hpc_serial, copy the grids to the buildbot.grids
if [ x$target = "xhpc_serial"  ] ; then
  cp grids/* /e/uscratch/extwsauf/buildbot.grids
fi

################################################################

if [ "${run_ALL}" == "1" -o "${run_EXP}" -eq "1" ]
then

  echo "|======================================================|" 
  echo "|                                                      |"
  echo "|         Running exp-scripts                          |"
  echo "|                                                      |"
  echo "|======================================================|"

  LOOP_STATUS_FILE="LOOP_STATUS_EXP_FILE"

  rm -f ${LOOP_STATUS_FILE}
  rm -f ./run/run_post_list
  rm -f ./run/run_post_comp_list
  touch ./run/run_post_list
  touch ./run/run_post_comp_list

  stop_check="warning_on_error"
  build_post_file="true"

  if [ "${use_exp_list}" == "true" ] 
  then 
    echo "Run one or more special experiments"
    EXP_FILES=`cat ./run_exp_list`
    rm ./run_exp_list
  else
    echo "Run all exp.test_*.run in run directory"
    cd run
    EXP_FILES=`ls exp.test_*.run`
    cd ..
  fi

  run_scripts run

  ALL_RUNS_OK=`grep ${TEXT_RUN_FAILED} ${LOOP_STATUS_FILE}`

  if [ $? == 0 ]
  then
    echo "One or more Exp-Runs were not successful"
    RETURN_STATUS=1
  else
    echo "All Exp-Runs were successful"
    RETURN_STATUS=0
  fi

fi


#==============================================================

if [ "${run_ALL}" == "1" -o "${run_POST}" -eq "1" ]
then
  TARGET_TMP=`echo $target | cut -c1-3`
  echo "TARGET_TMP $TARGET_TMP"
  if [  "x${TARGET_TMP}" = "xsx9" ]
  then
     cp config/set-up.info config/set-up.info.bac
     echo  'use_target="hpc"' >> config/set-up.info
  #   ./configure postscripts setup=hpc
     ./make_post_runscripts
     cp config/set-up.info config/set-up.info.hpc
     cp config/set-up.info.bac config/set-up.info
  fi


  echo "|======================================================|"
  echo "|                                                      |"
  echo "|          Running postprocessing                      |"
  echo "|              $(date)                                 |"
  echo "|                                                      |"
  echo "|======================================================|"

  echo "POST Part"

  LOOP_STATUS_FILE="LOOP_STATUS_POST_FILE"

  rm -f ${LOOP_STATUS_FILE}
  stop_check="warning_on_error"
  build_post_file="false"

  if [  -a ./run/run_post_list ] 
  then 
    echo "Use special file ./run/run_post_list for post-script run"
    EXP_FILES=`cat ./run/run_post_list` 
  else
    echo "Run all post-script post.test_*.run"
    cd run
    EXP_FILES=`ls post.test_*.run`
    cd ..
  fi
  if [  -a ./run/run_post_comp_list ]
  then 
    echo "Use special file ./run/run_post_comp_list for post-script run"
    EXP_FILES="${EXP_FILES} `cat ./run/run_post_comp_list`"
  fi

  run_scripts run
  if [  -a ${LOOP_STATUS_FILE} ]
  then
 
    ALL_RUNS_OK=`grep ${TEXT_RUN_FAILED} ${LOOP_STATUS_FILE}`

    if [ $? == 0 ]
    then
      echo "One or more Post-Runs were not successful"
      RETURN_STATUS=1
    else
      echo "All Post-Runs were successful"
      RETURN_STATUS=0
    fi
  else
    echo "ALL Post-Runs were not successful"
    RETURN_STATUS=1
  fi
fi


echo "|======================================================|"
echo "|                                                      |"
echo "|           Ends                                       |"
echo "|              $(date)                                 |"
echo "|                                                      |"
echo "|======================================================|"

# return OK Status

exit ${RETURN_STATUS}

