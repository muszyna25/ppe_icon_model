# -*- python -*-
# ex: set syntax=python:

# This is a sample buildmaster config file. It must be installed as
# 'master.cfg' in your buildmaster's base directory (although the filename
# can be changed with the --basedir option to 'mktap buildbot master').

# It has one job: define a dictionary named BuildmasterConfig. This
# dictionary has a variety of keys to control different aspects of the
# buildmaster. They are documented in docs/config.xhtml .

import datetime
import sys
import os
import glob

sys.path.append("py")
reload(sys)
sys.setdefaultencoding('utf8')

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

c['buildHorizon'] = 250
c['eventHorizon'] = 50
c['logHorizon'] = 250

c['buildCacheSize'] = 150

####### BUILDSLAVES

# the 'slaves' list defines the set of allowable buildslaves. Each element is
# a BuildSlave object, which is created with bot-name, bot-password.  These
# correspond to values given to the buildslave's mktap invocation.

from buildbot.buildslave import BuildSlave
from buildbot.status     import mail

m = mail.MailNotifier(fromaddr="buildbot@zmaw.de", builders=[], relayhost="smtp.zmaw.de")

c['properties'] = {'section' : 'all',
                   'exp'     : 'all',
                   'make'    : 'yes',
                   'list'    : 'icon-dev',
	           'subdir' : 'default'
                  }

c['slaves'] = [BuildSlave("thunder" , "bot1passwd", notify_on_missing="help-buildbot@zmaw.de", missing_timeout=300)
              ,BuildSlave("daint_cpu" , "bot1passwd", notify_on_missing="help-buildbot@zmaw.de", missing_timeout=300)
              ,BuildSlave("mistral" , "bot1passwd", notify_on_missing="help-buildbot@zmaw.de", missing_timeout=300)
              ]

# to limit to two concurrent builds on a slave, use
#  c['slaves'] = [BuildSlave("thunder", "bot1passwd", max_builds=2)]

# 'slavePortnum' defines the TCP port to listen on. This must match the value
# configured into the buildslaves (with their --master option)
c['slavePortnum'] = 9988


####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes. Any class which implements IChangeSource can be
# put here: there are several in buildbot/changes/*.py to choose from.

#from buildbot.changes.pb import PBChangeSource
#c['change_source'] = PBChangeSource()

# For example, if you had CVSToys installed on your repository, and your
# CVSROOT/freshcfg file had an entry like this:
#pb = ConfigurationSet([
#    (None, None, None, PBService(userpass=('foo', 'bar'), port=2401)),
#    ])

# then you could use the following buildmaster Change Source to subscribe to
# the FreshCVS daemon and be notified on every commit:
#
#from buildbot.changes.freshcvs import FreshCVSSource
#fc_source = FreshCVSSource("127.0.0.1", 2401, "foo", "bar")
#c['change_source'] = fc_source

# or, use a PBChangeSource, and then have your repository's commit script run
# 'buildbot sendchange', or use contrib/svn_buildbot.py, or
# contrib/arch_buildbot.py :
#

def icon_svn_split_file(path):
    '''
        Split path into ICON branch and residual

        Paths in 'branches' needs to be checked for container directories,
        but 'tags' and 'trunk' both contain just a single subdirectory layer.
    '''
    pieces = path.split('/')
    # Branches in subdirectories should repeat the directory name
    if pieces[0] == 'branches' and pieces[2].startswith(pieces[1]):
        index = 3
    else:
        index = 2
    return ('/'.join(pieces[0:index]), '/'.join(pieces[index:]))

from buildbot.changes.pb import PBChangeSource
from buildbot.changes.svnpoller import SVNPoller
c['change_source'] = [
    PBChangeSource(),
    SVNPoller(
        svnurl = 'https://svn.zmaw.de/svn/icon',
        split_file = icon_svn_split_file,
        pollinterval = 1800
    )
]



####### SCHEDULERS

## configure the Schedulers

# WS 10*60 gibt wieviel Zeit zwischen dem Triggersignal und dem Start der builder liegen soll

from buildbot.scheduler import AnyBranchScheduler
from buildbot           import scheduler
from buildbot.schedulers.forcesched import ForceScheduler, StringParameter

# Definition of the default branch
default_Branch='trunk/icon-dev'
default_builder_list = [
    'THUNDER_gcc', 'THUNDER_intel_hybrid', 'THUNDER_nag',
    'DAINT_CPU_cce',
    'MISTRAL_intel_hybrid', 'MISTRAL_intel', 'MISTRAL_intel_openmp',
    'MISTRAL_gcc',
    'MISTRAL_nag', 'MISTRAL_nag_serial', 'MISTRAL_nag_mtime',
    'MISTRAL_ocean'
]

# Test changes on the default branch whenever they occur
# NOTE: currently disabled!
s1 = AnyBranchScheduler(
         name = 'main',
         branches = [default_Branch],
         treeStableTimer = 1*30,
         builderNames = default_builder_list
     )

# Test DWD's NWP branch every night at 1 AM, unless there were no changes.
n1 = scheduler.Nightly(
         name = 'nightly_nwp',
         properties = {'subdir' : 'nightly_nwp'},
         builderNames = ['THUNDER_doc'] + default_builder_list,
         branch = 'branches/icon-nwp/icon-nwp-dev',
         hour = 01,
         minute = 00,
         onlyIfChanged = True,
     )

# Force build buttons
f1 = ForceScheduler(
         name = "force",
         builderNames = default_builder_list,
         reason = StringParameter(
                      name = 'reason',
                      label = 'Reason for build:',
                      default = 'Enter reason here (or else!!!)',
                      size = 80,
                  )
     )

c['schedulers'] = [n1, f1]


####### BUILDERS

# the 'builders' list defines the Builders. Each one is configured with a
# dictionary, using the following keys:
# - name              (required): the name used to describe this builder
# - slavename         (required): which slave to use (must appear in c['bots'])
# - builddir          (required): which subdirectory to run the builder in
# - factory           (required): a BuildFactory to define how the build is run
# - periodicBuildTime (optional): if set, force a build every N seconds

# buildbot/process/factory.py provides several BuildFactory classes you can
# start with, which implement build processes for common targets (GNU
# autoconf projects, CPAN perl modules, etc). The factory.BuildFactory is the
# base class, and is configured with a series of BuildSteps. When the build
# is run, the appropriate buildslave is told to execute each Step in turn.

# the first BuildStep is typically responsible for obtaining a copy of the
# sources. There are source-obtaining Steps in buildbot/steps/source.py for
# CVS, SVN, and others.

from buildbot.process     import factory
from buildbot.steps       import source, shell
from buildbot.steps.shell import ShellCommand
from buildbot.steps.transfer import DirectoryUpload
from buildbot.process.properties import WithProperties
from buildbot.status.builder import FAILURE, SKIPPED
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

work_dir = shell.WithProperties("%s", "subdir")

# ================================================================

class ICON_RunExp(ShellCommand):

   from build_interfaces import get_EXPNAME
   name="exp"
   usePTY=True
   description="bb_run"

   def start(self):
      sect = self.getProperty("section")
      l = sect.split(':')
      runscriptsList = glob.glob("run/*.run")

      if (( 'exp' in l) or ('all' in l)) and not runscriptsList == "" :
         # get the list of runscripts; these are all the run/*.run files
         self.logfiles = {"STATUS": "LOOP_STATUS_EXP_FILE"}
         for runscript in runscriptsList:
            expname = get_EXPNAME(runscript)
            self.logfiles[expname] = 'run/LOG.' + runscript + '.o'
         call = 'scripts/buildbot_scripts/bb_run'
         self.setCommand(call)

      else:
         self.logfiles = {}
         self.setCommand('echo Running of bb_run exp is switched off')

      ShellCommand.start(self)

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

class ICON_Make(ShellCommand):

   from buildbot_builders import buildbot_experiments_list

   name="make"
   usePTY=True
   description="build"
   builder_list_name =""
   #global builder_list_name

   def start(self):
      # check if experiment names are given explicitly in buildbot
      exp_str = self.getProperty("exp")
      if ( exp_str != 'all' ):
        # if so, create a temporary list "buildbot_explist.tmp" with these experiments
        builder_list_name = "buildbot_explist.tmp"
        myList = buildbot_experiments_list(builder_list_name)
        expList = exp_str.split(':')
        myList.add_experimentsByNameToAllBuilders(expList, "")
        myList.write()
      else:
        # set the list name from the properties
        builder_list_name = self.getProperty("list")

      # delete runscripts if exist ? 
      myList = buildbot_experiments_list(builder_list_name)
      builderName = self.getProperty("buildername")
      builder_flags = myList.get_builder_flags(builderName)

      if self.getProperty("make") == "yes" and not "Inactive" in builder_flags:
         self.setCommand("scripts/buildbot_scripts/build "+builderName+" --list "+builder_list_name)
      else:
         self.setCommand('echo Compiling is switched off')

      ShellCommand.start(self)

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

class ICON_Del(ShellCommand):

   name="del"
   description="del"

   def start(self):
      if self.getProperty("make") == "yes":
         self.setCommand('rm -rf * .svn')
      else:
         self.setCommand('echo No deleting is done')

      ShellCommand.start(self)

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

class Build_Property_List(ShellCommand):
# This class is used 

   name="Info"
   description="Info"

   def start(self):
      now = datetime.datetime.now()
      DATE  = str(now.year) + '-' + str(now.month).zfill(2) + '-' + str(now.day).zfill(2)
      mTime  = str(now.hour) + ':' + str(now.minute).zfill(2) + ':' + str(now.second).zfill(2)

      BASE_DIR="/srv/buildbot/icon/upload/" + DATE + '/buildbot/'
      

      filename  = BASE_DIR
      filename += self.getProperty("got_revision") + '/'
      filename += self.getProperty("buildername") + '/'
      filename += str(self.getProperty("buildnumber")) + '/'

      if self.getProperty("branch") == None:
        b = str(default_Branch)
      else:
        b = str(self.getProperty("branch")) 

      dirname  = BASE_DIR
      dirname += self.getProperty("got_revision") + '/'
      dirname += b.replace('/','+') + '/'
      dirname += self.getProperty("buildername") + '/'
      dirname += str(self.getProperty("buildnumber")) 
      print "dirname " + dirname
      if os.path.isdir(dirname):
        filename = dirname + '/run_info.txt'
      else:
        filename += 'run_info.txt'

      file = open(filename, 'w')

      file.write("Name,	\tValue\n")
      if self.getProperty("branch") == None:
        file.write('branch:\t\t' + str(default_Branch) + '\n')
      else:
        file.write('branch:\t\t' + str(self.getProperty("branch")) + '\n')

      file.write("Timestamp:\t"  + DATE + ' ' + mTime + '\n')

      file.write("revision:\t" + self.getProperty("got_revision") + '\n\n')

      file.write("buildername:\t" + self.getProperty("buildername") + '\n')
      file.write("buildnumber:\t" + str(self.getProperty("buildnumber")) + '\n')
      file.write("slavename:\t" + self.getProperty("slavename") + '\n\n')

      file.write("subdir:\t" + self.getProperty("subdir") + '\n')
      file.write("exp:\t\t" + self.getProperty("exp") + '\n')
      file.write("make:\t" + self.getProperty("make") + '\n')
      file.write("section:\t" + self.getProperty("section") + '\n')
      file.write("list:\t" + self.getProperty("list") + '\n')
      com='echo write property info to '+ str(filename) + ' at ' + str(now)
      self.setCommand(com)
      file.close()

      ShellCommand.start(self)

#========================================================
# Available job steps

clean_workdir = ICON_Del(
    haltOnFailure=True, 
    workdir=work_dir
)

#--------------------------------------------------------

svn_update = source.SVN(
    mode='update',
    baseURL='https://svn.zmaw.de/svn/icon/',
#     description="svn",
    workdir=work_dir,
    defaultBranch=default_Branch,
    haltOnFailure=True
)

#--------------------------------------------------------

make = ICON_Make(
    haltOnFailure=True, 
    timeout=43200, 
    workdir=work_dir
)

#--------------------------------------------------------


#--------------------------------------------------------
# Creates the actual experiment list.


run_exp = ICON_RunExp(
    flunkOnFailure=True, 
    timeout=82800, 
    workdir=work_dir
)



#--------------------------------------------------------
# Upload plots to server for web-plots

#archive_dir = "upload"
#slave_dir = shell.WithProperties("/tmp/BuildBot/%s/archive", "buildername")

#upload_plots = DirectoryUpload(
    #slavesrc=slave_dir,
    #masterdest=archive_dir
#)

#--------------------------------------------------------

property_list = Build_Property_List(
    workdir=work_dir
)

#--------------------------------------------------------

make_doc = ShellCommand(
    command='scripts/buildbot_scripts/bb_make_doc', 
    haltOnFailure=True, 
    name="make doc",
    timeout=4800, 
    workdir=work_dir,
    usePTY=True,
    description="make doc"
)

#========================================================
# Build definitions

#--------------------------------------------------------
# Standard build process

run_full = factory.BuildFactory()

run_full.addStep(clean_workdir)
run_full.addStep(svn_update)
run_full.addStep(make)
run_full.addStep(run_exp)

#--------------------------------------------------------
# Build documentation only

m2 = factory.BuildFactory()

m2.addStep(clean_workdir)
m2.addStep(svn_update)
m2.addStep(make_doc)

#--------------------------------------------------------
# Build only: defined externally, so that it can be switched on-off without restarting buildbot

#build_only = factory.BuildFactory()

#build_only.addStep(clean_workdir)
#build_only.addStep(svn_update)
#build_only.addStep(make)


#========================================================
# Build definitions

c['builders'] = [
    {'name':'THUNDER_doc',
        'slavename':'thunder', 'builddir':'thunder_doc', 'factory':m2,
        'env':{'BB_SYSTEM':'thunder', 'BB_SLAVE':'doc'}},

    {'name':'THUNDER_gcc',
        'slavename':'thunder', 'builddir':'thunder_gcc', 'factory':run_full,
        'env':{'BB_SYSTEM':'thunder' , 'BB_SLAVE':'gcc'}},
    {'name':'THUNDER_intel_hybrid',
        'slavename':'thunder', 'builddir':'thunder_intel_hybrid', 'factory':run_full,
        'env':{'BB_SYSTEM':'thunder' , 'BB_SLAVE':'intel_hybrid'}},
    {'name':'THUNDER_nag',
        'slavename':'thunder', 'builddir':'thunder_nag', 'factory':run_full,
        'env':{'BB_SYSTEM':'thunder' , 'BB_SLAVE':'nag'}},

    {'name':'DAINT_CPU_cce',
        'slavename':'daint_cpu', 'builddir':'daint_cpu_cce', 'factory':run_full,
        'env':{'BB_SYSTEM':'daint_cpu', 'BB_SLAVE':'cce'}},

    {'name':'MISTRAL_intel_hybrid',
        'slavename':'mistral', 'builddir':'mistral_intel_hybrid', 'factory':run_full,
        'env':{'BB_SYSTEM':'mistral' , 'BB_SLAVE':'intel_hybrid'}},
    {'name':'MISTRAL_intel',
        'slavename':'mistral', 'builddir':'mistral_intel', 'factory':run_full,
        'env':{'BB_SYSTEM':'mistral' , 'BB_SLAVE':'intel'}},
    {'name':'MISTRAL_intel_openmp',
        'slavename':'mistral', 'builddir':'mistral_intel_openmp', 'factory':run_full,
        'env':{'BB_SYSTEM':'mistral' , 'BB_SLAVE':'intel_openmp'}},
    {'name':'MISTRAL_gcc',
        'slavename':'mistral', 'builddir':'mistral_gcc', 'factory':run_full,
        'env':{'BB_SYSTEM':'mistral' , 'BB_SLAVE':'gcc'}},
    {'name':'MISTRAL_nag',
        'slavename':'mistral', 'builddir':'mistral_nag', 'factory':run_full,
        'env':{'BB_SYSTEM':'mistral' , 'BB_SLAVE':'nag'}},
    {'name':'MISTRAL_nag_mtime',
        'slavename':'mistral', 'builddir':'mistral_nag_mtime',
        'factory':run_full,
        'env':{'BB_SYSTEM':'mistral' , 'BB_SLAVE':'nag_mtime'}},
    {'name':'MISTRAL_nag_serial',
        'slavename':'mistral', 'builddir':'mistral_nag_serial',
        'factory':run_full,
        'env':{'BB_SYSTEM':'mistral' , 'BB_SLAVE':'nag_serial'}},
    {'name':'MISTRAL_ocean',
        'slavename':'mistral', 'builddir':'mistral_ocean', 'factory':run_full,
        'env':{'BB_SYSTEM':'mistral' , 'BB_SLAVE':'ocean'}}
]

####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

# HTML
# ====

from buildbot.status import html
from buildbot.status.web.authz import Authz
import MainPage
import exp_plot
import reference_page

def is_admin(user):
    admins_file = open('buildbot_admins.txt')
    admins = filter(
                 lambda x: not x.startswith('#') and x,
                 map(
                     lambda x: x.strip(),
                     admins_file.readlines()
                 )
             )
    admins_file.close()
    return user in admins

authorizations = Authz(
    useHttpHeader = True,
    forceBuild = True,
    forceAllBuilds = True,
    pingBuilder = True,
    gracefulShutdown = is_admin,
    pauseSlave = is_admin,
    stopBuild = True,
    stopAllBuilds = True,
    cancelPendingBuild = True,
    cancelAllPendingBuilds = True,
    stopChange = True,
    cleanShutdown = is_admin,
    showUsersPage = is_admin,
)

WEB = html.WebStatus(
    http_port = "tcp:8011:interface=127.0.0.1",
    ### allowForce = True,
    authz = authorizations
)
WEB.putChild('home', MainPage.HomePage())
WEB.putChild('reference', reference_page.MainPage())
WEB.putChild('plot', exp_plot.EXP_plot())

c['status'].append(WEB)


# MAIL
# ====
from buildbot.status import mail

# Any failures
# ------------

c['status'].append(mail.MailNotifier(fromaddr="help-buildbot@zmaw.de",
                                     mode='failing',
                                     subject='[BUILDBOT ICON] %(builder)s BUILD FAILED',
                                     relayhost="smtp.zmaw.de",
                                     sendToInterestedUsers=False))

# c['status'].append(words.IRC(host="irc.example.com", nick="bb",
#                              channels=["#example"]))
#

from buildbot.status import client
c['status'].append(
    client.PBListener(port = 9998)
)




####### DEBUGGING OPTIONS

# if you set 'debugPassword', then you can connect to the buildmaster with
# the diagnostic tool in contrib/debugclient.py . From this tool, you can
# manually force builds and inject changes, which may be useful for testing
# your buildmaster without actually committing changes to your repository (or
# before you have a functioning 'sources' set up). The debug tool uses the
# same port number as the slaves do: 'slavePortnum'.

c['debugPassword'] = "debugpassword"

# if you set 'manhole', you can ssh into the buildmaster and get an
# interactive python shell, which may be useful for debugging buildbot
# internals. It is probably only useful for buildbot developers. You can also
# use an authorized_keys file, or plain telnet.
#from buildbot import manhole
#c['manhole'] = manhole.PasswordManhole("tcp:9999:interface=127.0.0.1",
#                                       "admin", "password")


####### PROJECT IDENTITY

# the 'projectName' string will be used to describe the project that this
# buildbot is working on. For example, it is used as the title of the
# waterfall HTML page. The 'projectURL' string will be used to provide a link
# from buildbot HTML pages to your project's home page.

c['projectName'] = "ICON"
c['projectURL']  = "https://code.zmaw.de/projects/icon"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.Waterfall page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.

c['buildbotURL'] = "http://buildbot.zmaw.de/icon/"

# vim:ft=python
