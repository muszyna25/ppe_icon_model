require 'rake/clean'
require 'logger'
# BASIC FOMATING SETUP {{{ ====================================================
LINEWIDTH = 80
# }}}
# TEST COLLECTION {{{ =========================================================
@testSuites = {
  :oceanAccumulation      => %w[exp.ocean_accumulation_hourly exp.ocean_accumulation_daily],
  :oceanPtestShort        => %w[exp.ocean_ptest_analytic_noforcing],
  :oceanPtestLong         => %w[exp.ocean_ptest_omip_160km_1year],
  :oceanPtest             => %w[oceanPtestShort oceanPtestLong], 
  :oceanTechnical         => %w[exp.oce_test_parallel],
  :oceanSurface           => %w[exp.oce_omip_testSurface],
  :oceanNpromaCheck       => ['exp.oce_omip_testSurface',],
  :oceanBasicConservation => %w[exp.oce_test_numeric exp.oce_tracer_bubble exp.oce_omip_testSurface],
  :oceanLong              => %w[exp.oce_omipR2B04L40 exp.oce_SmallBoxACC_0080km_cell],
  :oceanDev               => %w[oceanTechnical oceanBasicConservation],
  :oceanStable            => %w[oceanLong],
  :iconDev                => %w[exp.atm_icoles_nested exp.atm_amip_test],
}

# collect ALL test automatically from checksuites
@testCases = {}
{
  :ocean          => {:subDirPattern => 'ocean_internal/**/*'},
  :coupled        => {:subDirPattern => 'coupled/*'},
  :iconStableMpim => {:subDirPattern => 'icon-stable.mpim/**/*'},
  :iconDev        => {:subDirPattern => 'icon-dev/check.atm*'},
}.each {|component,componentExperiments|
  @testCases[component] = {}
  Dir.glob("./checksuite.#{componentExperiments[:subDirPattern]}").sort.each {|item| 
    filename = File.basename(item)
    if not File.directory?(item) and (['exp','post','check'].include?(filename.split('.').first)) then
      @testCases[component][filename] = item
      CLEAN.include(filename)
    end
  }
}

# collect ALL TESTS
#   available top level tests
@allTests = Dir.glob("{post,exp}*").delete_if {|f| File.extname(f) == '.run' or File.symlink?(f) }
#   templates from ckecksuites
@testCases.each_value {|v| @allTests << v.keys}
@allTests.flatten!

CLEAN.include('*.run')
# }}}
# RUNSCTIP GENERATION {{{ =====================================================
# define symlink rule for checksuite items
@testCases.each {|component, componentsTests|
  componentsTests.each {|template,source|
    file template => source do 
      FileUtils.ln_s(source, template, :force => true, :verbose => true)
    end
  }
}
# define rule for create .run files
@allTests.each {|template|
  runScriptName = "#{template}.run"
  file runScriptName => template do
    # get the technial setup from the command line or the test setup
    #   internal setup first
    setup = {}
    #   from the command line may overwrite internal default
    %w[with_mpi with_openmp cpu_time mpi_procs_pernode nproma openmp_threads omp_stacksize resources memory_model memory node_usage no_of_nodes queue out_script in_script job_name in_folder out_folder].each {|environmentKey| 
      setup[environmentKey] = ENV[environmentKey] if ENV.has_key?(environmentKey)
    }

    sh "cd ..; ./config/make_target_runscript in_script=#{template} #{setup.sort.map {|item| item.join('=')}.join(' ')}"
    # nproma=123 with_mpi=true mpi_procs_pernode=2
  end
}
# }}}
# LIST TESTS {{{ ==============================================================
desc "Show all known ocean tests"
task :showOcean do
  puts "ALL TESTSUITS ".ljust(LINEWIDTH,'=')
  @testSuites.each {|name,experimentList|
    if /^ocean/.match(name.to_s) then
      puts name.to_s
      experimentList.each {|experiment| puts "\t"+experiment }
    end
  }
  puts "ALL OCEAN TESTS".ljust(LINEWIDTH,'=')
  @testCases[:ocean].each {|k,v|
    puts [k.ljust(50,' '),v].join(':')
  }
  puts '='*LINEWIDTH
end

desc "Show all available tests cases"
task :showTests do
  puts "ALL TESTS".ljust(LINEWIDTH,'=')
  @allTests.each {|k,v|
    puts [k.ljust(50,' '),v].join(':')
  }
  puts '='*LINEWIDTH
end
desc "Show all available test suites"
task :showSuites do
  puts "ALL SUITES".ljust(LINEWIDTH,'=')
  @testSuites.each {|name,experimentList|
    puts name.to_s
    experimentList.each {|experiment| puts "\t"+experiment }
  }
  puts '='*LINEWIDTH
end
# }}}
# HELPER METHODS {{{ ==========================================================
def dbg(item)
  if ENV.has_key?('DEBUG')
    require 'pp'
    pp item
  end
end
def getExperimentsFromTestSuite(suite)
  dbg(suite)
  items = @testSuites[suite]
  experimentList = []
  items.each {|item|
    if @testSuites.keys.include?(item.to_sym) then
      experimentList << getExperimentsFromTestSuite(item.to_sym)
    else
      experimentList << item
    end
  }
  experimentList
end
# }}}
# HOST CONFIG: start, stop, check jobs {{{ ====================================
# may require local port forwarding 
RemoteQStat = {
  :blizzard => {host: 'passat.dkrz.de', user: 'm300064',             command: '/usr/bin/llq'},
  :thunder  => {host: 'localhost',      user: 'm300064',port: 50022, command: '/usr/bin/squeue'},
  :wizard   => {host: 'wizard.dkrz.de', user: 'm300064',             command: '/usr/bin/squeue'},
}
STATE_COLUMNS_WIDTH = 12
NAME_COLUMN_WIDTH   = 65
DATE_COLUMN_WIDTH   = 20
#@log                = Logger.new("#{ENV['HOME']}/rllq.log")
#==============================================================================
def getAdditionalInfo(ssh,logfile,tag)# {{{
  info =[]
# info_  = ssh.exec!("head -n 5000 #{logfile}  | grep #{tag} | tail -n 1").split(' ')[-4,-1]
  info_  = ssh.exec!("head -n 5000 #{logfile}  | grep #{tag} | tail -n 1")

  if info.nil? then
    return ''
  end

  info_  = info_.split(' ') unless info_.nil?
  info_  = info_.values_at(-3,-2,-1).map(&:to_f).map {|v| "%E"%v}.join(' ') unless info_.nil?
  
  info << "#{tag}: #{info_}"
  info.join(' - ')
end
def checkAll
  RemoteQStat.each {|hpc,setup|
      host, user, command, port = setup[:host], setup[:user], setup[:command], setup[:port]

      log = ''
      log << "# #{hpc} ".ljust(80,'=') << "\n"

      Net::SSH.start(host,user,port: port) do |ssh|
        case hpc.to_s
        when /thunder|wizard/ then
          ssh.exec!('source /etc/profile; source /client/etc/profile.zmaw')
          columns = [:state,:name,:id,:nodes,:time]
          results = {}
          status = ssh.exec!(command + ' -u $USER -o "%T %j %i %D %M"')
          next if status.nil?
          status.chomp.split("\n").each_with_index {|line,lineIndex|
            next if 0 == lineIndex
            state,name,id,nodes,time = line.split
            if 'RUNNING' == state then
              scontrol = ssh.exec!("/usr/bin/scontrol show job #{id}").split("\n")
              workdir = scontrol.grep(/WorkDir/).first.split('=').last.chomp
              script  = scontrol.grep(/Command/).first.split('=').last.chomp
              logfile = workdir + '/' + ssh.exec!("grep 'error=' #{script}").chomp.split('=').last.sub(/%j/,id)
              lastDate = ssh.exec!("tail -n 3000 #{logfile} | grep datetime | tail -n 1").to_s.split(' ').last
              info = @options.has_key?("tag") ? getAdditionalInfo(ssh,logfile,@options["tag"]) : ''
              if 'default' == @info then
                myLog = [
                  state.ljust(STATE_COLUMNS_WIDTH,' '),
                  name.ljust(NAME_COLUMN_WIDTH,' '),
                  id,
                  nodes,
                  lastDate.nil? ? '' : lastDate.rjust(DATE_COLUMN_WIDTH,' '),
                  info,
                ].join(' | ') << "\n"
              else
                myLog = [
                  state.ljust(STATE_COLUMNS_WIDTH,' '),
                  name.ljust(NAME_COLUMN_WIDTH,' '),
                  id,
                  nodes,
                  lastDate.rjust(DATE_COLUMN_WIDTH,' '),
                  info,script,logfile,
                ].join(' | ') << "\n"
              end
              log << myLog 
              # [
              #   state.ljust(STATE_COLUMNS_WIDTH,' '),
              #   name.ljust(NAME_COLUMN_WIDTH,' '),
              #   id,
              #   nodes,
              #   lastDate.rjust(DATE_COLUMN_WIDTH,' '),
              #   info,
              # ].join(' | ') << "\n"
            else
              log << [state.ljust(STATE_COLUMNS_WIDTH,' '),name.ljust(NAME_COLUMN_WIDTH,' '),id,nodes].join(' | ') << "\n"
            end
          }
        when /blizzard/ then
          ssh.exec!('source ~/.profile;')
          myJobs = ssh.exec!("#{command} -u $USER | grep $USER")
          next if myJobs.nil?
          myJobs =  myJobs.split("\n").map {|l| l.split(' ').first }
          myJobs.each {|job|
            jobList = ssh.exec!("#{command} #{job} -l").chomp.split("\n")
            name    = jobList.grep(/Job Name/).first.split(':').last.strip
            status  = jobList.grep(/Status/).first.split(':').last.strip.upcase
            script  = (not jobList.grep(/Executable/).empty?) ? jobList.grep(/Executable/).first.split(':').last : jobList.grep(/Cmd/).first.split(':').last
            id      = jobList.grep(/Job Step Id/).first.split(':').last.strip

            logfile     = [
              jobList.grep(/Initial Working Dir:/).first.split(':').last,
              jobList.grep(/Err:/).first.split(':').last.strip.chomp
            ].join('/')
            if 'RUNNING' == status then
              lastDate = ssh.exec!("tail -n 3000 #{logfile} | grep datetime | tail -n 1").to_s.split(' ').last.to_s
              #puts name
              #pp ssh.exec!("tail -n 3000 #{logfile} | grep datetime | tail -n 1").to_s.split(' ').last
              info = @options.has_key?("tag") ? getAdditionalInfo(ssh,logfile,@options["tag"]) : ''
            else
              lastDate = ''
            end
            if 'default' == @info then
              log << [
                status.ljust(STATE_COLUMNS_WIDTH,' '),
                name.ljust(NAME_COLUMN_WIDTH,' '),
                lastDate.rjust(DATE_COLUMN_WIDTH,' '),
                info,
              ].join(' | ') << "\n"
            else
              log << [
                status.ljust(STATE_COLUMNS_WIDTH,' '),
                name.ljust(NAME_COLUMN_WIDTH,' '),
                lastDate.rjust(DATE_COLUMN_WIDTH,' '),
                id,info,script,logfile,
              ].join(' | ') << "\n"
            end
          }
        end
      end
      puts log
      #lock.synchronize {
      #  File.open(@logfile,"a") {|logfile| logfile << log }
      #}
      #@log.info(log)
    }
end# }}}
# }}}
# RUNNING|CHECKING TESTS {{{ ===========================================================
# config first
@jobHost   = /[[:alpha:]]+/.match(`hostname`.chomp)[0] ; dbg(@jobHost)
@jobSubmit = {thunder: 'sbatch' , blizzard: 'llsubmit', passat: 'llsubmit'}#[@jobHost.to_sym]
@jobCancel = {thunder: 'scancel', blizzard: 'llcancel', passat: 'llcancel'}#[#@jobHost.to_sym]
@jobStatus = {thunder: 'squeue' , blizzard: 'llq'     , passat: 'llq'     }#[@jobHost.to_sym]
# default is direct execution
@jobSubmit.default = ''

def mySh(args)
  if ENV.has_key?('DRYRUN') then
    puts args
  else
    sh args
  end
end
desc "Run named test or testsuite or TESTS='a,b,..'"
task :run, :name do |t,args|
  testsGiven = args.name.nil? ? (ENV.has_key?('TESTS') ? ENV['TESTS'].split(',') : nil ) : [args.name]
  
  if testsGiven.nil? then
    warn "Nothing to test!"
    exit 0
  end
  puts "try to run #{testsGiven.join(' ')} ..."

  # determine the submission command
  submitCommand = ENV.has_key?('SUBMIT') ? ENV['SUBMIT'] : @jobSubmit[@jobHost.to_sym]
  dbg("Submission Command is: '#{submitCommand}'")

  # if testsuites are given, transform them into lists of experiments
  experimentList =[]
  testsGiven.each {|test| 
    if @testSuites.keys.include?(test.to_sym) then
      experimentList << getExperimentsFromTestSuite(test.to_sym)
    else
      experimentList << test if @allTests.include?(test)
    end
  }
  experimentList.flatten!; dbg(experimentList)

  if experimentList.empty? then
    warn "Could not find any experiments to test!"
    exit 1
  end

  experimentList.each {|experiment|
    Rake::Task[experiment.to_sym].invoke
    Rake::Task["#{experiment}.run".to_sym].invoke
    sh "#{submitCommand} ./#{experiment}.run"
  }
end
desc "Run all tests for agiven component: ocean coupled"
task :runAllOf,:component do 
end
desc "Check all your running jobs"
task :check do
  checkAll
end
# }}}
# HELP {{{ ====================================================================
desc "Show detailed help"
task :help do
  puts "F1!"
  sh "rake -T"
end
desc "Run almost all targets"
task :selfCheck do
  dbg(Rake::Task.tasks)
  Rake::Task.tasks.each {|t| 
    puts t.name
    t.invoke unless %w[check clean clobber].include?(t.name)
  }
end
task :showSubmit do
  require 'pp'

  puts 'HOST is:'
  pp @jobHost
  puts 'SUBMITs is: '
  pp @jobSubmit
  pp @jobSubmit[@jobHost.to_sym]
end
# }}}
# vim:fdm=marker
