# BASIC FOMATING SETUP {{{ ====================================================
LINEWIDTH = 80
# }}}
# OCEAN TEST COLLECTION {{{ ===================================================
@testSuites = {
  :oceanTechnical         => %w[exp.oce_test_parallel],
  :oceanSurface           => %w[exp.oce_omip_testSurface],
  :oceanBasicConservation => %w[exp.oce_test_numeric exp.oce_tracer_bubble exp.oce_omip_testSurface],
  :oceanLong              => %w[exp.omipR2B05L40 exp.oce_SmallBoxACC_0080km_cell],
  :oceanDev               => %w[oceanTechnical oceanBasicConservation],
  :oceanStable            => %w[oceanLong],
}

# collect ALL test automatically from its checksuite
@testCases = {}
{
  :ocean          => {:subDirPattern => 'ocean_internal/**/*'},
  :coupled        => {:subDirPattern => 'coupled/*'},
  :iconStableMpim => {:subDirPattern => 'icon-stable.mpim/**/*'},
  :iconDev        => {:subDirPattern => 'icon-dev/check.atm*'},
}.each {|component,componentExperiments|
  @testCases[component] = {}
  Dir.glob("./checksuite.#{componentExperiments[:subDirPattern]}").sort.each {|item| 
    filename = File.basename(item)
    if not File.directory?(item) and ('exp.' == filename[0,4] or 'check.' == filename[0,6]) then
      @testCases[component][filename] = item
    end
  }
}

# collect ALL TOPLEVEL TESTS
@allTests = Dir.glob("{post,exp}*").delete_if {|f| File.extname(f) == '.run'}
@testCases.each_value {|v| @allTests << v.keys}
@allTests.flatten.sort!
# }}}
# RUNSCTIP GENERATION {{{ =====================================================
# define symlink rule
@testCases.each {|component, componentsTests|
  componentsTests.each {|template,source|
    file template => source do 
      FileUtils.ln_s(source, template, :force => true, :verbose => true)
    end
  }
}
# define rule for create .run files from existing template (exp/post)
@allTests.each {|template|
  runScriptName = "#{template}.run"
  file runScriptName => template do
    sh "cd ..; ./make_runscripts #{template.sub(/^exp./,'')}"
  end
}
# }}}
# LIST TESTS {{{ ==============================================================
desc "Show all known ocean tests"
task :showOcean do
  puts "ALL TESTSUITS ".ljust(LINEWIDTH,'=')
  @testSuites.each {|name,experimentList|
    if /^ocean/.match(name.to_s) then
      puts name.to_s
      experimentList.each {|experiment| puts "\t"+experiment }
    end
  }
  puts "ALL OCEAN TESTS".ljust(LINEWIDTH,'=')
  @oceanTests.each {|k,v|
    puts [k.ljust(50,' '),v].join(':')
  }
  puts '='*LINEWIDTH
end

desc "Show all available tests cases"
task :showTests do
  puts "ALL TESTS".ljust(LINEWIDTH,'=')
  @allTests.each {|k,v|
    puts [k.ljust(50,' '),v].join(':')
  }
  puts '='*LINEWIDTH
end
desc "Show all available test suites"
task :showSuites do
  puts "ALL SUITES".ljust(LINEWIDTH,'=')
  @testSuites.each {|name,experimentList|
    puts name.to_s
    experimentList.each {|experiment| puts "\t"+experiment }
  }
  puts '='*LINEWIDTH
end
# }}}
def dbg(item)
  if ENV.has_key?('DEBUG')
    require 'pp'
    pp item
  end
end
def getExperimentsFromTestSuite(suite)
  dbg(suite)
  items = @testSuites[suite]
  experimentList = []
  items.each {|item|
    if @testSuites.keys.include?(item.to_sym) then
      experimentList << getExperimentsFromTestSuite(item.to_sym)
    else
      experimentList << item
    end
  }
  experimentList
end
desc "Run named test or testsuite or TESTS='a,b,..'"
task :run, :name do |t,args|
  testsGiven = args.name.nil? ? (ENV.has_key?('TESTS') ? ENV['TESTS'].split(',') : nil ) : [args.name]
  
  puts "try to run #{testsGiven.join(' ')} ..."

  # if testsuites are given, transform them into lists of experiments
  experimentList =[]
  testsGiven.each {|test| 
    if @testSuites.keys.include?(test.to_sym) then
      experimentList << getExperimentsFromTestSuite(test.to_sym)
    else
      experimentList << test
    end
  }
  experimentList.flatten!; dbg(experimentList)

  experimentList.each {|experiment|
    sh "echo start #{experiment}"
  }
end
# HELP {{{ ====================================================================
desc "Show detailed help"
task :help do
  puts "F1!"
  sh "rake -T"
end
# }}}
# vim:fdm=marker
