#-----------------------------------------------------------------------------

nested_grids=$(ls ../grids/iconR2B05_DOM02.nc)
if [[ "x$nested_grids" != "x../grids/iconR2B05_DOM02.nc" ]] ; then
  echo "Try to copy grids generated for a different compiler"
  firstfound=$(ls ../../../*/build/grids/iconR2B03_DOM00.nc|head -1)
  griddir=${firstfound%/*}
  if [[ -a ${griddir}/iconR2B03_DOM00.nc && -a ${griddir}/iconR2B04_DOM01.nc && -a ${griddir}/iconR2B05_DOM02.nc ]]; then
    echo "  Copy grids from ${griddir} and make test"
    cp -f $griddir/iconR2B0?_DOM0?.nc ../grids
  else
    echo "  No grids found --> exit test"
    check_error 0 "exp.nat_jww_nwp_mpiomp"
    exit 0
  fi
fi
#-----------------------------------------------------------------------------
#=============================================================================
#
# This section of the run script containes the specifications of the experiment.
# The specifications are passed by namelist to the program.
# For a complete list see Namelist_overview.pdf
#
# EXPNAME and NPROMA must be defined in as environment variables or must 
# they must be substituted with appropriate values.
#
# DWD, 2010-08-31
#
#-----------------------------------------------------------------------------
# Basic specifications of the simulation
# --------------------------------------
#
# This test must have available at least 3 MPI processes.
#
# If the model runs with mpi_procs=1, then this script exits without error:
if [[ ${mpi_procs} = 1 ]]; then
  echo "This test must not be started if mpi_procs=1 --> exit test without error"
  check_error 0 "exp.nat_jww_nwp_mpiomp"
  exit 0
fi
# If running in parallel, mpi_procs must be bigger than 2:
if [[ ${mpi_procs} = 2 ]]; then
  echo "This test needs at least 3 MPI processes --> increase mpi_procs from 2 to 3"
  mpi_procs=3
  START=${START%2}3
fi
#
# These values need to be stored in variables, which are needed to 
# construct filenames  or directories:
# 
R=2               # nroot
B=4               # number of bisections applied for the global grid
# Variables needed when runnig the model with grid refinement (IREF must be .TRUE.)
IREF=.true.
NDOM=2
LPATCH0=.true.    # must be set to .TRUE. if the reduced grid is used for radiation
#
N=40              # nlev = number of full levels
OPT="spr0.90"     # grid optimization
#
IEQ=3             # equation system
#                     1=hydrost. atm. T
#                     1=hydrost. atm. theta dp
#                     3=non-hydrost. atm., 
#                     0=shallow water model
#                    -1=hydrost. ocean
#
#
DTIME=120         # time step in seconds
NSTEPS=50         # number of time steps to run
DT_DATA=`expr ${DTIME} \* ${NSTEPS}`   # data output at the end of the integration
#
#-----------------------------------------------------------------------------
#
# ICON namelist parameters
# ------------------------
# For a complete list see Namelist_overview and Namelist_overview.pdf
#
cat > NAMELIST_${EXPNAME} << EOF
!
&parallel_ctl
 p_test_run     = .true.
 l_test_openmp  = .true.
 l_log_checks   = .true.  
/
&nh_testcase_ctl
 nh_test_name   = 'jabw_m'     ! test case identifier
 rh_at_1000hpa  = 0.99
 qv_max         = 35.e-3
/
&io_ctl
 out_expname    = '${EXPNAME}' ! file name base
 dt_data        = ${DT_DATA}   ! [s] output interval
 dt_diag        = ${DT_DATA}
/
&grid_ctl
 nroot          = ${R}         ! root division of icosahedron edges
 start_lev      = ${B}         ! number of bisections applied for the base grid
 n_dom          = ${NDOM}
 lfeedback      = .true.,
 lpatch0        = ${LPATCH0}
 lredgrid_phys  = .true.,.true.
/
&run_ctl
 nproma         = ${NPROMA}    ! array blocking length
 nlev           = ${N}         ! number of full levels of vertical grid
 nsteps         = ${NSTEPS}    ! 50 ! 1200 ! 7200 !
 dtime          = ${DTIME}     ! timestep in seconds
 iequations     = ${IEQ}       ! equation system
 i_cell_type    = 3            ! triangular cells
 ldynamics      = .TRUE.       ! dynamics
 ltransport     = .TRUE.
 ntracer        = 5            ! default: 0
 iforcing       = 3            ! diabatic forcing
 ltestcase      = .TRUE.       ! run testcase
 itopo          = 0
 lcorio         = .TRUE.
 msg_level      = 12           ! detailed report during integration
 ltimer         = .false.
 ldump_states   = .false.
 lrestore_states= .false. 
/
&nwp_phy_ctl
inwp_gscp       = 1
inwp_convection = 1
inwp_radiation  = 1
inwp_cldcover   = 3
inwp_turb       = 2
/
&radiation_nml
 irad_o3 = 6
/
&nonhydrostatic_ctl
 iadv_rhotheta  = 2
 ivctype        = 2            ! sleve vertical coordinate
 exner_expol    = 0.60
 vwind_offctr   = 0.12
 damp_height    = 23000.
 rayleigh_coeff = 0.05
 iadv_rcf       = 4
 l_open_ubc     = .false.
 l_nest_rcf     = .true.
/
&sleve_ctl
 min_lay_thckn  = 50.
 top_height     = 32500.
 decay_scale_1  = 4000.
 decay_scale_2  = 2500.
 decay_exp      = 1.2
 flat_height    = 16000.
/
&dynamics_ctl
 itime_scheme   = 5
 idiv_method    = 1
 divavg_cntrwgt = 0.50
/
&transport_ctl
  ctracer_list  = '12345'
/
&diffusion_ctl
 hdiff_order      = 5
 hdiff_efdt_ratio = 10.0
 hdiff_smag_fac   = 0.15
 lhdiff_vn        = .TRUE.
 lhdiff_temp      = .TRUE.
 hdiff_multfac    = 1.0
 hdiff_tv_ratio   = 1.0
/
&interpol_ctl
nudge_zone_width  = 4
/
&gridref_ctl
 grf_intmethod_ct = 2
 grf_tracfbk      = 2
 denom_diffu_v    = 150.
/
&regularization_ctl
/
&ocean_ctl
/
EOF
#
