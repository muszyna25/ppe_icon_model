#!/bin/ksh
#=============================================================================
#
# Leonidas Linardakis   MPI-M,   2009-12 
# Stephan Lorenz        MPI-M,   2010-07 
#
# This script creates the ICON grid for the ocean model. Moreover, the
# land-sea-mask used in the ocean model and, in the coupled case in the
# atmosphere as well, is created.
# The ocean grid is created with root division 2 and up to level 6
# using the respective optimization algorithms:
#
#=============================================================================
#
# This section of the run script containes the specifications of the ocean grid
#
# The ocean part in the ocean grid generator can be defined in three ways:
# A. Using a bathymetry file ([+set_sea_depth], [set_min_sea_depth]).
#    If set_sea_depth is given then an ocean with flat bed will be created.
# B. Using geometric conditions (no_of_conditions=1) +set_sea_depth
# C. No conditions: no_of_conditions=0, elevation_file='', +set_set_sea_depth (aqua planet)
# 
# There are two options regarding the cells contained in the ocean grid:
# only_get_sea_land_mask=.true.  The global grid will be written with the sea-land mask
#                                defined as above
# only_get_sea_land_mask=.false. Only the ocean part will be written, land part is not defined
# 
# The user can define if smoothing will be applied: No ocean triangle cell is allowed to be
#    neighbored by more than one land cell
# smooth_ocean_boundary=[.true.][.false.]  
# 
#-----------------------------------------------------------------------------
create_basin=".true."
create_aqua_planet=".true."
create_etopo40_planet=".true."
# plot_grid=".true."
#-----------------------------------------------------------------------------


#-----------------------------------------------------------------------------
# default optimization parameteres
set_optimization()
{
  dual_iterations=0       # prime/dual iterations

  use_barycenter_force='.false.'
  barycenter_force_coeff="1.0"

  use_isotropy_correction='.false.'
  isotropy_rotation_coeff="0.5"
  isotropy_stretch_coeff="0.1"

  use_edge_springs='.false.'
  use_adaptive_spring_length='.false.'
  use_local_reference_length='.false.'
  local_reference_length_coeff=1.0

  prime_ref_length_coeff=1.0
  prime_soft_spring_stiffness=1.0  # the stiffness of "large" prime springs
  prime_hard_spring_stiffness=1.0  # the stiffness of "small" prime springs

  use_centers_spring_correction='.false.'
  centers_springcorrection_coeff=0.25

  prime_use_spring_cellcenters='.false.'
  prime_centers_ref_length_coeff=1.0
  prime_centers_spring_stiffness=1.0  # the stiffness of vertex-cell center springs

  spring_friction=2.0
  spring_dt=1.6e-2
  use_adaptive_dt='.true.'
  max_dt_distance_ratio=5.0e-5

  prime_total_force_condition=0.025  # exit condition for total force
  prime_max_force_condition=0.01   # exit condition for max force
  max_min_condition=1.1            # exit condition for max/min edge
  centers_vertex_condition=1.005

  #-----------------------------------------------------------------------------
  dual_use_spring_cellcenters=".false."
  dual_ref_length_coeff=1.0
  dual_centers_ref_length_coeff=1.0
  dual_soft_spring_stiffness=1.0
  dual_hard_spring_stiffness=1.0
  dual_centers_spring_stiffness=1.0
  dual_total_force_condition=1.0
  dual_max_force_condition=1.0
  centers_local_condition=1.0

  use_isotropy_correction='.true.'
  isotropy_rotation_coeff=0.75
  isotropy_stretch_coeff=0.1
  use_edge_springs='.true.'
  use_adaptive_spring_length='.true.'
  prime_ref_length_coeff=1.0
  use_local_reference_length='.true.'
  local_reference_length_coeff=0.75
  prime_use_spring_cellcenters='.true.'
  prime_centers_ref_length_coeff=1.0
  prime_centers_spring_stiffness=1.0  # the stiffness of vertex-cell center springs
  
}
#-----------------------------------------------------------------------------

#-----------------------------------------------------------------------------
create_optimization_namelist()
{
# optimization namelist
parameterFile=$1
tmpFile=optimization_namelist.tmp
set_optimization
cat > $tmpFile << EOF
&grid_optimization
  use_optimization              = $use_optimization
  use_edge_springs              = $use_edge_springs
  use_adaptive_dt               = $use_adaptive_dt
  dual_use_spring_cellcenters   = $dual_use_spring_cellcenters
  prime_use_spring_cellcenters  = $prime_use_spring_cellcenters
  max_dt_distance_ratio         = $max_dt_distance_ratio
  prime_ref_length_coeff             = $prime_ref_length_coeff
  prime_centers_ref_length_coeff     = $prime_centers_ref_length_coeff
  dual_ref_length_coeff              = $dual_ref_length_coeff
  dual_centers_ref_length_coeff      = $dual_centers_ref_length_coeff
  prime_soft_spring_stiffness   = $prime_soft_spring_stiffness
  prime_hard_spring_stiffness   = $prime_hard_spring_stiffness   
  prime_centers_spring_stiffness= $prime_centers_spring_stiffness
  dual_soft_spring_stiffness    = $dual_soft_spring_stiffness    
  dual_hard_spring_stiffness    = $dual_hard_spring_stiffness    
  dual_centers_spring_stiffness = $dual_centers_spring_stiffness 
  use_centers_spring_correction = $use_centers_spring_correction
  centers_springcorrection_coeff= $centers_springcorrection_coeff
  spring_friction               = $spring_friction
  spring_dt                     = $spring_dt
  dual_iterations               = $dual_iterations
  p_total_force_condition       = $prime_total_force_condition
  d_total_force_condition       = $dual_total_force_condition
  p_max_force_condition         = $prime_max_force_condition
  d_max_force_condition         = $dual_max_force_condition
  max_min_condition             = $max_min_condition
  centers_vertex_condition      = $centers_local_condition
  use_adaptive_spring_length    = $use_adaptive_spring_length
  use_local_reference_length    = $use_local_reference_length
  local_reference_length_coeff  = $local_reference_length_coeff
  use_isotropy_correction       = $use_isotropy_correction
  isotropy_rotation_coeff       = $isotropy_rotation_coeff
  isotropy_stretch_coeff        = $isotropy_stretch_coeff
  use_barycenter_force          = $use_barycenter_force
  barycenter_force_coeff        = $barycenter_force_coeff
/
EOF
#-----------------------------------------------------------------------------
cat $tmpFile >> $parameterFile
rm $tmpFile
}


#-----------------------------------------------------------------------------
# function to create the input grids
create_input_grids()
{
  # define the levels to create
  input_grids_no_of_levels=$1
  input_grids_optimization_extension=$2
  #-----------------------------------------------------------------------------
  input_grids_parameterFile=create_icon_grid.namelist
  input_grids_commandFile=command.grid
  input_grids_command=create_icon_grid
  input_grids_run_commmand="$bindir/grid_command"
  #-----------------------------------------------------------------------------

cat > $input_grids_parameterFile << EOF
&icosahedron_grid
  no_of_levels = $input_grids_no_of_levels
  start_level =  0
  start_optimize= 1
  end_optimize  = $input_grids_no_of_levels
  refinement_method = 1
  output_file  = 'iconR2B'
  optimization_extension = '$input_grids_optimization_extension'
/
EOF

use_optimization='.true.'
create_optimization_namelist $input_grids_parameterFile
#-----------------------------------------------------------------------------
# run grid generator
echo $input_grids_command $input_grids_parameterFile > $input_grids_commandFile
${start} ${input_grids_run_commmand}
check_error $? "create input grids"

}

#-----------------------------------------------------------------------------
# function to create one ocean grid
create_ocean_grid()
{
  #-----------------------------------------------------------------------------
  # absolute paths of directories
  GRIDDIR=${basedir}/grids            # graphs, grids and patches
  TOPODIR=${basedir}/data/external     # external directory for topography file
  cd $GRIDDIR
  #-----------------------------------------------------------------------------

  #-----------------------------------------------------------------------------
  # refine ocean grid from REFINE_ITERATIONS level coarser than target level:
  #-----------------------------------------------------------------------------
  # construct input grid name
  if (( $REFINE_ITERATIONS > $B )) ; then
    echo "REFINE_ITERATIONS cannot be greater than required level."
    check_error 1 "REFINE_ITERATIONS cannot be greater than required level."
    exit 1
  fi    
  # typeset -Z2 Bm1 B it does not work on squall, needs further check
  ((Bm1=B-$REFINE_ITERATIONS))
  INPGRID_EXT="-grid_spr0.90"
  INPGRID=iconR${R}B0${Bm1}${INPGRID_EXT}.nc
  # if the INPGRID does not exits, create it
  if [[ ! -f $INPGRID ]] ; then
    create_input_grids ${Bm1} ${INPGRID_EXT}
  fi
    
  #-----------------------------------------------------------------------------
  command=create_ocean
  parameterFile=NAMELIST_OCEAN_GRID
  commandFile=command.grid
  run_commmand="$bindir/grid_command"
  #-----------------------------------------------------------------------------

  #-----------------------------------------------------------------------------
  # respective icon topography file interpolated from regular topography file $TOPFILE
  TOPICON=iconR${R}B${Bm1}-topo.nc
  # respective elevation file to read topography in icon grid for decision of sea-land-mask
  if [[ $TOPFILE = "" ]] ; then
    ELEVF=""
  else
    ELEVF="$GRIDDIR/$TOPICON"
  fi

  # interpolate regular topography into icon grid
  if [[ $TOPFILE != "" ]]; then
    if [[ ! -s  $GRIDDIR/$TOPICON ]]; then
      if [[ -s  $TOPODIR/$TOPFILE ]]; then
        echo " Now running:"
        echo " cdo remapcon,$GRIDDIR/$INPGRID $TOPODIR/$TOPFILE $GRIDDIR/$TOPICON"
        cdo remapcon,$GRIDDIR/$INPGRID $TOPODIR/$TOPFILE $GRIDDIR/$TOPICON
        check_error $? "cdo remapcon,$GRIDDIR/$INPGRID $TOPODIR/$TOPFILE $GRIDDIR/$TOPICON"
      else
        echo " no file  $TOPODIR/$TOPFILE available - exit script"
        check_error 1 "no file $TOPODIR/$TOPFILE available - exit script"
        exit 1
      fi
    fi
  fi

  #-----------------------------------------------------------------------------
  # namelist
cat > $parameterFile << EOF
&grid_geometry_conditions    
  no_of_conditions   = $no_of_conditions       ! 1: create ocean basin with patch_center and radius; 0: no conditions
  patch_shape        = $patch_shape            ! 1: rectangle; 2: circle_shape
  rectangle_xradious = $rectangle_xradious  ! half diameter of meridional extension in degrees
  rectangle_yradious = $rectangle_yradious  ! half diameter of zonal extension in degrees
  circle_radious     = $circle_radious
  patch_center_x     = $patch_center_x       ! longitude of center
  patch_center_y     = $patch_center_y       ! latitude  of center
/
&create_ocean_grid
  only_get_sea_land_mask    = $only_get_sea_land_mask
  smooth_ocean_boundary     = $smooth_ocean_boundary
  output_ocean_file         = '$GRIDDIR/$OCEGRID'
  output_atmo_file         = ''
  input_file                = '$GRIDDIR/$INPGRID'
  elevation_file            = '$ELEVF'             ! elevation file on icon grid
  elevation_field           = 'ROSE'               ! array name in output file
  min_sea_depth             = $MINDEPTH
  edge_elev_interp_method   = $INTMTH  
  set_sea_depth             = $SEADEPTH
  refine_iterations         = $REFINE_ITERATIONS
/
EOF

  #-----------------------------------------------------------------------------
  if [[ "x$optimize_ocean_grids" = "x.true." ]] ; then
    use_optimization='.true.'
  else
    use_optimization='.false.'    
  fi
  create_optimization_namelist $parameterFile
  #-----------------------------------------------------------------------------
  
  # create the ocean grid
  echo $command $parameterFile > $commandFile
  ${start} ${run_commmand}
  check_error $? "create $OCEGRID"
  #-----------------------------------------------------------------------------
  
  #-----------------------------------------------------------------------------
  # plot sea -land mask
  nclscript=../scripts/postprocessing/tools/plotIconSphereGrid.ncl
  if [[ "x$plot_grid" = "x.true." ]] ; then
    grid_name=\"$GRIDDIR/$OCEGRID\"
    echo ncl $nclscript \'grid=\"$GRIDDIR/$OCEGRID\"\'   \'var=\"edge_elevation\"\' > __tmp__
    echo ncl $nclscript \'grid=\"$GRIDDIR/$OCEGRID\"\'   \'var=\"edge_sea_land_mask\"\' > __tmp__
    chmod +x  __tmp__
    ./__tmp__
    rm __tmp__
  fi
  
}
#-----------------------------------------------------------------------------


#-----------------------------------------------------------------------------
# create oceans basin
if [[ x$create_basin = "x.true." ]] ; then
  # grid parameters
  R=2                   # nroot
  B=4                   # the final resolution of the grid
  REFINE_ITERATIONS=4   # iterations on the initial basin
  optimize_ocean_grids=".true."
  only_get_sea_land_mask=".true."
  smooth_ocean_boundary=".true."
  #bathymetry parameters
  MINDEPTH="-6.0"       # minimum bathymetry depth to consider grid point as sea [m] in elevation file
  SEADEPTH="-2800.0"    # set ocean bathymetry to constant (flat bottom)
  INTMTH=3              # edge elevation interpolation method: 1= linear, 2=min,  3=max
  # topography file
  TOPFILE=""            # no topography file used for the basin
  #conditions
  no_of_conditions=1
  patch_shape=2            # 1=orthogonal, 2= circle
  rectangle_xradious=0.0   # x radius for orthogonal
  rectangle_yradious=0.0   # y radius for orthogonal
  circle_radious=40.0      # radius of circle
  patch_center_x=0.0
  patch_center_y=0.0
 # patch_shape=1            # 1=orthogonal, 2= circle
 # rectangle_xradious=40.0  # x radius for orthogonal
 # rectangle_yradious=30.0  # y radius for orthogonal
 # circle_radious=0.0       # radius of circle
 # patch_center_x=0.0       
 # patch_center_y=30.0
  # output grid name
  OCEGRID=iconR${R}B0${B}-ocean_basin.nc
  ATMOGRID=iconR${R}B0${B}-atmo_basin.nc

  create_ocean_grid
fi


#-----------------------------------------------------------------------------
# create aqua planet
if [[ x$create_aqua_planet = "x.true." ]] ; then
  # grid parameters
  R=2                   # nroot
  B=4                   # number of bisections applied for the global grid
  REFINE_ITERATIONS=1
  optimize_ocean_grids=".true."
  only_get_sea_land_mask=".true."
  smooth_ocean_boundary=".false."
  #bathymetry parameters
  MINDEPTH="-6.0"       # minimum bathymetry depth to consider grid point as sea [m] in elevation file
  SEADEPTH="-2800.0"    # set ocean bathymetry to constant (flat bottom)
  INTMTH=3              # edge elevation interpolation method: 1= linear, 2=min,  3=max
  # topography file
  TOPFILE=""            # no topography file used for aqua planet
  #conditions
  no_of_conditions=0
  # output grid name
  OCEGRID=iconR${R}B0${B}-ocean_aqua_planet.nc
  ATMOGRID=iconR${R}B0${B}-atmo_aqua_planet.nc

  create_ocean_grid
fi

#-----------------------------------------------------------------------------
# create etopo40 planet
if [[ x$create_etopo40_planet = "x.true." ]] ; then
  # grid parameters
  R=2                   # nroot
  B=4                   # number of bisections applied for the global grid
  REFINE_ITERATIONS=1
  optimize_ocean_grids=".false."
  only_get_sea_land_mask=".true."
  smooth_ocean_boundary=".true."
  #bathymetry parameters
  MINDEPTH="-6.0"       # minimum bathymetry depth to consider grid point as sea [m] in elevation file
  INTMTH=3              # edge elevation interpolation method: 1= linear, 2=min,  3=max
  # topography file
  TOPFILE="etopo40.cdf" # topography file on regular grid to create land-sea-mask
  #conditions
  no_of_conditions=0
  # output grid name
  OCEGRID=iconR${R}B0${B}-ocean_etopo40_planet.nc
  ATMOGRID=iconR${R}B0${B}-atmo_etopo40_planet.nc

  create_ocean_grid
fi


#-----------------------------------------------------------------------------
# exit
#-----------------------------------------------------------------------------
