#!/bin/ksh
#=============================================================================
#
# Leonidas Linardakis   MPI-M,   2009-12 
# Stephan Lorenz        MPI-M,   2010-07 
#
# This script creates the ICON grid for the ocean model. Moreover, the
# land-sea-mask used in the ocean model and, in the coupled case in the
# atmosphere as well, is created.
# The ocean grid is created with root division 2 and up to level 6
# using the respective optimization algorithms:
#
#=============================================================================
#
# This section of the run script containes the specifications of the ocean grid
#
# The ocean part in the ocean grid generator can be defined in these ways:
# A. create_basin=".true."
#    Using geometric conditions (no_of_conditions=1) and $SEADEPTH for creating a basin
# B. create_aqua_planet=".true."
#    No conditions: no_of_conditions=0, elevation_file='', $SEADEPTH for aqua planet
# C. create_etopo40_flat=".true."
#    Using etopo40 file to create a land-sea-mask and a flat bottom bathymetry ($LSMDEPTH, $SEADEPTH)
# D. create_etopo40_planet=".true."
#    Using etopo40 file to create a land-sea-mask and ocean bathymetry ($LSMDEPTH)
#
# There are three parameters determining the resultant ocean bathymetry
#    min_sea_depth=$LSMDEPTH gives the value to decide whether a point is land or sea
#    If set_sea_depth=$SEADEPTH is given then an ocean with flat bottom will be created.
#    If set_min_sea_depth=$MINDEPTH is given then a sea-point gets this value as minimum depth
#      which can be set to the thickness of the first two layers
# 
# There are two options regarding the cells contained in the ocean grid:
# only_get_sea_land_mask=.true.  The global grid will be written with the sea-land mask
#                                defined as above
# only_get_sea_land_mask=.false. Only the ocean part will be written, land part is not defined
# 
# The user can define if smoothing will be applied: No ocean triangle cell is allowed to be
#    neighbored by more than one land cell
# smooth_ocean_boundary=[.true.][.false.]  
# 
#-----------------------------------------------------------------------------

#-----------------------------------------------------------------------------
#create_basin=".true."
#create_aqua_planet=".true."
#create_etopo40_flat=".true."
create_etopo40_planet=".true."
#-----------------------------------------------------------------------------
# plot_grid=".true."
#-----------------------------------------------------------------------------


#-----------------------------------------------------------------------------
if [[ "x$target" = "xsx9" ]] ; then
  echo "Disabled for ${target}. Copying grids from buildbot.grids."
  cp  ../../../../buildbot.grids/* ${basedir}/grids
  check_error 0 "create_nested_grids"
  exit 0
fi
#-----------------------------------------------------------------------------


#-----------------------------------------------------------------------------
set_default_optimization_grids()
{
dual_iterations=0       # prime/dual iterations
max_iterations=10000

# use_optimization='.false.'
use_barycenter_force='.false.'
barycenter_force_coeff="1.0"

use_isotropy_force='.false.'
isotropy_rotation_coeff="0.5"
isotropy_stretch_coeff="0.1"

use_edge_springs='.false.'
use_adaptive_spring_length='.false.'
use_local_reference_length='.false.'
local_reference_length_coeff=1.0

prime_ref_length_coeff=1.1
minedge_ref_length_weight=0.2
prime_soft_spring_stiffness=1.0  # the stiffness of "large" prime springs
prime_hard_spring_stiffness=1.0  # the stiffness of "small" prime springs

use_centers_spring_correction='.false.'
centers_springcorrection_coeff=0.25

use_prime_spring_cellcenters='.false.'
use_dual_spring_cellcenters='.false.'
centers_ref_length_coeff=0.9
centers_spring_stiffness=1.0  # the stiffness of vertex-cell center springs

spring_friction=1.6
spring_dt=1.6e-2
use_adaptive_dt='.false.'
max_dt_distance_ratio=5.0e-5

prime_total_force_condition=0.05  # exit condition for total force
prime_max_force_condition=0.01   # exit condition for max force
max_min_condition=1.1            # exit condition for max/min edge
centers_vertex_condition=1.005

centers_local_condition=1.0

#-----------------------------
optimize_vertex_depth=4

}
#-----------------------------------------------------------------------------


#-----------------------------------------------------------------------------
set_comb_optimization_grids()
{
  set_default_optimization_grids
  
#   use_optimization='.true.'

  use_edge_springs='.true.'
  prime_ref_length_coeff=1.0
  use_adaptive_spring_length='.true.'
  
  use_local_reference_length='.true.'
  local_reference_length_coeff=0.75
  
#   use_prime_spring_cellcenters='.true.'
#   centers_ref_length_coeff=1.0 
#   centers_spring_stiffness=1.0  # the stiffness of vertex-cell center springs
  
  use_isotropy_force='.true.'
  isotropy_rotation_coeff=1.0
  isotropy_stretch_coeff=0.1
}
#-----------------------------------------------------------------------------


#-----------------------------------------------------------------------------
create_optimization_namelist()
{
# optimization namelist
parameterFile=$1
tmpFile=optimization_namelist.tmp
set_comb_optimization_grids
cat > $tmpFile << EOF
&grid_optimization
  use_optimization              = $use_optimization
  max_iterations                = $max_iterations
  use_edge_springs              = $use_edge_springs
  use_adaptive_dt               = $use_adaptive_dt
  use_prime_spring_cellcenters  = $use_prime_spring_cellcenters
  use_dual_spring_cellcenters   = $use_dual_spring_cellcenters
  max_dt_distance_ratio         = $max_dt_distance_ratio
  prime_ref_length_coeff        = $prime_ref_length_coeff
  centers_ref_length_coeff      = $centers_ref_length_coeff
  minedge_ref_length_weight     = $minedge_ref_length_weight
  prime_soft_spring_stiffness   = $prime_soft_spring_stiffness
  prime_hard_spring_stiffness   = $prime_hard_spring_stiffness   
  centers_spring_stiffness      = $centers_spring_stiffness
  use_centers_spring_correction = $use_centers_spring_correction
  centers_springcorrection_coeff= $centers_springcorrection_coeff
  spring_friction               = $spring_friction
  spring_dt                     = $spring_dt
  p_total_force_condition       = $prime_total_force_condition
  p_max_force_condition         = $prime_max_force_condition
  max_min_condition             = $max_min_condition
  centers_vertex_condition      = $centers_local_condition
  use_adaptive_spring_length    = $use_adaptive_spring_length
  use_local_reference_length    = $use_local_reference_length
  local_reference_length_coeff  = $local_reference_length_coeff
  use_isotropy_force       = $use_isotropy_force
  isotropy_rotation_coeff       = $isotropy_rotation_coeff
  isotropy_stretch_coeff        = $isotropy_stretch_coeff
  use_barycenter_force          = $use_barycenter_force
  barycenter_force_coeff        = $barycenter_force_coeff
  optimize_vertex_depth         = $optimize_vertex_depth
/
EOF
#-----------------------------------------------------------------------------
cat $tmpFile >> $parameterFile
rm $tmpFile
}


#-----------------------------------------------------------------------------
# function to create the input grids
create_input_grids()
{
  # define the levels to create
  input_grids_no_of_levels=$1
  input_grids_optimization_extension=$2
  #-----------------------------------------------------------------------------
  input_grids_parameterFile=create_icon_grid.namelist
  input_grids_commandFile=command.grid
  input_grids_command=create_icon_grid
  input_grids_run_commmand="$bindir/grid_command"
  #-----------------------------------------------------------------------------

cat > $input_grids_parameterFile << EOF
&icosahedron_grid
  no_of_levels = $input_grids_no_of_levels
  start_level =  0
  start_optimize= 1
  end_optimize  = $input_grids_no_of_levels
  refinement_method = 1
  output_file  = 'iconR2B'
  optimization_extension = '$input_grids_optimization_extension'
/
EOF

use_optimization='.true.'
create_optimization_namelist $input_grids_parameterFile
#-----------------------------------------------------------------------------
# run grid generator
echo $input_grids_command $input_grids_parameterFile > $input_grids_commandFile
${start} ${input_grids_run_commmand}
check_error $? "create input grids"

}

#-----------------------------------------------------------------------------
# function to create one ocean grid
create_ocean_grid()
{
  #-----------------------------------------------------------------------------
  # absolute paths of directories
  GRIDDIR=${basedir}/grids            # graphs, grids and patches
  EXTDDIR=${basedir}/data/external     # external directory for topography file
  #-----------------------------------------------------------------------------
  if [ ! -d $GRIDDIR ]; then
#     echo $GRIDDIR does nor exists
#     exit
    mkdir -p $GRIDDIR
  fi
  cd $GRIDDIR
  #-----------------------------------------------------------------------------

  #-----------------------------------------------------------------------------
  # refine ocean grid from REFINE_ITERATIONS level coarser than target level:
  #-----------------------------------------------------------------------------
  # construct input grid name
  if (( $REFINE_ITERATIONS > $B )) ; then
    echo "REFINE_ITERATIONS cannot be greater than required level."
    check_error 1 "REFINE_ITERATIONS cannot be greater than required level."
    exit 1
  fi    
  # typeset -Z2 Bm1 B it does not work on squall, needs further check
  ((Bm1=B-$REFINE_ITERATIONS))
  INPGRID_EXT="-grid"
  INPGRID=iconR${R}B0${Bm1}${INPGRID_EXT}.nc
  # if the INPGRID does not exits, create it
  if [[ ! -f $INPGRID ]] ; then
    create_input_grids ${Bm1} ${INPGRID_EXT}
  fi
    
  #-----------------------------------------------------------------------------
  command=create_ocean
  parameterFile=NAMELIST_OCEAN_GRID
  commandFile=command.grid
  run_commmand="$bindir/grid_command"
  #-----------------------------------------------------------------------------

  #-----------------------------------------------------------------------------
  # respective icon topography file interpolated from regular topography file $TOPFILE
  TOPICON=iconR${R}B${Bm1}-topo.nc
  # respective elevation file to read topography in icon grid for decision of sea-land-mask
  #  - for aquaplanet, or special basins: TOPFILE not used
  if [[ "x$TOPFILE" == "x" ]]; then
    ELEVF=""
  else
    ELEVF="$GRIDDIR/$TOPICON"
  fi

  # interpolate regular topography into icon grid
  if [[ "x$TOPFILE" != "x" ]]; then
    if [[ ! -s  "$GRIDDIR/$TOPICON" ]]; then
      # now use edited $TOPICON from EXTDDIR if it exists there under svn control:
      if [[ -s  "$EXTDDIR/$TOPICON" ]]; then
        cp "$EXTDDIR/$TOPICON" "$GRIDDIR/$TOPICON"
        check_error $? "cp $EXTDIR/$TOPICON $GRIDDIR/$TOPICON"
      else
        if [[ -s  "$EXTDDIR/$TOPFILE" ]]; then
          echo " Now running:"
          echo " cdo remapcon,$GRIDDIR/$INPGRID $EXTDDIR/$TOPFILE $GRIDDIR/$TOPICON"
          cdo remapcon,$GRIDDIR/$INPGRID $EXTDDIR/$TOPFILE $GRIDDIR/$TOPICON
          check_error $? "cdo remapcon,$GRIDDIR/$INPGRID $EXTDDIR/$TOPFILE $GRIDDIR/$TOPICON"
        else
          echo " no file  $EXTDDIR/$TOPFILE available - exit script"
          check_error 1 "no file $EXTDDIR/$TOPFILE available - exit script"
        fi  # TOPFILE exists
      fi  # EXTDDIR/TOPICON exists
    fi  # GRIDDIR/TOPICON exists
  fi  # TOPFILE needed

  #-----------------------------------------------------------------------------
  # in case of missing values
  LSMDEPTH=${LSMDEPTH:=0.0}
  SEADEPTH=${SEADEPTH:=0.0}
  MINDEPTH=${MINDEPTH:=${LSMDEPTH}}

  #-----------------------------------------------------------------------------
  # namelist
cat > $parameterFile << EOF
&grid_geometry_conditions    
  no_of_conditions   = $no_of_conditions       ! 1: create ocean basin with patch_center and radius; 0: no conditions
  patch_shape        = $patch_shape            ! 1: rectangle; 2: circle_shape
  rectangle_xradious = $rectangle_xradious  ! half diameter of meridional extension in degrees
  rectangle_yradious = $rectangle_yradious  ! half diameter of zonal extension in degrees
  circle_radious     = $circle_radious
  patch_center_x     = $patch_center_x       ! longitude of center
  patch_center_y     = $patch_center_y       ! latitude  of center
/
&create_ocean_grid
  only_get_sea_land_mask    = $only_get_sea_land_mask
  smooth_ocean_boundary     = $smooth_ocean_boundary
  output_ocean_file         = '$OCEGRID'
  output_atmo_file          = ''
  input_file                = '$INPGRID'
  elevation_file            = '$ELEVF'             ! elevation file on icon grid
  elevation_field           = 'ROSE'               ! array name in output file
  min_sea_depth             = $LSMDEPTH
  edge_elev_interp_method   = $INTMTH  
  set_sea_depth             = $SEADEPTH
  set_min_sea_depth         = $MINDEPTH
  refine_iterations         = $REFINE_ITERATIONS
/
EOF

  #-----------------------------------------------------------------------------
  if [[ "x$optimize_ocean_grids" = "x.true." ]] ; then
    use_optimization='.true.'
  else
    use_optimization='.false.'    
  fi
  create_optimization_namelist $parameterFile
  #-----------------------------------------------------------------------------
  
  # create the ocean grid
  echo $command $parameterFile > $commandFile
  ${start} ${run_commmand}
  check_error $? "create $OCEGRID"
  #-----------------------------------------------------------------------------
  
  #-----------------------------------------------------------------------------
  # plot sea -land mask
  nclscript=../scripts/postprocessing/tools/plotIconSphereGrid.ncl
  if [[ "x$plot_grid" = "x.true." ]] ; then
#   echo ncl $nclscript \'grid=\"$GRIDDIR/$OCEGRID\"\'   \'var=\"edge_elevation\"\' > __tmp__
    echo ncl $nclscript \'grid=\"$GRIDDIR/$OCEGRID\"\'   \'var=\"edge_sea_land_mask\"\' > __tmp__
    chmod +x  __tmp__
    ./__tmp__
    rm __tmp__
  fi
  
}
#-----------------------------------------------------------------------------


#-----------------------------------------------------------------------------
# create ocean basin
if [[ x$create_basin = "x.true." ]] ; then
  # grid parameters
  R=2                   # nroot
  B=4                   # no. of bisections applied for the global grid
  REFINE_ITERATIONS=3   # no. of refinements after smoothing ocean boundary
                        #  - resolution for smoothing is ((B-REFINE_ITERATIONS))
  optimize_ocean_grids=".true."
  only_get_sea_land_mask=".true."
  smooth_ocean_boundary=".true."
  #bathymetry parameters
  SEADEPTH="-12000.0"   # set ocean bathymetry to constant (flat bottom)
  INTMTH=3              # edge elevation interpolation method: 1= linear, 2=min,  3=max
  # topography file
  TOPFILE=""            # no topography file used for the basin
  #conditions
  no_of_conditions=1    # use parameter for new Stommel basin (see below)
  patch_shape=2
  rectangle_xradious=50.0
  rectangle_yradious=30.0
  circle_radious=30.0
  patch_center_x=0.0
  patch_center_y=30.0
  # patch_shape=1            # 1=orthogonal, 2= circle   #  1 for slo; 2 for pk
  # rectangle_xradious=50.0  # x radius for orthogonal   # 50 for slo
  # rectangle_yradious=30.0  # y radius for orthogonal   # 30 for slo
  # circle_radious=30.0      # radius of circle          #             30 for pk
  # patch_center_x=-25.0     # x center for radius       #-25 for slo;  0 for pk
  # patch_center_y=45.0      # y center for radius       # 45 for slo; 30 for pk
  # output grid name
  # OCEGRID=iconR${R}B0${B}-ocean_basin.nc
  OCEGRID=iconR${R}B0${B}-ocean_bas10-80N.nc  #  new Stommel basin slo 10-80N
  OCEGRID=iconR${R}B0${B}-ocean_bas0-60N.nc   #  new Stommel basin pk 0-60N
  ATMOGRID=iconR${R}B0${B}-atmo_basin.nc

  create_ocean_grid
fi


#-----------------------------------------------------------------------------
# create aqua planet with flat bottom
if [[ x$create_aqua_planet = "x.true." ]] ; then
  # grid parameters
  R=2                   # nroot
  B=4                   # number of bisections applied for the global grid
  REFINE_ITERATIONS=0
  optimize_ocean_grids=".true."
  only_get_sea_land_mask=".true."
  smooth_ocean_boundary=".false."
  #bathymetry parameters
  SEADEPTH="-12000.0"   # set ocean bathymetry to constant (flat bottom)
  INTMTH=3              # edge elevation interpolation method: 1= linear, 2=min,  3=max
  # topography file
  TOPFILE=""            # no topography file used for aqua planet
  #conditions
  no_of_conditions=0
  # output grid name
  OCEGRID=iconR${R}B0${B}-ocean_aqua_planet.nc
  ATMOGRID=iconR${R}B0${B}-atmo_aqua_planet.nc

  create_ocean_grid
fi

#-----------------------------------------------------------------------------
# create etopo40 flat bottom bathymetry
if [[ x$create_etopo40_flat = "x.true." ]] ; then
  # grid parameters
  R=2                   # nroot
  B=4                   # number of bisections applied for the global grid
  REFINE_ITERATIONS=0   # resolution for defining LSM is $B-$REFINE_ITERATIONS
  optimize_ocean_grids=".false."
  only_get_sea_land_mask=".true."
  smooth_ocean_boundary=".true."
  #bathymetry parameters
  LSMDEPTH="0.0"        # minimum bathymetry depth to consider grid point as sea [m] in elevation file
  SEADEPTH="-12000.0"   # set ocean bathymetry to constant value (flat bottom)
  INTMTH=3              # edge elevation interpolation method: 1= linear, 2=min,  3=max
  # topography file
  TOPFILE="etopo40.cdf" # topography file on regular grid to create land-sea-mask
  #conditions
  no_of_conditions=0
  # output grid name
  OCEGRID=iconR${R}B0${B}-ocean_etopo40_flat.nc
  ATMOGRID=iconR${R}B0${B}-atmo_etopo40_planet.nc

  create_ocean_grid
fi

#-----------------------------------------------------------------------------
# create etopo40 variable bathymetry
if [[ x$create_etopo40_planet = "x.true." ]] ; then
  # grid parameters
  R=2                   # nroot
  B=4                   # number of bisections applied for the global grid
  REFINE_ITERATIONS=0   # resolution for defining LSM is $B-$REFINE_ITERATIONS
  optimize_ocean_grids=".false."
  only_get_sea_land_mask=".true."
  smooth_ocean_boundary=".true."
  #bathymetry parameters
  LSMDEPTH="0.0"        # minimum bathymetry depth to consider grid point as sea [m] in elevation file
  SEADEPTH=""           # not used here
  MINDEPTH="-40.0"      # set to minimum bathymetry depth when gridpoint considered as sea
  INTMTH=3              # edge elevation interpolation method: 1= linear, 2=min,  3=max
  # topography file
  TOPFILE="etopo40.cdf" # topography file on regular grid to create land-sea-mask
  #conditions
  no_of_conditions=0
  # output grid name
  OCEGRID=iconR${R}B0${B}-ocean_etopo40_planet.nc
  ATMOGRID=iconR${R}B0${B}-atmo_etopo40_planet.nc

  create_ocean_grid
fi


#-----------------------------------------------------------------------------
# exit
#-----------------------------------------------------------------------------
