# Path to the root source directory:
srcdir:= @srcdir@

# Relative path to the directory with the preprocessed source files:
ppdir:= pp

# CLAW preprocessing subdirectory:
CLAW_ppdir:= claw

# Relative path to the directory with the '.xmod' files:
xmoddir:= $(ppdir)/$(CLAW_ppdir)/xmod

############################ SOURCE FILE COLLECTION ############################

# By default, CLAW performs the code transformation (deep preprocessing) only if
# the input file contains CLAW directives. Otherwise, the contents of the input
# file are copied as-is to the output (shallow preprocessing). The deep
# preprocessing of a Fortran file requires additional information, which is
# stored in the '.xmod' files: if the code in the input file uses a Fortran
# module, the respective '.xmod' file needs to be generated in advance. CLAW
# implements an algorithm that generates the required '.xmod' files
# automatically. However, it reduces the transparency of the process (and poses
# a significant limitation in the case of the old CLAW driver, which we
# currently still support: all CLAW preprocessing jobs must run serially). The
# alternative is to generate the '.xmod' files as a side effect of the code
# transformation: similar to the regular Fortran compilers, CLAW generates
# '.xmod' files when performing the deep preprocessing of a source file that
# declares the respective Fortran modules. That is, we can generate the required
# '.xmod' files by enforcing the code transformation of the corresponding source
# files in the right topologically sorted order: files that declare Fortran
# modules are processed before files that use them. Note that there are cases
# when CLAW is unable to perform the code transformation but still generates the
# required '.xmod' files.
#
# The deep preprocessing is expensive and fragile. Therefore, we have to
# minimize the number of files that undergo it. For that reason, we distinguish
# three types of input files:
#   1. Primary input files with CLAW directives. These files undergo the deep
#      preprocessing unconditionally.
#   2. Primary input files without CLAW directives. These files undergo the
#      shallow preprocessing unconditionally. However, some of these files might
#      declare Fortran modules that are used in files that undergo the deep
#      preprocessing (e.g. all files in 1.). Files that fall under such cases
#      additionally undergo the deep preprocessing but only the interface part
#      of a Fortran module is parsed in order to generate the respective '.xmod'
#      file (the old CLAW driver does not support the partial parsing,
#      therefore, it is allowed to fail, as long a all the required '.xmod'
#      files are generated).
#   3. Secondary input files. Regardless of having CLAW directives, these files
#      undergo the aforementioned partial deep preprocessing (see 2.) only if
#      they declare Fortran modules that are used in files that must undergo the
#      deep preprocessing.

# Primary input '.f90' files:
f90_files:= $(CLAW_in_f90_files)
# Secondary input '.f90' files:
xmod_f90_files:= $(filter-out $(f90_files),$(CLAW_xmod_f90_files))

# Relative paths to the directories with Fortran include files:
inc_subdirs:= $(CLAW_inc_subdirs)

################################ UTILITY FILES #################################

# Dependency files (ensure the topologically sorted order of the preprocessing):
dep_files:= $(addprefix $(ppdir)/$(CLAW_ppdir)/,$(addsuffix .claw.d,$(f90_files) $(xmod_f90_files:.f90=.xmodstamp)))

# Stamp files of the preprocessing subdirectories:
dir_files= $(filter-out ./.dirstamp,$(addsuffix .dirstamp,$(sort $(dir $(dep_files))) $(xmoddir)/))

########################### BUILDING TOOLS AND FLAGS ###########################

# Compilers and utilities:
CLAW= @CLAW@
PYTHON= @PYTHON@
DEPGEN= ${PYTHON} $(srcdir)/utils/mkhelper/depgen.py

# CLAW flags:
#   We set '-w 1000' to minimize the number of line continuations introduced by
#   CLAW because they might break compilation with Intel and potentially other
#   compilers. Ideally, we would choose a larger number (~2000) to prevent the
#   automatically generated line continuations at all. Unfortunatelly,
#   PGI/NVIDIA compilers refuse to compile Fortran files with lines exceeding
#   1001 character. However, the value we set seems to be enough to avoid most
#   of the poorly injected line breaks.
CLAWFLAGS= --no-dep -w 1000 @CLAW_MOD_IN@$(xmoddir) @CLAW_MOD_OUT@$(xmoddir) $(addprefix -I$(srcdir)/,$(inc_subdirs)) $(addprefix @CLAW_MOD_IN@$(srcdir)/externals/omni-xmod-pool/,mpi/3.0 self/0.2 yaxt/0.7.0 mtime/1.0.8 cdi/1.8.x) @CLAWFLAGS@
@CLAW_OLD_DRIVER_ENABLED@CLAWFLAGS+= --Wf-no-module-cache
@CLAW_NEW_DRIVER_ENABLED@CLAWFLAGS+= --disable-mp --no-module-cache
@JSBACH_ENABLED@CLAWFLAGS+= --model-config=$(srcdir)/externals/jsbach/config/icon_jsbach.toml

ICON_CLAWFLAGS=
ICON_OCEAN_CLAWFLAGS=
DEPGEN_CLAWFLAGS= @DEPGEN_CLAWFLAGS@

# Fortran compiler flags:
FCFLAGS= @FCFLAGS@
ICON_FCFLAGS= @ICON_FCFLAGS@
ICON_OCEAN_FCFLAGS= @ICON_OCEAN_FCFLAGS@

# Auxiliary function. Filters the requested Fortran compiler flags and turns
# them into respective CLAW flags. Receives three arguments:
#   (1) the prefix of the requested Fortran compiler flags (allowed to have a
#       significant trailing whitespace);
#   (2) the respective prefix understood by CLAW (no trailing whitespaces are
#       allowed);
#   (3) a list of Fortran compiler arguments.
# Examples:
#   1) FCFLAGS= -WF,-D   MACRO1 -WF,-DMACRO2 -I irrelevant args
#      FC_MACRO_PREFIX= -WF,-D
#      result:= $(call convert_fcflags,$(FC_MACRO_PREFIX),-D,$(FCFLAGS))
#      result equals to: `-DMACRO1 -DMACRO2`
#   2) FCFLAGS= -WF,-D   MACRO1 -WF,-DMACRO2 -I irrelevant args
#      FC_MACRO_PREFIX= -WF,-D # significant trailing whitespace
#      result:= $(call convert_fcflags,$(FC_MACRO_PREFIX),-D,$(FCFLAGS))
#      result equals to `-DMACRO1`
convert_fcflags= $(filter $(2)%,$(subst $(2) ,$(2),$(subst $(1),$(2),$(strip $(3)))))

FC_INC_FLAG_PP= @FC_INC_FLAG_PP_f90@
CLAWFLAGS+= $(call convert_fcflags,$(FC_INC_FLAG_PP),-I,$(FCFLAGS))
ICON_CLAWFLAGS+= $(call convert_fcflags,$(FC_INC_FLAG_PP),-I,$(ICON_FCFLAGS))
ICON_OCEAN_CLAWFLAGS+= $(call convert_fcflags,$(FC_INC_FLAG_PP),-I,$(ICON_OCEAN_FCFLAGS))

FC_INC_FLAG= @FC_INC_FLAG@
ifneq ($(FC_INC_FLAG),$(FC_INC_FLAG_PP))
CLAWFLAGS+= $(call convert_fcflags,$(FC_INC_FLAG),-I,$(FCFLAGS))
ICON_CLAWFLAGS+= $(call convert_fcflags,$(FC_INC_FLAG),-I,$(ICON_FCFLAGS))
ICON_OCEAN_CLAWFLAGS+= $(call convert_fcflags,$(FC_INC_FLAG),-I,$(ICON_OCEAN_FCFLAGS))
endif

FC_PP_MACRO_FLAG= @FC_PP_DEF@
CLAWFLAGS+= $(call convert_fcflags,$(FC_PP_MACRO_FLAG),-D,$(FCFLAGS))
ICON_CLAWFLAGS+= $(call convert_fcflags,$(FC_PP_MACRO_FLAG),-D,$(ICON_FCFLAGS))
ICON_OCEAN_CLAWFLAGS+= $(call convert_fcflags,$(FC_PP_MACRO_FLAG),-D,$(ICON_OCEAN_FCFLAGS))

############################### MAKEFILE TWEAKS ################################

# Silent rule prefixes:
V= @DEFAULT_VERBOSITY@
ifeq ($(V),0)
silent_CLAW=    @echo "  CLAW    " $@;
silent_DEPGEN=  @echo "  DEPGEN  " $@;
silent_MKDIR=   @echo "  MKDIR   " $(@D);
silent_XMOD=    @echo "  XMOD   <" $<;
endif

# Disable built-in suffix rules:
.SUFFIXES:
# Delete partially updated files:
.DELETE_ON_ERROR:
# Targets not associated with files:
.PHONY: all mostlyclean clean distclean sanitize-mod-proxies

# Targets that do not need the dependency files:
nodep_targets:= dummy-depend mostlyclean clean distclean

# Selective search paths:
vpath %.f90 $(srcdir)

############################### INTERFACE RULES ################################

# Default rule:
all: $(CLAW_mk_targets)

# Delete files generated at the building stage:
clean: mostlyclean
	rm -f $(dep_files:.claw.d=)
	rm -f $(addprefix $(ppdir)/$(CLAW_ppdir)/,$(f90_files:.f90=.xmodstamp))
	rm -f $(xmoddir)/*.xmod $(xmoddir)/*.xmod.proxy

# Delete everything generated at the configure stage:
distclean: clean
	rm -f $(dep_files)
	rm -f $(dir_files)
	rm -f claw.mk

########################### CLAW PREPROCESSING RULES ###########################

ICON_CLAW_CMD=       $(CLAW) -o $@ $(CLAWFLAGS) $(ICON_CLAWFLAGS) $<
ICON_OCEAN_CLAW_CMD= $(CLAW) -o $@ $(CLAWFLAGS) $(ICON_OCEAN_CLAWFLAGS) $<

# Auxiliary function. Returns a non-empty string if a source file, the argument
# of the function, is part of ICON-Ocean, and an empty string otherwise.
# See icon.mk for the rationale behind this function.
is_ocean_src= $(strip $(foreach d,src/hamocc/ src/ocean/ src/sea_ice/,$(findstring $(d),$(1))))

$(ppdir)/$(CLAW_ppdir)/%.f90: %.f90 | $(dir_files)
	$(silent_CLAW)$(if $(call is_ocean_src,$<),$(ICON_OCEAN_CLAW_CMD),$(ICON_CLAW_CMD))

############################ XMOD GENERATION RULES #############################

# These are similar to $(ICON_CLAW_CMD) and $(ICON_OCEAN_CLAW_CMD) but serve
# the purpose of the '.xmod' file generation, therefore:
#   1) the deep preprocessing is enforced;
#   2) the output of CLAW is dropped as irrelevant (old driver only);
#   3a) the command is allowed to fail (old driver only);
#   3b) errors in non-interface parts of the Fortran modules are ignored (new
#       driver only).
@CLAW_OLD_DRIVER_ENABLED@ICON_XMOD_CMD=       $(CLAW) -f $(CLAWFLAGS) $(ICON_CLAWFLAGS) $< >/dev/null; touch $@
@CLAW_OLD_DRIVER_ENABLED@ICON_OCEAN_XMOD_CMD= $(CLAW) -f $(CLAWFLAGS) $(ICON_OCEAN_CLAWFLAGS) $< >/dev/null; touch $@
@CLAW_NEW_DRIVER_ENABLED@ICON_XMOD_CMD=       $(CLAW) -f --gen-mod-files $(CLAWFLAGS) $(ICON_CLAWFLAGS) $< && touch $@
@CLAW_NEW_DRIVER_ENABLED@ICON_OCEAN_XMOD_CMD= $(CLAW) -f --gen-mod-files $(CLAWFLAGS) $(ICON_OCEAN_CLAWFLAGS) $< && touch $@

$(ppdir)/$(CLAW_ppdir)/%.xmodstamp: %.f90 | $(dir_files)
	$(silent_XMOD)$(if $(call is_ocean_src,$<),$(ICON_OCEAN_XMOD_CMD),$(ICON_XMOD_CMD))

@CLAW_OLD_DRIVER_ENABLED@MODCMP_CMD= ${PYTHON} $(srcdir)/utils/mkhelper/fortmodcmp.py '$@' '$(@:.proxy=)' omni 2>/dev/null
@CLAW_NEW_DRIVER_ENABLED@MODCMP_CMD= cmp '$@' '$(@:.proxy=)' >/dev/null 2>&1

$(xmoddir)/%.xmod.proxy:| sanitize-mod-proxies
	@if test -z '$<'; then \
	  echo "Cannot find Fortran source file providing module '$(basename $(@F:.proxy=))'." >&2; \
	else \
	  if test ! -f '$(@:.proxy=)'; then rm -f '$<'; $(MAKE) -f claw.mk '$<'; fi; \
	  if $(MODCMP_CMD); then :; \
	  else cp '$(@:.proxy=)' '$@' 2>/dev/null; fi; \
	fi

sanitize-mod-proxies:
	@rm -f $(filter-out $(addsuffix .proxy,$(wildcard $(moddir)/*.xmod)),$(wildcard $(moddir)/*.xmod.proxy))

############################### AUXILIARY RULES ################################

# Directory creation rule:
%/.dirstamp:
	$(silent_MKDIR)@MKDIR_P@ $(@D) && touch $@

# Keep directory stamps:
.PRECIOUS: $(dir_files)

######################### DEPENDENCY GENERATION RULES ##########################

DEPGEN_CMD_prefix= $(DEPGEN) @depgen.f90.config \
                   --pp-inc-flag=-I --pp-macro-flag=-D \
                   --fc-mod-ext=xmod.proxy --fc-mod-upper=no \
                   --fc-inc-flag=-I --fc-mod-dir-flag='@CLAW_MOD_OUT@' \
                   -o $@ -i $<

DEPGEN_CMD_suffix= -- $(DEPGEN_CLAWFLAGS) $(CLAWFLAGS) \
                   $(if $(call is_ocean_src,$<),$(ICON_OCEAN_CLAWFLAGS),$(ICON_CLAWFLAGS))

DEPGEN_CMD= $(DEPGEN) $(DEPGEN_ARGS) --obj-name $(@:.claw.d=) -- \
                      $(DEPGEN_CLAWFLAGS) $(CLAWFLAGS) \
                      $(if $(call is_ocean_src,$<),$(ICON_OCEAN_CLAWFLAGS),$(ICON_CLAWFLAGS))

# Dependency generation rule for the primary input files
# (CLAW_FILTER_CMD checks input files for the presence of CLAW directives):
@CLAW_OLD_DRIVER_ENABLED@CLAW_FILTER_CMD= $(srcdir)/utils/claw-helpers/claw_filter.sh $< >/dev/null
@CLAW_NEW_DRIVER_ENABLED@CLAW_FILTER_CMD= test -n "`$(CLAW) --print-claw-files $< 2>/dev/null`"

$(ppdir)/$(CLAW_ppdir)/%.f90.claw.d: %.f90 icon.mk claw.mk depgen.f90.config | $(dir_files)
	$(silent_DEPGEN) \
	if $(CLAW_FILTER_CMD); then \
	  oname='$(@:.claw.d=)'; \
	else \
	  oname='$(@:.f90.claw.d=.xmodstamp)'; \
	fi; \
	$(DEPGEN_CMD_prefix) --obj-name "$$oname" $(DEPGEN_CMD_suffix)

# Dependency generation rule for the secondary input files:
$(ppdir)/$(CLAW_ppdir)/%.xmodstamp.claw.d: %.f90 icon.mk claw.mk depgen.f90.config | $(dir_files)
	$(silent_DEPGEN)$(DEPGEN_CMD_prefix) --obj-name $(@:.claw.d=) $(DEPGEN_CMD_suffix)

# Dummy dependency file generation rule:
dummy-depend: | $(dir_files)
	@for file in $(dep_files); do \
	  test -e "$$file" || touch "$$file"; \
	done

# Include dependencies if required:
current_targets:= $(strip $(MAKECMDGOALS))
ifeq (,$(current_targets))
current_targets:= all
endif

ifneq (,$(filter-out $(nodep_targets),$(current_targets)))
include $(dep_files)
endif
