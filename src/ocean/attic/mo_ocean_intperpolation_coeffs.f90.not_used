
!>
!! Contains the implementation of interpolation and reconstruction.
!!
!! Contains the implementation of interpolation and reconstruction
!! routines used by the shallow water model, including the RBF
!! reconstruction routines.
!!
!! @par Revision History
!! Developed  by Luca Bonaventura and Will Sawyer (2002-4).
!! Modified to ProTeX-style by  Luca Bonaventura and Thomas Heinze (2004).
!! Adapted to new data structure by Thomas Heinze,
!! Peter Korn and Luca Bonaventura (2005).
!! Modification by Thomas Heinze (2006-02-21):
!! - renamed m_modules to mo_modules
!! Modification by Thomas Heinze (2006-07-05):
!! - modified cell2edge_lin_int_coeff
!! - created cc_dot_product
!! Modification by Peter Korn and Luca Bonaventura(2006-07-28):
!! - moved several auxiliary functions to mo_math_utilities
!! - introduced recoded rbf interpolation for vector fields
!! - added lraviart switch to force RT interpolation to be used
!! Modification by Thomas Heinze  and Luca Bonaventura(2006-10-05):
!! - merged with 'Milano' version by P. Korn
!! Modification by Pilar Ripodas (2006-11):
!! - new subroutine rbf_vec_interpol_car with the cartesian
!!   coordinates as output
!! Modification by Peter Korn, MPI-M, (2006-11-23):
!! - replacements in TYPE patch: ic by l2g_c, ie by l2g_e, iv by l2g_v,
!!   iic by g2l_c, iie by g2l_e, iiv by g2l_v
!! - replaced edge_index by edge_idx
!! - replaced vertex_index by vertex_idx
!! - replaced cell_index by cell_idx
!! - replaced neighbor_index by neighbor_idx
!! Modification by Pilar Ripodas (2006-12):
!! - dt_tan_vec and dt_tan_rt_vec are wrong. They are renamed to
!!   dt_tan_vec_old and dt_tan_rt_vec_old and should not be used
!! - New subroutines dt_tan_vec_h and dt_tan_vec_kin and
!!   dt_tan_vec_gen are produced and
!!   moved to mo_sw_state.f90
!!  Modification by Peter Korn, MPI-M (2007-02)
!!  Modification by Hui Wan, MPI-M (2007-02-22)
!!  - changes in the USE section because
!!    the coordinate types had been move from mo_model_domain
!!    to mo_math_utilities;
!!  Modification by Almut Gassmann, MPI-M (2007-04)
!!  - removed reference to unused halo_verts
!!  - summing over all halos of the various parallel patches (Quick and Dirty!)
!!  Modification by Almut Gassmann, MPI-M (2007-04)
!!  - abandon grid for the sake of patch
!!  Modification by Thomas Heinze, DWD (2007-07-26)
!!  - including all the improvements of Tobias Ruppert's diploma thesis
!!  - several changes according to the programming guide
!!  Modification by Pilar Ripodas, DWD (2007-07):
!!  - substruct the outgoing component of the reconstructed
!!    vector in subroutine "rbf_vec_interpol_car"
!!  Modification by Thomas Heinze, DWD (2007-08-02)
!!  - replaced rbf_kern_dim by rbf_kern_dim_c
!!  - replaced rbf_vec_dim by rbf_vec_dim_c
!!  - replaced rbf_mat_dim by rbf_mat_dim_c
!!  - replaced rbf_vec_scale by rbf_vec_scale_c
!!  - replaced rbf_vec_pdeg_c by rbf_vec_rbf_vec_pdeg_c_c
!!  Modification by Hui Wan, MPI-M (2007-08-02; 2007-11-30)
!!  - added interpolation coefficients c_aw_e and e_aw_c
!!    and the initialization subroutine aw_int_coeff.
!!  - added subroutine edges2cells_scalar
!!  Modification by Jochen Foerstner, DWD (2008-05-05)
!!  - four new subroutines
!!      rbf_vec_index_vertex
!!      rbf_vec_compute_coeff_vertex
!!      rbf_vec_interpol_car_vertex
!!      prepare_simpson
!!    to reconstruct a Cartesian vector at the vertices using
!!    RBF interpolation and to prepare quadrature via the
!!    Simpson's rule.
!!  Modification by Marco Restelli, MPI (2008-07-17)
!!  - included the subroutines
!!      cells2vertex_scalar, cells2vertex_coeff, ravtom_normgrad2,
!!      ls_normgrad2, ls_normgrad2_ii, edges2points_vector
!!    to compute polynomial fitting with sufficient accuracy as
!!    required in SW-alpha model.
!!  Modification by Jochen Foerstner, DWD (2008-09-12)
!!  - moved SUBROUTINE ravtom_normgrad2 to mo_math_operators
!!    because of conflicting use statements.
!!  Modification by Almut Gassmann, MPI-M (2008-10-09)
!!  - added features for helicity bracket reconstruction
!!  Modification by Guenther Zaengl, DWD (2008-10-23)
!!  - added interpolation routines needed for mesh refinement
!!  Modification by Almut Gassmann, MPI-M (2009-01-29)
!!  - conforming scalar interpolation routines and adjusting coefficients
!!  Modification by Guenther Zaengl, DWD (2009-02-11)
!!  - all routines needed for grid refinement are moved into the new
!!    module mo_grf_interpolation
!!  Modification by Guenther Zaengl, DWD (2009-02-13)
!!  - RBFs are changed to direct reconstruction of velocity components on
!!    the sphere, avoiding the detour over the 3D Cartesian space
!!  Modification by Almut Gassmann, DWD (2009-03-17)
!!  - remove lraviart
!!  Modification by Almut Gassmann, MPI-M (2009-04-23)
!!  - remove all Raviart Thomas stuff, add edge to verts averaging
!!  Modification by Daniel Reinert, DWD (2009-07-20)
!!  - added subroutine grad_lsq_compute_coeff_cell to prepare
!!    (2D) gradient reconstruction at circumcenter via the least squares
!!    method.
!!  Modification by Almut Gassmann, MPI-M (2009-10-05)
!!  - set RBF vec dimensions to predefined values (edges:4,vertices:6,cells:9);
!!    All other switches and belongings are deleted. The reason is that
!!    the Hollingsworth instability requires 4 edges, cell reconstruction
!!    is only needed for output and vertices are only used in the bracket
!!    version, where the dimension at the vertices should be 6
!!  Modification by Daniel Reinert, DWD (2009-12-10)
!!  - replaced grad_lsq_compute_coeff_cell by lsq_compute_coeff_cell
!!    which initializes either a second order or a third order least squares
!!    reconstruction.
!!  Modification by Almut Gassmann, MPI-M (2010-01-12)
!!  - generalize p_int%primal_normal_ec and p_int%edge_cell_length to hexagons
!!  Modification by Almut Gassmann, MPI-M (2012-04-19)
!!  - added routine init_tplane_c, which projects vertices and mass points onto
!!    a plane tangent to cell centers.
!!
!! @par Copyright
!! 2002-2007 by DWD and MPI-M
!! This software is provided for non-commercial use only.
!! See the LICENSE and the WARRANTY conditions.
!!
!! @par License
!! The use of ICON is hereby granted free of charge for an unlimited time,
!! provided the following rules are accepted and applied:
!! <ol>
!! <li> You may use or modify this code for your own non commercial and non
!!    violent purposes.
!! <li> The code may not be re-distributed without the consent of the authors.
!! <li> The copyright notice and statement of authorship must appear in all
!!    copies.
!! <li> You accept the warranty conditions (see WARRANTY).
!! <li> In case you intend to use the code commercially, we oblige you to sign
!!    an according license agreement with DWD and MPI-M.
!! </ol>
!!
!! @par Warranty
!! This code has been tested up to a certain level. Defects and weaknesses,
!! which may be included in the code, do not establish any warranties by the
!! authors.
!! The authors do not make any warranty, express or implied, or assume any
!! liability or responsibility for the use, acquisition or application of this
!! software.
!!
!!

!----------------------------
#include "omp_definitions.inc"
!----------------------------

MODULE mo_ocean_interpolation_coeffs
  !
  USE mo_kind,                ONLY: wp
  USE mo_math_constants,      ONLY: pi2, pi_2, deg2rad
  USE mo_exception,           ONLY: message, finish
  USE mo_impl_constants,      ONLY: min_rlcell, min_rledge, min_rlvert, max_char_length,&
    & beta_plane_coriolis,full_coriolis,min_rledge_int,min_rlcell_int,min_rlvert_int
  USE mo_impl_constants_grf,  ONLY: grf_nudge_start_c, grf_nudge_start_e
  USE mo_model_domain,        ONLY: t_patch, t_grid_edges, t_grid_vertices, t_grid_cells, t_subset_range
  USE mo_grid_config,         ONLY: lplane, lfeedback, grid_sphere_radius, grid_angular_velocity
  USE mo_math_utilities,      ONLY: gc2cc, cc2gc, gnomonic_proj,               &
    & gvec2cvec, cvec2gvec,                      &
    & t_cartesian_coordinates,                   &
    & rotate_latlon, arc_length,                 &
    & t_geographical_coordinates, vector_product, plane_torus_closest_coordinates
  USE mo_dynamics_config,     ONLY: divavg_cntrwgt
  USE mo_parallel_config,     ONLY: nproma
  USE mo_loopindices,         ONLY: get_indices_c, get_indices_e, get_indices_v
  USE mo_sync,                ONLY: sync_c, sync_e, sync_v, sync_patch_array, sync_idx, global_max
  USE mo_intp_data_strc,      ONLY: t_int_state
  USE mo_interpol_config,     ONLY: i_cori_method, nudge_zone_width, nudge_max_coeff, &
    & nudge_efold_width
  USE mo_ocean_nml,           ONLY: n_zlev, dzlev_m, no_tracer, &
    & coriolis_type, basin_center_lat, basin_height_deg
  
  USE mo_grid_subset,         ONLY: t_subset_range, get_index_range
  USE mo_grid_geometry_info,  ONLY: planar_torus_geometry, sphere_geometry
  
  IMPLICIT NONE
  
  PRIVATE
  
  ! PUBLIC :: init_geo_factors_oce

  ! flags for computing ocean coefficients
  LOGICAL, PARAMETER :: mid_point_dual_edge = .TRUE. !Please do not change this unless
  !you are sure, you know what you do.
  LOGICAL, PARAMETER :: larc_length = .FALSE.
  
CONTAINS
  
  !-------------------------------------------------------------------------
  !>
  !! Computes the coefficients that determine the scalar product on the primal grid. This
  !! scalar product depends on the grid geometry only and  is used to formulate the primitive
  !! equations in weak form. The coefficients are applied in module "mo_scalar_product".
  !! The following components of the data type "ocean_patch" are filled:
  !!   edge2cell_coeff  : coefficients for edge to cell mapping
  !!   edge2cell_coeff_t: coefficients for transposed of edge to cell mappings
  !!   edge2vert_coeff  : coefficients for edge to vertex mapping
  !!   edge2vert_coeff_t: coefficients for transposed of edge to vertex mappings
  !!   fixed_vol_norm   : summed volume weight of moved cell
  !!   variable_vol_norm: volume weight at the edges of moved cell
  !!
  !! @par Revision History
  !!  developed by Peter Korn, MPI-M  2010-09
  !!  Modification by Stephan Lorenz, 2010-11
  !!  Parallelized by Leonidas Linardakis, 2012-3
  SUBROUTINE par_init_scalar_product_oce( patch, intp_2d_coeff)
    TYPE(t_patch)    , TARGET, INTENT(inout) :: patch
    TYPE(t_int_state),         INTENT(inout) :: intp_2d_coeff

    REAL(wp), ALLOCATABLE :: prime_edge_length( :, : )
    REAL(wp), ALLOCATABLE :: dual_edge_length ( :, : )
    !     REAL(wp), ALLOCATABLE :: cell_area( :, : )
    !     REAL(wp), ALLOCATABLE :: dual_cell_area ( :, : )

    TYPE(t_subset_range), POINTER :: owned_edges         ! these are the owned entities
    TYPE(t_subset_range), POINTER :: owned_cells         ! these are the owned entities
    TYPE(t_subset_range), POINTER :: owned_verts         ! these are the owned entities
    TYPE(t_cartesian_coordinates) :: vertex_position, cell_center, edge_center
    TYPE(t_cartesian_coordinates) :: dist_vector
    TYPE(t_cartesian_coordinates), POINTER :: dual_edge_middle(:,:)

    TYPE(t_cartesian_coordinates) :: coriolis_cartesian_coordinates
    TYPE(t_geographical_coordinates) :: coriolis_geo_coordinates, geo_coordinates
    REAL(wp) :: basin_center_lat_rad, basin_height_rad

    REAL(wp) :: norm, orientation, length
    REAL(wp) :: inverse_sphere_radius

    INTEGER :: edge_block, edge_index
    INTEGER :: cell_index, cell_block
    INTEGER :: vertex_index, vertex_block
    INTEGER :: start_index, end_index, neigbor
    INTEGER :: cell_1_index, cell_1_block, cell_2_index, cell_2_block
    INTEGER :: vertex_1_index, vertex_1_block, vertex_2_index, vertex_2_block
    !-----------------------------------------------------------------------
    !     REAL(wp) :: dist_cell2edge(nproma, patch%nblks_e,2)
    !     TYPE(t_cartesian_coordinates) :: check_v1(nproma, patch%nblks_v, 6)
    !     TYPE(t_cartesian_coordinates) :: check_v2(nproma, patch%nblks_e, 2)
    !     REAL(wp) :: max_diff, max_val
    !-----------------------------------------------------------------------
    inverse_sphere_radius = 1.0_wp / grid_sphere_radius

    owned_edges => patch%edges%owned
    owned_cells => patch%cells%owned
    owned_verts => patch%verts%owned

    intp_2d_coeff%edge2vert_coeff_cc(:,:,:)%x(1) = 0.0_wp
    intp_2d_coeff%edge2vert_coeff_cc(:,:,:)%x(2) = 0.0_wp
    intp_2d_coeff%edge2vert_coeff_cc(:,:,:)%x(3) = 0.0_wp

    intp_2d_coeff%edge2vert_coeff_cc_t(:,:,:)%x(1) = 0.0_wp
    intp_2d_coeff%edge2vert_coeff_cc_t(:,:,:)%x(2) = 0.0_wp
    intp_2d_coeff%edge2vert_coeff_cc_t(:,:,:)%x(3) = 0.0_wp

    !-------------------------------------------
    ! compute some basic distances
    ! this is required if the cartesian distance is used
    ! instead of the spherical
    !
    ! computes_dist_cell2edge( patch, intp_2D_coeff)
    !
    ALLOCATE( prime_edge_length( nproma, patch%nblks_e))
    ALLOCATE( dual_edge_length ( nproma, patch%nblks_e))
    !     ALLOCATE( cell_area        ( nproma, patch%nblks_c))
    !     ALLOCATE( dual_cell_area   ( nproma, patch%nblks_v))

    IF ( mid_point_dual_edge ) THEN
      dual_edge_middle => patch%edges%cartesian_dual_middle
    ELSE
      dual_edge_middle => patch%edges%cartesian_center
    ENDIF

    ! get the areas on a unit sphere
    !     cell_area(:,:)      = patch%cells%area(:,:)      * inverse_earth_radius * inverse_earth_radius
    !     dual_cell_area(:,:) = patch%verts%dual_area(:,:) * inverse_earth_radius * inverse_earth_radius

    IF (larc_length) THEN

      ! we just need to get them from the grid
      ! NOTE:  these are earth's distances, translate on a unit sphere
      intp_2d_coeff%dist_cell2edge(:,:,:) = &
        & patch%edges%edge_cell_length(:,:,:) * inverse_sphere_radius
      prime_edge_length(:,:) = &
        & patch%edges%primal_edge_length(:,:) * inverse_sphere_radius
      dual_edge_length(:,:) = &
        & patch%edges%dual_edge_length(:,:) * inverse_sphere_radius

    ELSE

      ! calcultate cartesian distance
      prime_edge_length(:,:) = 0.0_wp
      dual_edge_length(:,:) = 0.0_wp
      intp_2d_coeff%dist_cell2edge(:,:,:) =  0.0_wp

      DO edge_block = owned_edges%start_block, owned_edges%end_block
        CALL get_index_range(owned_edges, edge_block, start_index, end_index)
        DO edge_index = start_index, end_index

          !----------------------------------------
          ! calculate the cartesian edge length
          vertex_1_index = patch%edges%vertex_idx(edge_index, edge_block, 1)
          vertex_1_block = patch%edges%vertex_blk(edge_index, edge_block, 1)
          vertex_2_index = patch%edges%vertex_idx(edge_index, edge_block, 2)
          vertex_2_block = patch%edges%vertex_blk(edge_index, edge_block, 2)

          dist_vector%x = &
            & patch%verts%cartesian(vertex_1_index, vertex_1_block)%x - &
            & patch%verts%cartesian(vertex_2_index, vertex_2_block)%x

          prime_edge_length(edge_index,edge_block) = &
            & SQRT(SUM((  dist_vector%x *  dist_vector%x)))
          !----------------------------------------

          !----------------------------------------
          ! calculate the cartesian distance of the edge center to the cell center
          DO neigbor = 1,2

            intp_2d_coeff%dist_cell2edge(edge_index,edge_block,neigbor) = 0.0_wp

            cell_index = patch%edges%cell_idx(edge_index,edge_block,neigbor)
            cell_block = patch%edges%cell_blk(edge_index,edge_block,neigbor)

            IF (cell_block > 0) THEN
              dist_vector%x = &
                & patch%edges%cartesian_center(edge_index,edge_block)%x - &
                & patch%cells%cartesian_center(cell_index,cell_block)%x

              intp_2d_coeff%dist_cell2edge(edge_index,edge_block,neigbor) = &
                & SQRT(SUM((  dist_vector%x *  dist_vector%x)))
            ENDIF

          ENDDO ! neigbor = 1,2
          !----------------------------------------

          !----------------------------------------
          ! calculate the cartesian dual edge length
          cell_1_index = patch%edges%cell_idx(edge_index, edge_block, 1)
          cell_1_block = patch%edges%cell_blk(edge_index, edge_block, 1)
          cell_2_index = patch%edges%cell_idx(edge_index, edge_block, 2)
          cell_2_block = patch%edges%cell_blk(edge_index, edge_block, 2)

          IF (cell_1_block > 0 .AND. cell_2_block > 0) THEN
            dist_vector%x = &
              & patch%cells%cartesian_center(cell_1_index, cell_1_block)%x - &
              & patch%cells%cartesian_center(cell_2_index, cell_2_block)%x

            dual_edge_length(edge_index,edge_block) = &
              & SQRT(SUM((  dist_vector%x *  dist_vector%x)))
          ELSE
            dual_edge_length(edge_index,edge_block) =              &
              & intp_2d_coeff%dist_cell2edge(edge_index,edge_block,1) + &
              & intp_2d_coeff%dist_cell2edge(edge_index,edge_block,2)
          ENDIF
          !----------------------------------------

        ENDDO ! edge_index=start_index,end_index
      ENDDO ! edge_block = owned_edges%start_block, owned_edges%end_block

      ! synchronize the edge distances
      CALL sync_patch_array(sync_e, patch, intp_2d_coeff%dist_cell2edge(:,:,1))
      CALL sync_patch_array(sync_e, patch, intp_2d_coeff%dist_cell2edge(:,:,2))
      CALL sync_patch_array(sync_e, patch, prime_edge_length(:,:))
      CALL sync_patch_array(sync_e, patch, dual_edge_length(:,:))
    ENDIF
    ! distances have been computed
    !-------------------------------------------

    !-------------------------------------------
    ! compute:
    !   edge2cell_coeff_cc
    !   fixed_vol_norm
    !   variable_vol_norm
    intp_2d_coeff%edge2cell_coeff_cc(:,:,:)%x(1) = 0.0_wp
    intp_2d_coeff%edge2cell_coeff_cc(:,:,:)%x(2) = 0.0_wp
    intp_2d_coeff%edge2cell_coeff_cc(:,:,:)%x(3) = 0.0_wp
    intp_2d_coeff%fixed_vol_norm(:,:)       = 0.0_wp
    intp_2d_coeff%variable_vol_norm(:,:,:)  = 0.0_wp
    DO cell_block = owned_cells%start_block, owned_cells%end_block
      CALL get_index_range(owned_cells, cell_block, start_index, end_index)
      DO cell_index = start_index, end_index

        cell_center%x = patch%cells%cartesian_center(cell_index, cell_block)%x
        intp_2d_coeff%fixed_vol_norm(cell_index,cell_block) = 0.0_wp

        !-------------------------------
        DO neigbor=1,patch%cell_type

          intp_2d_coeff%edge2cell_coeff_cc(cell_index,cell_block,neigbor)%x = 0.0_wp
          intp_2d_coeff%variable_vol_norm(cell_index, cell_block, neigbor) =  0.0_wp

          edge_index = patch%cells%edge_idx(cell_index, cell_block, neigbor)
          edge_block = patch%cells%edge_blk(cell_index, cell_block, neigbor)

          IF (edge_block > 0 ) THEN
            ! we have an edge
            dist_vector%x = &
              & patch%edges%cartesian_center(edge_index,edge_block)%x - &
              & cell_center%x

            norm  = SQRT(SUM( dist_vector%x * dist_vector%x))

            ! compute edge2cell_coeff_cc
            intp_2d_coeff%edge2cell_coeff_cc(cell_index,cell_block,neigbor)%x =  &
              & dist_vector%x *                                             &
              & prime_edge_length(edge_index,edge_block) *                  &
              & patch%cells%edge_orientation(cell_index,cell_block,neigbor)! / &
            ! & cell_area(cell_index, cell_block)
            ! Note: here we do not divide by the cell area !

            intp_2d_coeff%fixed_vol_norm(cell_index,cell_block) = &
              & intp_2d_coeff%fixed_vol_norm(cell_index,cell_block) + &
              & 0.5_wp * norm * prime_edge_length(edge_index,edge_block)

            intp_2d_coeff%variable_vol_norm(cell_index, cell_block, neigbor) = &
              & 0.5_wp * norm * prime_edge_length(edge_index,edge_block)

          ENDIF !(edge_block > 0 )

        ENDDO !neigbor=1,patch%cell_type
        !-------------------------------

      ENDDO ! cell_index = start_index, end_index
    ENDDO !cell_block = owned_cells%start_block, owned_cells%end_block
    !-------------------
    ! sync the results
    CALL sync_patch_array(sync_c, patch, intp_2d_coeff%fixed_vol_norm(:,:))
    DO neigbor=1,patch%cell_type
      CALL sync_patch_array(sync_c, patch, intp_2d_coeff%edge2cell_coeff_cc(:,:,neigbor)%x(1))
      CALL sync_patch_array(sync_c, patch, intp_2d_coeff%edge2cell_coeff_cc(:,:,neigbor)%x(2))
      CALL sync_patch_array(sync_c, patch, intp_2d_coeff%edge2cell_coeff_cc(:,:,neigbor)%x(3))
      CALL sync_patch_array(sync_c, patch, intp_2d_coeff%variable_vol_norm(:,:,neigbor))
    ENDDO
    !-------------------

    !-------------------------------------------
    ! compute:
    !   edge2cell_coeff_cc_t
    !     intp_2D_coeff%edge2cell_coeff_cc_t(:,:,:)%x(1) = 0.0_wp
    !     intp_2D_coeff%edge2cell_coeff_cc_t(:,:,:)%x(2) = 0.0_wp
    !     intp_2D_coeff%edge2cell_coeff_cc_t(:,:,:)%x(3) = 0.0_wp
    DO edge_block = owned_edges%start_block, owned_edges%end_block
      CALL get_index_range(owned_edges, edge_block, start_index, end_index)
      DO edge_index = start_index, end_index

        intp_2d_coeff%edge2cell_coeff_cc_t(edge_index, edge_block, 2)%x = 0.0_wp
        edge_center%x = patch%edges%cartesian_center(edge_index, edge_block)%x

        DO neigbor=1,2

          intp_2d_coeff%edge2cell_coeff_cc_t(edge_index, edge_block, neigbor)%x = 0.0_wp
          cell_index = patch%edges%cell_idx(edge_index, edge_block, neigbor)
          cell_block = patch%edges%cell_blk(edge_index, edge_block, neigbor)

          IF (cell_block > 0) THEN

            dist_vector%x =  edge_center%x -                             &
              & patch%cells%cartesian_center(cell_index, cell_block)%x

            orientation = DOT_PRODUCT(dist_vector%x, &
              & patch%edges%primal_cart_normal(edge_index, edge_block)%x)
            IF (orientation < 0.0_wp) dist_vector%x = - dist_vector%x

            intp_2d_coeff%edge2cell_coeff_cc_t(edge_index, edge_block, neigbor)%x = &
              & dist_vector%x / dual_edge_length(edge_index, edge_block)

          ENDIF ! (cell_block > 0)

        ENDDO ! neigbor=1,2

      ENDDO ! edge_index = start_index, end_index
    ENDDO ! edge_block = owned_edges%start_block, owned_edges%end_block
    !-------------------
    ! sync the results
    DO neigbor=1,2
      CALL sync_patch_array(sync_e, patch, intp_2d_coeff%edge2cell_coeff_cc_t(:,:,neigbor)%x(1))
      CALL sync_patch_array(sync_e, patch, intp_2d_coeff%edge2cell_coeff_cc_t(:,:,neigbor)%x(2))
      CALL sync_patch_array(sync_e, patch, intp_2d_coeff%edge2cell_coeff_cc_t(:,:,neigbor)%x(3))
    ENDDO ! neigbor=1,2
    !   edge2cell_coeff_cc_t is computed
    !-------------------------------------------


    !-------------------------------------------
    ! compute:
    !   edge2vert_coeff_cc
    !   variable_dual_vol_norm
    DO vertex_block = owned_verts%start_block, owned_verts%end_block
      CALL get_index_range(owned_verts, vertex_block, start_index, end_index)
      DO vertex_index = start_index, end_index

        vertex_position%x = patch%verts%cartesian(vertex_index, vertex_block)%x

        DO neigbor=1, 6 ! we have to change this to accomodate the dual grid

          !           intp_2D_coeff%edge2vert_coeff_cc(vertex_index, vertex_block, neigbor)%x = 0.0_wp
          intp_2d_coeff%variable_dual_vol_norm(vertex_index, vertex_block, neigbor) = 0.0_wp

          edge_index = patch%verts%edge_idx(vertex_index, vertex_block, neigbor)
          edge_block = patch%verts%edge_blk(vertex_index, vertex_block, neigbor)

          IF (edge_block > 0) THEN
            ! we got an adjacent edge
            dist_vector%x = &
              & dual_edge_middle(edge_index, edge_block)%x - &
              & vertex_position%x


            ! the dist_vector has cartesian length
            ! if we use spherical distance we need to recalculate
            ! its length
            IF (larc_length) THEN
              length = arc_length(vertex_position, dual_edge_middle(edge_index, edge_block))
              norm = SQRT(SUM( dist_vector%x * dist_vector%x ))
              dist_vector%x = dist_vector%x * length / norm
            ELSE
              length = SQRT(SUM( dist_vector%x * dist_vector%x ))
            ENDIF

            dist_vector = vector_product(dist_vector, dual_edge_middle(edge_index, edge_block))
            orientation = DOT_PRODUCT( dist_vector%x,                         &
              & patch%edges%primal_cart_normal(edge_index, edge_block)%x)
            IF (orientation < 0) dist_vector%x = - dist_vector%x

            intp_2d_coeff%edge2vert_coeff_cc(vertex_index, vertex_block, neigbor)%x = &
              & dist_vector%x                                *                    &
              & dual_edge_length(edge_index, edge_block) !    /                    &
            !& dual_cell_area(vertex_index, vertex_block)

            intp_2d_coeff%variable_dual_vol_norm(vertex_index, vertex_block, neigbor) = &
              & 0.5_wp * dual_edge_length(edge_index, edge_block) * length

          ENDIF !(edge_block > 0) THEN

        ENDDO !neigbor=1,6

      ENDDO ! vertex_index = start_index, end_index
    ENDDO !vertex_block = owned_verts%start_block, owned_verts%end_block
    !-------------------
    ! sync the results
    DO neigbor=1,6
      CALL sync_patch_array(sync_v, patch, intp_2d_coeff%edge2vert_coeff_cc(:,:,neigbor)%x(1))
      CALL sync_patch_array(sync_v, patch, intp_2d_coeff%edge2vert_coeff_cc(:,:,neigbor)%x(2))
      CALL sync_patch_array(sync_v, patch, intp_2d_coeff%edge2vert_coeff_cc(:,:,neigbor)%x(3))
      CALL sync_patch_array(sync_v, patch, intp_2d_coeff%variable_dual_vol_norm(:,:, neigbor))
    ENDDO ! neigbor=1,6
    ! edge2vert_coeff_cc
    ! variable_dual_vol_norm
    !   are computed
    !----------------------------------------------------

    !----------------------------------------------------
    ! compute:
    !   edge2vert_coeff_cc_t
    DO edge_block = owned_edges%start_block, owned_edges%end_block
      CALL get_index_range(owned_edges, edge_block, start_index, end_index)
      DO edge_index = start_index, end_index

        edge_center%x = dual_edge_middle(edge_index, edge_block)%x

        DO neigbor=1,2

          intp_2d_coeff%edge2vert_coeff_cc_t(edge_index, edge_block, neigbor)%x = 0.0_wp

          vertex_index = patch%edges%vertex_idx(edge_index, edge_block, neigbor)
          vertex_block = patch%edges%vertex_blk(edge_index, edge_block, neigbor)

          intp_2d_coeff%edge2vert_coeff_cc_t(edge_index, edge_block, neigbor)%x =              &
            & (edge_center%x - patch%verts%cartesian(vertex_index, vertex_block)%x) * &
            & patch%edges%system_orientation(edge_index, edge_block)                / &
            & prime_edge_length(edge_index, edge_block)

        ENDDO !neigbor=1,2

      ENDDO ! edge_index = start_index, end_index
    ENDDO ! edge_block = owned_edges%start_block, owned_edges%end_block
    !-------------------
    ! sync the results
    DO neigbor=1,2
      CALL sync_patch_array(sync_e, patch, intp_2d_coeff%edge2vert_coeff_cc_t(:,:,neigbor)%x(1))
      CALL sync_patch_array(sync_e, patch, intp_2d_coeff%edge2vert_coeff_cc_t(:,:,neigbor)%x(2))
      CALL sync_patch_array(sync_e, patch, intp_2d_coeff%edge2vert_coeff_cc_t(:,:,neigbor)%x(3))
    ENDDO ! neigbor=1,2
    ! edge2vert_coeff_cc_t is computed
    !----------------------------------------------------


    !----------------------------------------------------
    ! recalculate the coriolis coefficient
    ! It is required if we use the middle of the dual_edge_length
    IF (mid_point_dual_edge) THEN

      IF (coriolis_type == full_coriolis) THEN

        DO edge_block = owned_edges%start_block, owned_edges%end_block
          CALL get_index_range(owned_edges, edge_block, start_index, end_index)
          DO edge_index = start_index, end_index

            coriolis_geo_coordinates = cc2gc(dual_edge_middle(edge_index,edge_block))
            patch%edges%f_e(edge_index,edge_block) = &
              & 2._wp * grid_angular_velocity * SIN(coriolis_geo_coordinates%lat)

          ENDDO
        ENDDO

      ELSEIF (coriolis_type == beta_plane_coriolis) THEN

        basin_center_lat_rad = basin_center_lat * deg2rad
        basin_height_rad     = basin_height_deg * deg2rad
        coriolis_geo_coordinates%lat = basin_center_lat_rad - 0.5_wp * basin_height_rad
        coriolis_geo_coordinates%lon = 0.0_wp
        coriolis_cartesian_coordinates  = gc2cc(coriolis_geo_coordinates)

        DO edge_block = owned_edges%start_block, owned_edges%end_block
          CALL get_index_range(owned_edges, edge_block, start_index, end_index)
          DO edge_index = start_index, end_index

            geo_coordinates     = cc2gc(dual_edge_middle(edge_index,edge_block))
            geo_coordinates%lon = 0.0_wp
            edge_center         = gc2cc(geo_coordinates)
            length              = grid_sphere_radius * &
              & arc_length(edge_center, coriolis_cartesian_coordinates)

            patch%edges%f_e(edge_index,edge_block) =  2.0_wp * grid_angular_velocity * &
              & ( SIN(basin_center_lat_rad) + (COS(basin_center_lat_rad) / &
              & grid_sphere_radius) * length)

          ENDDO
        ENDDO

      ENDIF !(CORIOLIS_TYPE==full_coriolis)
    ENDIF ! (MID_POINT_DUAL_EDGE)
    !-------------------
    ! sync patch%edges%f_e
    CALL sync_patch_array(sync_e, patch, patch%edges%f_e)



    !----------------------------------------------------
    DEALLOCATE( prime_edge_length)
    DEALLOCATE( dual_edge_length )
    !     DEALLOCATE( cell_area )
    !     DEALLOCATE( dual_cell_area )
    !---------------------------------------------------------

    RETURN
    !---------------------------------------------------------
    ! checks
    !
    !      !---------------------------------------------------------
    !      check_v1 = intp_2D_coeff%edge2vert_coeff_cc
    !      check_v2 = intp_2D_coeff%edge2vert_coeff_cc_t
    !      !---------------------------------------------------------
    !
    !      CALL init_scalar_product_oce( patch, intp_2D_coeff )
    !
    !      !---------------------------------------------------------
    !      max_diff = MAXVAL(ABS(intp_2D_coeff%edge2vert_coeff_cc(:,:,:)%x(1) - &
    !        &  check_v1(:,:,:)%x(1) ))
    !      max_val  =  MAXVAL(ABS( check_v1(:,:,:)%x(1)))
    !      Write(0,*) "max diff of edge2vert_coeff_cc(:,:,:,:)%x(1)=", max_diff, max_val
    !
    !      max_diff = MAXVAL(ABS(intp_2D_coeff%edge2vert_coeff_cc(:,:,:)%x(2) - &
    !        & check_v1(:,:,:)%x(2) ))
    !      max_val  =  MAXVAL(ABS( check_v1(:,:,:)%x(2)))
    !      Write(0,*) "max diff of edge2vert_coeff_cc(:,:,:,:)%x(2)=", max_diff, max_val
    !
    !      max_diff = MAXVAL(ABS(intp_2D_coeff%edge2vert_coeff_cc(:,:,:)%x(3) - &
    !        & check_v1(:,:,:)%x(3) ))
    !      max_val  =  MAXVAL(ABS( check_v1(:,:,:)%x(3)))
    !      Write(0,*) "max diff of edge2vert_coeff_cc(:,:,:,:)%x(3)=", max_diff, max_val
    !      !---------------------------------------------------------
    !
    !      max_diff = MAXVAL(ABS(intp_2D_coeff%edge2vert_coeff_cc_t(:,:,:)%x(1) - &
    !        &  check_v2(:,:,:)%x(1) ))
    !      max_val  =  MAXVAL(ABS( check_v2(:,:,:)%x(1)))
    !      Write(0,*) "max diff of edge2vert_coeff_cc_t(:,:,:,:)%x(1)=", max_diff, max_val
    !
    !      max_diff = MAXVAL(ABS(intp_2D_coeff%edge2vert_coeff_cc_t(:,:,:)%x(2) - &
    !        & check_v2(:,:,:)%x(2) ))
    !      max_val  =  MAXVAL(ABS( check_v2(:,:,:)%x(2)))
    !      Write(0,*) "max diff of edge2vert_coeff_cc_t(:,:,:,:)%x(2)=", max_diff, max_val
    !
    !      max_diff = MAXVAL(ABS(intp_2D_coeff%edge2vert_coeff_cc_t(:,:,:)%x(3) - &
    !        & check_v2(:,:,:)%x(3) ))
    !      max_val  =  MAXVAL(ABS( check_v2(:,:,:)%x(3)))
    !      Write(0,*) "max diff of edge2vert_coeff_cc_t(:,:,:,:)%x(3)=", max_diff, max_val
    !

  END SUBROUTINE par_init_scalar_product_oce
  !-------------------------------------------------------------------------


  !---------------------------------------------------------------------------
  !>
  !! Precomputes the geometrical factors used in the divergence, rotation.
  !!
  !! @par Revision History
  !!  developed by Guenther Zaengl, 2009-03-17
  !!  Modification by Almut Gassmann, 2009-12-19
  !!  - Vorticity is computed on quads in case of the hexagonal grid
  !!  Modification by Almut Gassmann, 2010-02-05
  !!  - Added feature for poor men's 3rd order advection, where a directional
  !!    laplace is needed at the edges.
  !!  Modification by Stephan Lorenz, 2010-06-02
  !!  - Storage moved from int_state into patch_oce since it is static
  !!    geometric information used in the ocean model
  !!  Modification by Peter Korn, 2010-11
  !!  - Calculation of cell area changed to achieve compatibility with
  !!    sw-model (cell area and consequently divergence different)
  !!  Modification by Stephan Lorenz, 2011-07
  !!   - 3-dim structures moved from patch_oce to hydro_ocean_base for parallelization
  !!
  SUBROUTINE init_geo_factors_oce( ptr_patch, ptr_intp )
    !
    IMPLICIT NONE
    !
    !  patch on which computation is performed
    !
    TYPE(t_patch), TARGET, INTENT(inout) :: ptr_patch
    TYPE(t_int_state),     INTENT(inout) :: ptr_intp
    !
    
    INTEGER :: jc, jb, je, jv, je1, ie
    INTEGER :: rl_start, rl_end
    INTEGER :: i_startblk, i_endblk, i_startidx, i_endidx, i_nchdom
    
    INTEGER :: ile, ibe, ilc1, ibc1, ilc2, ibc2, ifac, ic, ilnc, ibnc
    INTEGER :: ile1, ibe1,ile2,ibe2,ile3,ibe3
    INTEGER, PARAMETER :: i_cell_type = 3
    !TYPE(cartesian_coordinates)::z_pn_k,z_pn_j
    !REAL(wp) :: z_lon, z_lat, z_nu, z_nv, z_proj
    REAL(wp) :: cell_area
    
    REAL(wp) :: z_sync_c(nproma,ptr_patch%nblks_c)
    REAL(wp) :: z_sync_e(nproma,ptr_patch%nblks_e)
    REAL(wp) :: z_sync_v(nproma,ptr_patch%nblks_v)
    
    TYPE(t_subset_range), POINTER :: all_cells         ! these are the owned entities
    TYPE(t_subset_range), POINTER :: owned_verts         ! these are the owned entities
    
    CHARACTER(LEN=max_char_length), PARAMETER :: &
      & routine = ('mo_oce_state:init_geo_factors_oce')
    
    !-----------------------------------------------------------------------
    all_cells => ptr_patch%cells%ALL
    owned_verts => ptr_patch%verts%owned
    
    CALL message (TRIM(routine), 'start')
    
    i_nchdom   = MAX(1,ptr_patch%n_childdom)
    
    
!$OMP PARALLEL PRIVATE(rl_start,rl_end,i_startblk,i_endblk,ifac)
    ! a) Geometrical factor for divergence
    rl_start = 1
    rl_end = min_rlcell
    
    ! values for the blocking
    i_startblk = ptr_patch%cells%start_blk(rl_start,1)
    i_endblk   = ptr_patch%cells%end_blk(rl_end,i_nchdom)
    !
    ! loop through all patch cells (and blocks)
    !
!$OMP DO PRIVATE(jb,je,jc,i_startidx,i_endidx,ile,ibe) ICON_OMP_DEFAULT_SCHEDULE
    DO jb = all_cells%start_block, all_cells%end_block
      CALL get_index_range(all_cells, jb, i_startidx, i_endidx)
      DO jc = i_startidx, i_endidx
        
        ile1 = ptr_patch%cells%edge_idx(jc,jb,1)
        ibe1 = ptr_patch%cells%edge_blk(jc,jb,1)
        ile2 = ptr_patch%cells%edge_idx(jc,jb,2)
        ibe2 = ptr_patch%cells%edge_blk(jc,jb,2)
        ile3 = ptr_patch%cells%edge_idx(jc,jb,3)
        ibe3 = ptr_patch%cells%edge_blk(jc,jb,3)
        
        cell_area =  0.25_wp&
          & *( ptr_patch%edges%primal_edge_length(ile1,ibe1)*ptr_patch%edges%dual_edge_length(ile1,ibe1)&
          & +ptr_patch%edges%primal_edge_length(ile2,ibe2)*ptr_patch%edges%dual_edge_length(ile2,ibe2)&
          & +ptr_patch%edges%primal_edge_length(ile3,ibe3)*ptr_patch%edges%dual_edge_length(ile3,ibe3))
        
        
        DO je = 1, i_cell_type
          
          IF (je > ptr_patch%cells%num_edges(jc,jb)) CYCLE ! relevant for hexagons
          
          ile = ptr_patch%cells%edge_idx(jc,jb,je)
          ibe = ptr_patch%cells%edge_blk(jc,jb,je)
          
          ptr_intp%geofac_div(jc,je,jb) =                &
            & ptr_patch%edges%primal_edge_length(ile,ibe) * &
            & ptr_patch%cells%edge_orientation(jc,jb,je)  / &
            & ptr_patch%cells%area(jc,jb)!cell_area
          
        ENDDO !edge loop
        
      ENDDO !idx loop
      
    END DO !block loop
!$OMP END DO
    !
    ! the ptr_intp%geofac_div has been computed on all cells, so no sync is required
    !
    
    ! b) Geometrical factor for rotation
    rl_start = 1  ! #slo# changed to 1 - 2010-12-07
    rl_end = min_rlvert_int
    
    ! Vorticity should have the right sign
    ifac = 0
    SELECT CASE (i_cell_type)
    CASE (3)
      ifac = 1
    CASE (6)
      ifac = -1
    END SELECT
    
    
    ! values for the blocking
    i_startblk = ptr_patch%verts%start_blk(rl_start,1)
    i_endblk   = ptr_patch%verts%end_blk(rl_end,i_nchdom)
    !
    ! loop through all patch cells (and blocks)
    !
!$OMP DO PRIVATE(jb,je,jv,i_startidx,i_endidx,ile,ibe) ICON_OMP_DEFAULT_SCHEDULE
    DO jb = owned_verts%start_block, owned_verts%end_block
      CALL get_index_range(owned_verts, jb, i_startidx, i_endidx)
      
      DO je = 1, 9-i_cell_type
        DO jv = i_startidx, i_endidx
          
          IF (je > ptr_patch%verts%num_edges(jv,jb)) CYCLE   ! relevant for hexagons
          
          ile = ptr_patch%verts%edge_idx(jv,jb,je)
          ibe = ptr_patch%verts%edge_blk(jv,jb,je)
          
          ptr_intp%geofac_rot(jv,je,jb) =              &
            & ptr_patch%edges%dual_edge_length(ile,ibe) * &
            & ptr_patch%verts%edge_orientation(jv,jb,je)/ &
            & ptr_patch%verts%dual_area(jv,jb) * REAL(ifac,wp)
          
        ENDDO !vertex loop
      ENDDO
      
    END DO !block loop
!$OMP END DO
    !
    ! ptr_intp%geofac_rot needs to be synced
    !
    ! c) Geometrical factor for nabla2_scalar
    rl_start = 1  ! #slo# changed to 1 - 2010-12-07
    rl_end = min_rlcell_int
    
    ! values for the blocking
    i_startblk = ptr_patch%cells%start_blk(rl_start,1)
    i_endblk   = ptr_patch%cells%end_blk(rl_end,i_nchdom)
    !
    ! loop through all patch cells (and blocks)
    !
!$OMP DO PRIVATE(jb,je,jc,ic,i_startidx,i_endidx,ile,ibe,ilc1,ibc1,&
!$OMP    ilc2,ibc2,ilnc,ibnc) ICON_OMP_DEFAULT_SCHEDULE
    DO jb = i_startblk, i_endblk
      
      CALL get_indices_c(ptr_patch, jb, i_startblk, i_endblk, &
        & i_startidx, i_endidx, rl_start, rl_end)
      
      DO je = 1, i_cell_type
        DO jc = i_startidx, i_endidx
          
          ile = ptr_patch%cells%edge_idx(jc,jb,je)
          ibe = ptr_patch%cells%edge_blk(jc,jb,je)
          
          ilc1 = ptr_patch%edges%cell_idx(ile,ibe,1)
          ibc1 = ptr_patch%edges%cell_blk(ile,ibe,1)
          ilc2 = ptr_patch%edges%cell_idx(ile,ibe,2)
          ibc2 = ptr_patch%edges%cell_blk(ile,ibe,2)
          
          IF (jc == ilc1 .AND. jb == ibc1) THEN
            IF (i_cell_type == 3) THEN
              ptr_intp%geofac_n2s(jc,1,jb)     =  &
                & ptr_intp%geofac_n2s(jc,1,jb)  -  &
                & ptr_intp%geofac_div(jc,je,jb) /  &
                & ptr_patch%edges%dual_edge_length(ile,ibe)
            ELSE IF (i_cell_type == 6) THEN
              ptr_intp%geofac_n2s(jc,1,jb)       =  &
                & ptr_intp%geofac_n2s(jc,1,jb)  -  &
                & ptr_intp%geofac_div(jc,je,jb) /  &
                & ptr_patch%edges%dual_edge_length(ile,ibe)*  &
                & ptr_patch%edges%system_orientation(ile,ibe)
            ENDIF
          ELSE IF (jc == ilc2 .AND. jb == ibc2) THEN
            IF (i_cell_type == 3) THEN
              ptr_intp%geofac_n2s(jc,1,jb)       =  &
                & ptr_intp%geofac_n2s(jc,1,jb)  +  &
                & ptr_intp%geofac_div(jc,je,jb) /  &
                & ptr_patch%edges%dual_edge_length(ile,ibe)
            ELSE IF (i_cell_type == 6) THEN
              ptr_intp%geofac_n2s(jc,1,jb)       =  &
                & ptr_intp%geofac_n2s(jc,1,jb)  +  &
                & ptr_intp%geofac_div(jc,je,jb) /  &
                & ptr_patch%edges%dual_edge_length(ile,ibe)*  &
                & ptr_patch%edges%system_orientation(ile,ibe)
            ENDIF
          ENDIF
          DO ic = 1, i_cell_type
            ilnc = ptr_patch%cells%neighbor_idx(jc,jb,ic)
            ibnc = ptr_patch%cells%neighbor_blk(jc,jb,ic)
            IF (ilnc == ilc1 .AND. ibnc == ibc1) THEN
              IF (i_cell_type == 3) THEN
                ptr_intp%geofac_n2s(jc,ic+1,jb)     = &
                  & ptr_intp%geofac_n2s(jc,ic+1,jb)- &
                  & ptr_intp%geofac_div(jc,je,jb)  / &
                  & ptr_patch%edges%dual_edge_length(ile,ibe)
              ELSE IF (i_cell_type == 6) THEN
                ptr_intp%geofac_n2s(jc,ic+1,jb)     = &
                  & ptr_intp%geofac_n2s(jc,ic+1,jb)- &
                  & ptr_intp%geofac_div(jc,je,jb)  / &
                  & ptr_patch%edges%dual_edge_length(ile,ibe) * &
                  & ptr_patch%edges%system_orientation(ile,ibe)
              ENDIF
            ELSE IF (ilnc == ilc2 .AND. ibnc == ibc2) THEN
              IF (i_cell_type == 3) THEN
                ptr_intp%geofac_n2s(jc,ic+1,jb)     = &
                  & ptr_intp%geofac_n2s(jc,ic+1,jb)+ &
                  & ptr_intp%geofac_div(jc,je,jb)  / &
                  & ptr_patch%edges%dual_edge_length(ile,ibe)
              ELSE IF (i_cell_type == 6) THEN
                ptr_intp%geofac_n2s(jc,ic+1,jb)     = &
                  & ptr_intp%geofac_n2s(jc,ic+1,jb)+ &
                  & ptr_intp%geofac_div(jc,je,jb)  / &
                  & ptr_patch%edges%dual_edge_length(ile,ibe) * &
                  & ptr_patch%edges%system_orientation(ile,ibe)
              ENDIF
            ENDIF
          ENDDO
          
          ! To ensure that dummy edges have a factor of 0:
          IF (je > ptr_patch%cells%num_edges(jc,jb)) THEN
            ptr_intp%geofac_n2s(jc,je+1,jb) = 0._wp
          ENDIF
          
        ENDDO !cell loop
      ENDDO
      
    END DO !block loop
!$OMP END DO
    
    ! d) Geometrical factor for quad-cell divergence (triangles only)
    IF (i_cell_type == 3) THEN
      
      rl_start = 1  ! #slo# changed to 1 - 2010-12-07
      rl_end = min_rledge_int
      
      ! values for the blocking
      i_startblk = ptr_patch%edges%start_blk(rl_start,1)
      i_endblk   = ptr_patch%edges%end_blk(rl_end,i_nchdom)
      
!$OMP DO PRIVATE(jb,je,je1,i_startidx,i_endidx,ile,ibe) ICON_OMP_DEFAULT_SCHEDULE
      DO jb = i_startblk, i_endblk
        
        CALL get_indices_e(ptr_patch, jb, i_startblk, i_endblk, &
          & i_startidx, i_endidx, rl_start, rl_end)
        
        DO je1 = 1, 4
          DO je = i_startidx, i_endidx
            
            ile = ptr_patch%edges%quad_idx(je,jb,je1)
            ibe = ptr_patch%edges%quad_blk(je,jb,je1)
            
            ptr_intp%geofac_qdiv(je,je1,jb) =               &
              & ptr_patch%edges%primal_edge_length(ile,ibe) *  &
              & ptr_patch%edges%quad_orientation(je,jb,je1) /  &
              & ptr_patch%edges%quad_area(je,jb)
            
          ENDDO !edge loop
        ENDDO
        
      END DO !block loop
!$OMP END DO
      
    ENDIF
    
    ! f) compute inverse dual edge length (used in math_operators for the ocean)
    
    rl_start = 1  ! #slo# changed to 1 - 2010-12-07
    rl_end = min_rledge_int
    
    ! Second step: computed projected orientation vectors and related information
    i_startblk = ptr_patch%edges%start_blk(rl_start,1)
    i_endblk   = ptr_patch%edges%end_blk(rl_end,i_nchdom)
    !
    ! loop through all patch edges
    !
!$OMP DO PRIVATE(jb,i_startidx,i_endidx,je) ICON_OMP_DEFAULT_SCHEDULE
    DO jb = i_startblk, i_endblk
      
      CALL get_indices_e(ptr_patch, jb, i_startblk, i_endblk, &
        & i_startidx, i_endidx, rl_start, rl_end)
      
      DO je =  i_startidx, i_endidx
        
        ! compute inverse dual edge length (undefined for refin_ctrl=1)
        
        ptr_patch%edges%inv_dual_edge_length(je,jb) = &
          & 1._wp/ptr_patch%edges%dual_edge_length(je,jb)
        
      ENDDO
      
    END DO !block loop
!$OMP END DO NOWAIT
    
!$OMP END PARALLEL
    
    ! synchronize all elements of ptr_intp:
    
    DO ie = 1, i_cell_type
      
      z_sync_c(:,:) = ptr_intp%geofac_n2s(:,ie,:)
      CALL sync_patch_array(sync_c, ptr_patch, z_sync_c(:,:))
      ptr_intp%geofac_n2s(:,ie,:) = z_sync_c(:,:)
      
    END DO
    
    DO ie = 1, 4
      
      z_sync_e(:,:) = ptr_intp%geofac_qdiv(:,ie,:)
      CALL sync_patch_array(sync_e, ptr_patch, z_sync_e(:,:))
      ptr_intp%geofac_qdiv(:,ie,:) = z_sync_e(:,:)
      
    END DO
    
    CALL sync_patch_array(sync_e, ptr_patch, ptr_patch%edges%inv_dual_edge_length(:,:))
    
    DO ie = 1, 9-i_cell_type
      
      z_sync_v(:,:) = ptr_intp%geofac_rot(:,ie,:)
      CALL sync_patch_array(sync_v, ptr_patch, z_sync_v(:,:))
      ptr_intp%geofac_rot(:,ie,:) = z_sync_v(:,:)
      
    END DO
    
    CALL message (TRIM(routine), 'end')
    
  END SUBROUTINE init_geo_factors_oce
  !---------------------------------------------------------------------------


END MODULE mo_ocean_interpolation_coeffs
