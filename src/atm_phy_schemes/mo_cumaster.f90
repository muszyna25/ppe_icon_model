! $RCSfile$
! $Revision$ $Date$

!>
!! <Short description of module for listings and indices>
!! Description:
!!**** *CUMASTR*  MASTER ROUTINE FOR CUMULUS MASSFLUX-SCHEME
!!
!!  @author  M.TIEDTKE      E.C.M.W.F.     1986/1987/1989
!!  @author   D.GREGORY      E.C.M.W.F.     1996
!!  @author   P.BECHTOLD     E.C.M.W.F.     2005/2007
!!
!!     PURPOSE
!!     -------

!!          THIS ROUTINE COMPUTES THE PHYSICAL TENDENCIES OF THE
!!     PROGNOSTIC VARIABLES T,Q,U, V AND TRACERS DUE TO CONVECTIVE PROCESSES.
!!     PROCESSES CONSIDERED ARE: CONVECTIVE FLUXES, FORMATION OF
!!     PRECIPITATION, EVAPORATION OF FALLING RAIN BELOW CLOUD BASE,
!!     SATURATED CUMULUS DOWNDRAFTS.


!!     THE ROUTINE TAKES ITS INPUT FROM THE LONG-TERM STORAGE
!!     T,Q,U,V,PHI AND P AND MOISTURE TENDENCIES.
!!     IT RETURNS ITS OUTPUT TO THE SAME SPACE
!!      1.MODIFIED TENDENCIES OF MODEL VARIABLES
!!      2.RATES OF CONVECTIVE PRECIPITATION
!!        (USED IN SUBROUTINE SURF)
!!      3.CLOUD BASE, CLOUD TOP AND PRECIP FOR RADIATION
!!        (USED IN SUBROUTINE CLOUD)

!!     METHOD
!!     -------

!!     PARAMETERIZATION IS DONE USING A MASSFLUX-SCHEME.
!!        (1) DEFINE CONSTANTS AND PARAMETERS
!!        (2) SPECIFY VALUES (T,Q,QS...) AT HALF LEVELS AND
!!            INITIALIZE UPDRAFT- AND DOWNDRAFT-VALUES IN 'CUINI'
!!        (3) CALCULATE CLOUD BASE IN 'CUBASE'
!!            AND SPECIFY CLOUD BASE MASSFLUX FROM PBL MOISTURE BUDGET
!!        (4) DO CLOUD ASCENT IN 'CUASC' IN ABSENCE OF DOWNDRAFTS
!!        (5) DO DOWNDRAFT CALCULATIONS:
!!              (A) DETERMINE VALUES AT LFS IN 'CUDLFS'
!!              (B) DETERMINE MOIST DESCENT IN 'CUDDRAF'
!!              (C) RECALCULATE CLOUD BASE MASSFLUX CONSIDERING THE
!!                  EFFECT OF CU-DOWNDRAFTS
!!        (6) DO FINAL CLOUD ASCENT IN 'CUASC'
!!        (7) DO FINAL ADJUSMENTS TO CONVECTIVE FLUXES IN 'CUFLX',
!!            DO EVAPORATION IN SUBCLOUD LAYER
!!        (8) CALCULATE INCREMENTS OF T AND Q IN 'CUDTDQ'
!!        (9) CALCULATE INCREMENTS OF U AND V IN 'CUDUDV'


!!    *CONVGUST* Calculation of near-surface gusts generated by convection
!!           + adapted from the GME code

!! @par Revision History
!! Initial implementation into GME/ICON  by Kristina Froehlich, DWD (2010-05-26)
!! Added calclation of convective gusts  by Helmut Frank, DWD (2013-03-13)
!!
!!
!! @par Copyright and License
!!
!! This code is subject to the DWD and MPI-M-Software-License-Agreement in
!! its most recent form.
!! Please see the file LICENSE in the root of the source tree for this code.
!! Where software is supplied by third parties, it is indicated in the
!! headers of the routines.
!!
MODULE mo_cumaster
  
#ifdef __ICON__
  USE mo_kind   ,ONLY: JPRB=>wp     , &
    &                  jpim=>i4
#endif

#ifdef __GME__
!  USE parkind1  ,ONLY : jpim     ,jprb
  USE gme_data_parameters, ONLY: JPRB =>ireals, JPIM => iintegers
#endif
  
  
!  USE yomhook   ,ONLY : lhook,   dr_hook
  !KF
  USE mo_cuparameters , ONLY :                                   &
    & rtwat                                                     ,&
    & lmfdd    ,lmfdudv                                         ,&
    & rdepths ,lmfscv  ,lmfpen   ,lmfit                         ,&
    & rmflic  ,rmflia  ,rmfsoluv                                ,&
    & ruvper    ,rmfsoltq,rmfsolct,rmfcmin  ,lmfsmooth,lmfwstar ,&
    & lmftrac   ,   LMFUVDIS                                    ,&
    & rg       ,rd      ,rcpd  ,retv , rlvtt                    ,&
    & lhook,   dr_hook, icapdcycl
  
  
  USE mo_adjust,      ONLY: satur
  USE mo_cufunctions, ONLY: foelhmcu, foealfa
  USE mo_cuinit,      ONLY: cuinin, cubasen
  USE mo_cuascn,      ONLY: cuascn
  USE mo_cudescn,     ONLY: cudlfsn, cuddrafn
  USE mo_cuflxtends,  ONLY: cuflxn, cudtdqn,cududv,cuctracer
  USE mo_nwp_parameters,  ONLY: t_phy_params
  USE mo_fortran_tools,   ONLY: t_ptr_tracer

  IMPLICIT NONE

  PRIVATE


  PUBLIC :: cumastrn

CONTAINS

  !
SUBROUTINE cumastrn &
 & (  kidia,    kfdia,    klon,     ktdia,    klev,&
 & ldland, ldlake, ptsphy, phy_params, capdcfac, &
 & paer_ss,                                      &
 & pten,     pqen,     puen,     pven, plitot,   &
 & pvervel,  pqhfl,    pahfs,                    &
 & pap,      paph,     pgeo,     pgeoh,          &
 & zdph,               zdgeoh,   pcloudnum,      &
 & ptent,    ptenu,    ptenv,                    &
 & ptenq,    ptenl,    pteni,                    &
 & ptens,                                        &
 & ldcum,      ktype , kcbot,    kctop,          &
!& KBOTSC,   LDSC                                &
 & LDSHCV,                                       &
 & pmfu,     pmfd,                               &
 & pmfude_rate,        pmfdde_rate,              &
 & ptu,      pqu,      plu,                      &
 & pmflxr,   pmflxs,   prain, pdtke_con,         &
 & pcape,                                        &
!DR    & pcape ,pvddraf,                               &
 & ktrac, pcen, ptenc) 

!

!
! Code Description:
!     PARAMETER     DESCRIPTION                                   UNITS
!     ---------     -----------                                   -----
!     INPUT PARAMETERS (INTEGER):

!    *KIDIA*        START POINT
!    *KFDIA*        END POINT
!    *KLON*         NUMBER OF GRID POINTS PER PACKET
!    *KTDIA*        START OF THE VERTICAL LOOP
!    *KLEV*         NUMBER OF LEVELS
!    *KTRAC*        NUMBER OF CHEMICAL TRACERS
!    *KSTEP*        CURRENT TIME STEP INDEX
!    *KSTART*       FIRST STEP OF MODEL

!     INPUT PARAMETERS (LOGICAL)

!    *LDLAND*       LAND SEA MASK (.TRUE. FOR LAND)
!    *LDLAKE*       LAKE MASK (.TRUE. FOR LAKE)

!     INPUT PARAMETERS (REAL)

!    paer_ss    monthly aerosol climatology sea salt (optical thickness)

!    *PTSPHY*       TIME STEP FOR THE PHYSICS                       S
!    *PTEN*         PROVISIONAL ENVIRONMENT TEMPERATURE (T+1)       K
!    *PQEN*         PROVISIONAL ENVIRONMENT SPEC. HUMIDITY (T+1)  KG/KG
!    *PUEN*         PROVISIONAL ENVIRONMENT U-VELOCITY (T+1)       M/S
!    *PVEN*         PROVISIONAL ENVIRONMENT V-VELOCITY (T+1)       M/S
!    *PCEN*         PROVISIONAL ENVIRONMENT TRACER CONCENTRATIONS KG/KG
!    *PLITOT*       GRID MEAN LIQUID WATER+ICE CONTENT            KG/KG
!    *PVERVEL*      VERTICAL VELOCITY                             PA/S
!    *PQSEN*        ENVIRONMENT SPEC. SATURATION HUMIDITY (T+1)   KG/KG
!    *PQHFL*        MOISTURE FLUX (EXCEPT FROM SNOW EVAP.)        KG/(SM2)
!    *PAHFS*        SENSIBLE HEAT FLUX                            W/M2
!    *PAP*          PROVISIONAL PRESSURE ON FULL LEVELS             PA
!    *PAPH*         PROVISIONAL PRESSURE ON HALF LEVELS             PA
!    *PGEO*         GEOPOTENTIAL                                  M2/S2
!    *PGEOH*        GEOPOTENTIAL ON HALF LEVELS                   M2/S2
!    *zdgeoh*       geopot thickness on half levels               m2/s2
!    *zdph*         pressure thickness on half levels              Pa
!
!    *PSSTRU*       SURFACE MOMENTUM FLUX U                - not used presently
!    *PSSTRV*       SURFACE MOMENTUM FLUX V                - not used presently

!    UPDATED PARAMETERS (REAL):

!    *PTENT*        TEMPERATURE TENDENCY                           K/S
!    *PTENQ*        MOISTURE TENDENCY                             KG/(KG S)
!    *PTENL*        LIQUID WATER TENDENCY                         KG/(KG S)
!    *PTENI*        ICE CONDENSATE TENDENCY                       KG/(KG S)
!    *PTENS*        SNOW TENDENCY                                 KG/(KG S)
!    *PTENU*        TENDENCY OF U-COMP. OF WIND                    M/S2
!    *PTENV*        TENDENCY OF V-COMP. OF WIND                    M/S2
!    *PTENC*        TENDENCY OF CHEMICAL TRACERS                   1/S

!    OUTPUT PARAMETERS (LOGICAL):

!    *LDCUM*        FLAG: .TRUE. FOR CONVECTIVE POINTS
!    *LDSC*         FLAG: .TRUE. FOR SC-POINTS

!    OUTPUT PARAMETERS (INTEGER):

!    *KTYPE*        TYPE OF CONVECTION
!                       1 = PENETRATIVE CONVECTION
!                       2 = SHALLOW CONVECTION
!                       3 = MIDLEVEL CONVECTION
!    *KCBOT*        CLOUD BASE LEVEL
!    *KCTOP*        CLOUD TOP LEVEL
!    *KBOTSC*       CLOUD BASE LEVEL FOR SC-CLOUDS

!    OUTPUT PARAMETERS (REAL):

!    *PTU*          TEMPERATURE IN UPDRAFTS                         K
!    *PQU*          SPEC. HUMIDITY IN UPDRAFTS                    KG/KG
!    *PLU*          LIQUID WATER CONTENT IN UPDRAFTS              KG/KG
!    *PLUDE*        DETRAINED LIQUID WATER                        KG/(M2*S)
!    *PENTH*        INCREMENT OF DRY STATIC ENERGY                 J/(KG*S)
!    *PMFLXR*       CONVECTIVE RAIN FLUX                          KG/(M2*S)
!    *PMFLXS*       CONVECTIVE SNOW FLUX                          KG/(M2*S)
!    *PRAIN*        TOTAL PRECIP. PRODUCED IN CONV. UPDRAFTS      KG/(M2*S)
!                   (NO EVAPORATION IN DOWNDRAFTS)
!    *PMFU*         MASSFLUX UPDRAFTS                             KG/(M2*S)
!    *PMFD*         MASSFLUX DOWNDRAFTS                           KG/(M2*S)
!    *PDTKE_CON     CONV. BUOYANT TKE-PRODUCTION AT HALF LEVELS   M2/S**3)
!    *PMFUDE_RATE*  UPDRAFT DETRAINMENT RATE                      KG/(M3*S)
!    *PMFDDE_RATE*  DOWNDRAFT DETRAINMENT RATE                    KG/(M3*S)
!    *PCAPE*        CONVECTVE AVAILABLE POTENTIAL ENERGY           J/KG
!    *PWMEAN*       VERTICALLY AVERAGED UPDRAUGHT VELOCITY         M/S
!DR    !    *pvddraf*      convective gust at surface                     M/S

!     EXTERNALS.
!     ----------

!       CUINI:  INITIALIZES VALUES AT VERTICAL GRID USED IN CU-PARAMETR.
!       CUBASE: CLOUD BASE CALCULATION FOR PENETR.AND SHALLOW CONVECTION
!       CUASC:  CLOUD ASCENT FOR ENTRAINING PLUME
!       CUDLFS: DETERMINES VALUES AT LFS FOR DOWNDRAFTS
!       CUDDRAF:DOES MOIST DESCENT FOR CUMULUS DOWNDRAFTS
!       CUFLX:  FINAL ADJUSTMENTS TO CONVECTIVE FLUXES (ALSO IN PBL)
!       CUDQDT: UPDATES TENDENCIES FOR T AND Q
!       CUDUDV: UPDATES TENDENCIES FOR U AND V

!     SWITCHES.
!     --------

!          LMFPEN=.TRUE.   PENETRATIVE CONVECTION IS SWITCHED ON
!          LMFSCV=.TRUE.   SHALLOW CONVECTION IS SWITCHED ON
!          LMFMID=.TRUE.   MIDLEVEL CONVECTION IS SWITCHED ON
!          LMFIT=.TRUE.    UPDRAUGHT ITERATION
!          LMFDD=.TRUE.    CUMULUS DOWNDRAFTS SWITCHED ON
!          LMFDUDV=.TRUE.  CUMULUS FRICTION SWITCHED ON
!          LMFTRAC=.false. TRACER TRANSPORT

!     MODEL PARAMETERS (DEFINED IN SUBROUTINE CUPARAM)
!     ------------------------------------------------
!     ENTRDD     ENTRAINMENT RATE FOR CUMULUS DOWNDRAFTS
!     RMFCMAX    MAXIMUM MASSFLUX VALUE ALLOWED FOR
!     RMFCMIN    MINIMUM MASSFLUX VALUE (FOR SAFETY)
!     RMFDEPS    FRACTIONAL MASSFLUX FOR DOWNDRAFTS AT LFS
!     RPRCON     COEFFICIENT FOR CONVERSION FROM CLOUD WATER TO RAIN

!     REFERENCE.
!     ----------

!          PAPER ON MASSFLUX SCHEME (TIEDTKE,1989)
!          DRAFT PAPER ON MASSFLUX SCHEME (NORDENG, 1995)
!          Bechtold et al. (2008 QJRMS 134,1337-1351), Rooy et al. (2012 QJRMS)  
!          Bechtold et al. (2013 JAS)

!     AUTHOR.
!     -------
!      M.TIEDTKE      E.C.M.W.F.     1986/1987/1989

!     MODIFICATIONS.
!     --------------
!      03-08-29 : Clean-up, deep/shallow switches  P.Bechtold
!      04-02-11 : Add tracer transport             P.Bechtold
!      05-02-11 : Positive scaling of total Mflux  P.Bechtold
!      M.Hamrud      01-Oct-2003 CY28 Cleaning
!      04-12-03 : Turn off shallow convection over stratocu. M.Ko"hler
!      05-06-27 : Switch off ddraught if idtop<kctop  
!                 correction for detrainment rates P.Bechtold
!      05-11-22 : Mods for coarser/finer physics D.Salmond + M.Hortal
!      06-02-11 : Enable TQ implicit               P.Bechtold
!      07-06-01 : Only single updraught call with  P.Bechtold
!                 scaling, convective turnover time
!                 scale, contain momentum computations in cumastrn
!      07-10-09 : Added KE dissipation and convective scavenging   P. Bechtold
!      12-03-02 : remove all entrainment stuff     P. Bechtold
!      04-10-12 : Add RPLRG/RPLDARE for small planet  N.Semane+P.Bechtold  
!      13-02-23 : modif diurnal cycle CAPE closure P. Bechtold
!      13-10-01 : modified option RCAPDCYCL=1 for diurnal cycle N. Semane
!----------------------------------------------------------------------

!USE PARKIND1  ,ONLY : JPIM     ,JPRB
!USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK

!USE YOMCST   , ONLY : RG       ,RD       ,RCPD     ,RETV     ,&
! & RLVTT    ,RLSTT   ,RTT
!USE YOMDYNCORE, ONLY : RPLRG, RPLDARE 
!USE YOETHF   , ONLY : R2ES     ,R3LES    ,R3IES    ,R4LES    ,&
! & R4IES    ,R5LES    ,R5IES    ,R5ALVCP  ,R5ALSCP  ,&
! & RALVDCP  ,RALSDCP  ,RTWAT    ,RTICE    ,RTICECU  ,&
! & RTWAT_RTICECU_R    ,RTWAT_RTICE_R  
!USE YOECUMF  , ONLY : LMFDD    ,LMFDUDV  ,&
! & RTAU      ,RTAU0   ,RCAPDCYCL,RDEPTHS ,LMFSCV  ,LMFPEN   ,&
! & NJKT3     ,NJKT2    ,&
! & RMFCFL    ,RMFLIC  ,RMFLIA  ,RMFSOLUV ,&
! & RUVPER    ,RMFSOLTQ,RMFSOLCT,RMFCMIN  ,LMFSMOOTH,LMFWSTAR ,&
! & LMFUVDIS  ,LMFCUCA
!USE YOEPHY   , ONLY : LMFTRAC, LMFSCAV

IMPLICIT NONE

INTEGER(KIND=jpim),INTENT(in)    :: klon
INTEGER(KIND=jpim),INTENT(in)    :: klev
INTEGER(KIND=jpim),INTENT(in)    :: kidia
INTEGER(KIND=jpim),INTENT(in)    :: kfdia
INTEGER(KIND=jpim),INTENT(in)    :: ktrac
INTEGER(KIND=jpim)               :: ktdia
LOGICAL           ,INTENT(in)    :: ldland(klon) 
LOGICAL           ,INTENT(in)    :: ldlake(klon)
REAL(KIND=jprb)   ,INTENT(in)    :: ptsphy
TYPE(t_phy_params),INTENT(in)    :: phy_params
REAL(KIND=jprb)   ,INTENT(in)    :: capdcfac(klon)
!KF
REAL(KIND=jprb)   ,INTENT(in),OPTIONAL :: paer_ss(klon)
!KF
REAL(KIND=jprb)   ,INTENT(inout) :: pten(klon,klev) 
REAL(KIND=jprb)   ,INTENT(inout) :: pqen(klon,klev) 
REAL(KIND=jprb)   ,INTENT(in)    :: puen(klon,klev) 
REAL(KIND=jprb)   ,INTENT(in)    :: pven(klon,klev) 
REAL(KIND=jprb)   ,INTENT(in)    :: plitot(klon,klev) 
REAL(KIND=jprb)   ,INTENT(in)    :: pvervel(klon,klev) 
!REAL(KIND=JPRB)   ,INTENT(INOUT) :: PQSEN(KLON,KLEV) 
REAL(KIND=jprb)   ,INTENT(in)    :: pqhfl(klon,klev+1) 
REAL(KIND=jprb)   ,INTENT(in)    :: pahfs(klon,klev+1) 
REAL(KIND=jprb)   ,INTENT(in)    :: pap(klon,klev) 
REAL(KIND=jprb)   ,INTENT(in)    :: paph(klon,klev+1)
REAL(KIND=jprb)   ,INTENT(in)    :: zdph(klon,klev)
REAL(KIND=jprb)   ,INTENT(in)    :: pgeo(klon,klev) 
REAL(KIND=jprb)   ,INTENT(in)    :: pgeoh(klon,klev+1) 
REAL(KIND=jprb)   ,INTENT(in)    :: zdgeoh(klon,klev)
REAL(KIND=jprb)   ,INTENT(in)    :: pcloudnum(klon)
! with ktrac=0 this has zero size
!REAL(KIND=jprb)   ,INTENT(in), OPTIONAL :: pcen(klon,klev,ktrac)
TYPE(t_ptr_tracer),INTENT(in), OPTIONAL :: pcen(ktrac)
REAL(KIND=jprb)   ,INTENT(inout) :: ptent(klon,klev) 
REAL(KIND=jprb)   ,INTENT(inout) :: ptenq(klon,klev) 
REAL(KIND=jprb)   ,INTENT(inout)   :: ptenl(klon,klev)
REAL(KIND=jprb)   ,INTENT(inout)   :: pteni(klon,klev)
REAL(KIND=jprb)   ,INTENT(out), OPTIONAL :: ptens(klon,klev)
REAL(KIND=jprb)   ,INTENT(inout) :: ptenu(klon,klev) 
REAL(KIND=jprb)   ,INTENT(inout) :: ptenv(klon,klev) 
! with ktrac=0 this has zero size
!     REAL(KIND=jprb)   ,INTENT(inout), OPTIONAL :: ptenc(klon,klev,ktrac)
TYPE(t_ptr_tracer)   ,INTENT(inout), OPTIONAL :: ptenc(ktrac)
LOGICAL           ,INTENT(inout) :: ldcum(klon)
INTEGER(KIND=jpim),INTENT(inout) :: ktype(klon)
INTEGER(KIND=jpim),INTENT(inout) :: kcbot(klon)
INTEGER(KIND=jpim),INTENT(inout) :: kctop(klon)
!INTEGER(KIND=JPIM),INTENT(OUT)   :: KBOTSC(KLON)
!LOGICAL           ,INTENT(OUT)   :: LDSC(KLON)
LOGICAL           ,INTENT(IN)    :: LDSHCV(KLON) 
REAL(KIND=jprb)   ,INTENT(inout) :: ptu(klon,klev) 
REAL(KIND=jprb)   ,INTENT(inout) :: pqu(klon,klev) 
REAL(KIND=jprb)   ,INTENT(inout) :: plu(klon,klev) 
!REAL(KIND=JPRB)   ,INTENT(INOUT) :: PLUDE(KLON,KLEV)
!REAL(KIND=JPRB)   ,INTENT(OUT)   :: PENTH(KLON,KLEV) 
REAL(KIND=jprb)   ,INTENT(inout) :: pmflxr(klon,klev+1) 
REAL(KIND=jprb)   ,INTENT(inout) :: pmflxs(klon,klev+1) 
REAL(KIND=jprb)   ,INTENT(out)   :: pdtke_con(klon,klev+1)
REAL(KIND=jprb)   ,INTENT(out)   :: prain(klon) 
REAL(KIND=jprb)   ,INTENT(inout) :: pmfu(klon,klev)
REAL(KIND=jprb)   ,INTENT(inout) :: pmfd(klon,klev)
REAL(KIND=jprb)   ,INTENT(inout) :: pmfude_rate(klon,klev)
REAL(KIND=jprb)   ,INTENT(inout) :: pmfdde_rate(klon,klev)
REAL(KIND=jprb)   ,INTENT(out)   :: pcape(klon) 
!REAL(KIND=JPRB)   ,INTENT(OUT)   :: PWMEAN(KLON)

!DR    REAL(KIND=jprb)   ,INTENT(out)   :: pvddraf(klon)

!*UPG change to operations
REAL(KIND=jprb) :: pwmean(klon)
REAL(KIND=jprb) :: plude(klon,klev) ! only local variable
REAL(KIND=jprb) :: penth(klon,klev) ! only local variable
REAL(KIND=jprb) :: pqsen(klon,klev) ! only local variable
!*UPG

REAL(KIND=jprb) :: ztenh(klon,klev),       zqenh(klon,klev),&
  & zqsenh(klon,klev),&
  & ztd(klon,klev),         zqd(klon,klev),&
  & zmfus(klon,klev),       zmfds(klon,klev),&
  & zmfuq(klon,klev),       zmfdq(klon,klev),&
  & zdmfup(klon,klev),      zdmfdp(klon,klev),&
  & zmful(klon,klev),       zrfl(klon),&
  & zuu(klon,klev),         zvu(klon,klev),&
  & zud(klon,klev),         zvd(klon,klev),&
  & zkineu(klon,klev),      zkined(klon,klev), &
  & zvbuo(klon)      
REAL(KIND=jprb) :: &
  & zmfub(klon),            zmfub1(klon),  zkhvfl(klon),&
  & zdqcv(klon)
REAL(KIND=jprb) :: zdpmel(klon,klev),zlglac(klon,klev)
REAL(KIND=jprb) :: zdhpbl(klon),     zwubase(klon)

REAL(KIND=jprb) :: zdmfen(klon,klev),zdmfde(klon,klev)

INTEGER(KIND=jpim) ::  ilab(klon,klev), idtop(klon), ictop0(klon), ilwmin(klon)
INTEGER(KIND=jpim) ::  idpl(klon) ! departure level for convection
REAL(KIND=jprb) ::     zcape(klon), zheat(klon), zcappbl(klon), zcapdcycl(klon)
LOGICAL ::             llddraf(klon), llddraf3(klon), lldcum(klon)
LOGICAL ::             llo1, llo2(klon)

INTEGER(KIND=jpim) :: ikb, ikd, itopm2, jk, ik, jl

REAL(KIND=jprb) ::   zcons2, zcons, zdh,&
  & zdqmin, zdz, zeps, zfac, &
  & zmfmax, zpbmpt, zqumqe, zro, zmfa, zerate, zderate, zorcpd, zrdocpd,&
  & ZDUTEN, ZDVTEN, ZTDIS,&
  & zalv, zsfl(klon)

REAL(KIND=jprb) :: ztau(klon), ztaupbl(klon)  ! adjustment time

! scaling factor for momentum and tracer massflux
REAL(KIND=jprb) :: zmfs(klon),  zmfuus(klon,klev), zmfdus(klon,klev) ,&
  & zmfudr(klon,klev), zmfddr(klon,klev) ,&
  & ZTENU(KLON,KLEV),  ZTENV(KLON,KLEV)  ,&
  & zmfuub(klon), zmfuvb(klon),&
  & ZUV2(KLON,KLEV), ZSUM12(KLON), ZSUM22(KLON),&
  & zmf_shal(klon)
    
!   parameters to calculate near-surface gusts produced by convection
REAL(KIND=jprb), PARAMETER :: conv_gust_buoy = 0.2_jprb
REAL(KIND=jprb), PARAMETER :: conv_gust_v    = 0.0_jprb
REAL(KIND=jprb), PARAMETER :: conv_gust_max  = 50.0_jprb ! max. speed of conv. gusts

REAL(KIND=jprb) :: zhook_handle
REAL(KIND=jprb) :: rtice2, rtmix

! total convective flux density or dry static energy and vater vapour
REAL(KIND=jprb) :: zcvfl_s, zcvfl_q

!*UPG change to operations
!    LOCALS FOR CONSERVATION CHECK
LOGICAL :: llconscheck=.FALSE.
INTEGER(KIND=jpim) :: jn
REAL(KIND=jprb), DIMENSION(:,:), ALLOCATABLE :: ztent, ztenq, zsumc
REAL(KIND=jprb), DIMENSION(:,:,:), ALLOCATABLE :: ztenc

! CAPE threshold for applying ad-hoc fixes for numerical stability
REAL(KIND=jprb), PARAMETER :: zcapethresh = 7000._jprb

!#include "cuascn.intfb.h"
!#include "cubasen.intfb.h"
!#include "cuddrafn.intfb.h"
!#include "cudlfsn.intfb.h"
!#include "cudtdqn.intfb.h"
!#include "cududv.intfb.h"
!#include "cuflxn.intfb.h"
!#include "cuinin.intfb.h"
!#include "cuctracer.intfb.h"

!#include "fcttre.func.h"

!---------------------------------------------------------------------
!*UPG Change to operations call SATUR routine here

!     0.           Compute Saturation specific humidity
!                  ------------------------------------
!DR    pvddraf(:) = 0.0_jprb ! in case that it is not actually calculated !
ldcum(:)=.FALSE.
pqsen(:,:)=pqen(:,:)

CALL satur (kidia, kfdia, klon, phy_params%kcon2, klev,&
  & pap,    pten, pqen, pqsen, 1  )


!*UPG
!---------------------------------------------------------------------

!     1.           SPECIFY CONSTANTS AND PARAMETERS
!                  --------------------------------

IF (lhook) CALL dr_hook('CUMASTRN',0,zhook_handle)
zcons2=phy_params%mfcfl/(rg*ptsphy)
zcons=1.0_JPRB/(rg*ptsphy)
zorcpd=1.0_JPRB/rcpd
zrdocpd=rd*zorcpd

!set local fields zero at begin!
!CDIR BEGIN COLLAPSE
zqsenh(:,:)=0.0_JPRB
ztenh (:,:)=0.0_JPRB
zqsenh(:,:)=0.0_JPRB
zqenh (:,:)=0.0_JPRB
ztd   (:,:)=0.0_JPRB
zqd   (:,:)=0.0_JPRB
zmfus (:,:)=0.0_JPRB
zmfds (:,:)=0.0_JPRB
zmfuq (:,:)=0.0_JPRB
zmfdq (:,:)=0.0_JPRB
zdmfup(:,:)=0.0_JPRB
zdmfdp(:,:)=0.0_JPRB
zmful (:,:)=0.0_JPRB
zuu   (:,:)=0.0_JPRB
zvu   (:,:)=0.0_JPRB
zud   (:,:)=0.0_JPRB
zvd   (:,:)=0.0_JPRB
zkineu(:,:)=0.0_JPRB
zkined(:,:)=0.0_JPRB
!    zdpmel(:,:)=0.0_JPRB
zlglac(:,:)=0.0_JPRB
zdmfen(:,:)=0.0_JPRB
zdmfde(:,:)=0.0_JPRB
ilab  (:,:)=0
zmfuus(:,:)=0.0_JPRB
zmfdus(:,:)=0.0_JPRB
zmfudr(:,:)=0.0_JPRB
zmfddr(:,:)=0.0_JPRB
zmfuub  (:)=0.0_JPRB
zmfuvb  (:)=0.0_JPRB
zmf_shal(:)=0.0_JPRB
zmfs    (:)=0.0_JPRB
zdhpbl  (:)=0.0_JPRB
zwubase (:)=0.0_JPRB
zrfl    (:)=0.0_JPRB
!    zhcbase (:)=0.0_JPRB
zmfub   (:)=0.0_JPRB
zmfub1  (:)=0.0_JPRB
zdqcv   (:)=0.0_JPRB
idtop   (:)=0
ictop0  (:)=klev ! originally 0; change needed to avoid segfaults in cuascn (but otherwise no impact on results)
ilwmin  (:)=0
idpl    (:)=0
zcape   (:)=0.0_JPRB
zheat   (:)=0.0_JPRB
pdtke_con(:,:)=0.0_JPRB
!CDIR END
    
llddraf(:)= .FALSE.
llddraf3(:)= .FALSE.
lldcum(:)= .FALSE.
llo2(:)= .FALSE.

!----------------------------------------------------------------------

!*    2.           INITIALIZE VALUES AT VERTICAL GRID POINTS IN 'CUINI'
!                  ---------------------------------------------------

! Note by GZ: For unclear reasons, cuinin and cubasen have to be called
! for all model levels to obtain correct results
CALL cuinin &
  & ( kidia,    kfdia,    klon,   ktdia,    klev, phy_params%kcon2, &
  & pten,     pqen,     pqsen,    puen,     pven,&
  & pvervel,  pgeo,     paph,&
  & ilwmin,   ilab,&
  & ztenh,    zqenh,    zqsenh,   pgeoh,&
  & ptu,      pqu,      ztd,      zqd,&
  & zuu,      zvu,      zud,      zvd,&
  & plu     )

!---------------------------------------------------------------------

!*    3.0          CLOUD BASE CALCULATIONS
!                  -----------------------

!*             (A) DETERMINE CLOUD BASE VALUES IN 'CUBASE'
!                  ---------------------------------------

CALL cubasen &
  & ( kidia,    kfdia,    klon,   ktdia,    klev,&
  & phy_params%kcon1, phy_params%kcon2,          &
  & ztenh,    zqenh,    pgeoh,    paph,&
  & pqhfl,    pahfs,    &
  & pten,     pqen,     pqsen,    pgeo,&
  & puen,     pven,&
  & ptu,      pqu,      plu,      zuu,      zvu,    zwubase,&
  & ilab,     ldcum,       kcbot,   &
!&  LDSC,  KBOTSC,
  & ictop0,   idpl,     pcape )


!*             (B) DETERMINE TOTAL MOISTURE CONVERGENCE AND
!*                 DECIDE ON TYPE OF CUMULUS CONVECTION
!*                 ONE THE BASIS OF THE DEPTH OF THE CONVECTION
!*                 DEEP IF CLOUD DEPTH > 200MB
!*                 SHALLOW IF CLOUD DEPTH <200MB
!                  -----------------------------------------

! CALCULATE COLUMN AND SUB CLOUD LAYER MOISTURE CONVERGENCE
! AND SUB CLOUD LAYER MOIST STATIC ENERGY CONVERGENCE

DO jl=kidia,kfdia
  zdqcv(jl) =0.0_JPRB
  zdhpbl(jl)=0.0_JPRB
  idtop(jl)=0
  zcappbl(jl)=0.
  zkhvfl(jl)= -pahfs(jl,klev+1) * zorcpd - retv * pten(jl,klev) * pqhfl(jl,klev+1)
ENDDO
DO jk=MAX(ktdia,phy_params%kcon2),klev
  DO jl=kidia,kfdia
    zdqcv(jl)=zdqcv(jl)+MAX(0.0_JPRB,ptenq(jl,jk))*(paph(jl,jk+1)-paph(jl,jk))
    IF(ldcum(jl).AND.jk >= kcbot(jl)) THEN
      ZDZ=(PAPH(JL,JK+1)-PAPH(JL,JK))
      zdhpbl(jl)=zdhpbl(jl)+(rlvtt*ptenq(jl,jk)+rcpd*ptent(jl,jk))*zdz
      zcappbl(jl)=zcappbl(jl)+(ptent(jl,jk)+retv*ptenq(jl,jk))*zdz
    ENDIF
  ENDDO
ENDDO


!*                 ESTIMATE CLOUD HEIGHT FOR ENTRAINMENT/DETRAINMENT
!*                 CALCULATIONS IN CUASC AND INITIAL DETERMINATION OF
!*                 CLOUD TYPE
!*                 (MAX.POSSIBLE CLOUD HEIGHT
!*                 FOR NON-ENTRAINING PLUME, FOLLOWING A.-S.,1974)
!                  -------------------------------------------------

!DIR$ IVDEP
!OCL NOVREC
    
!*                 SPECIFY INITIAL CLOUD TYPE
!*

DO jl=kidia,kfdia
  IF (ldcum(jl)) THEN
    ikb=kcbot(jl)
    itopm2=ictop0(jl)
    zpbmpt=paph(jl,ikb)-paph(jl,itopm2)
    IF (zpbmpt >= rdepths) THEN
      ktype(jl)=1
    ELSE
      ktype(jl)=2
    ENDIF
  ELSE
    ktype(jl)=0
  ENDIF
ENDDO

!*             (C) calculate initial updraught mass flux
!*                 and set lateral mixing rates
!*
!*                 for deep convection assume it is 10% of
!*                 maximum value which is determined by the
!*                 thickness of the layer and timestep
!*
!*                 for shallow convection calculated assuming
!*                 a balance of moist static energy in the
!*                 sub-cloud layer (ignores present of downdraughts)
!                  ------------------------------------------

!DIR$ IVDEP
!OCL NOVREC
IF (lmfwstar) THEN
  DO jl=kidia,kfdia
    IF (ldcum(jl)) THEN
      ikb=kcbot(jl)
      zdz=MAX(0.0_JPRB,MIN(1.5E3_JPRB,(pgeoh(jl,ikb)-pgeoh(jl,klev+1))/rg))
      zmf_shal(jl)=0.07_JPRB*(rg/pten(jl,klev)*zdz*&
        & MAX(0.0_JPRB,zkhvfl(jl)))**.3333_jprb
       ZMFMAX=(PAPH(JL,IKB)-PAPH(JL,IKB-1))*ZCONS2*RMFLIC+RMFLIA
      zmf_shal(jl)=MIN(zmf_shal(jl),zmfmax)
    ENDIF
  ENDDO
ENDIF

DO jl=kidia,kfdia
  IF (ldcum(jl)) THEN
    ikb=kcbot(jl)
     ZMFMAX=(PAPH(JL,IKB)-PAPH(JL,IKB-1))*ZCONS2*RMFLIC+RMFLIA

    ! deep convection

    IF (ktype(jl) == 1) THEN
      zmfub(jl)=zmfmax*0.1_JPRB

    ELSEIF (ktype(jl) == 2) THEN

      ! shallow convection

      zqumqe=pqu(jl,ikb)+plu(jl,ikb)-zqenh(jl,ikb)
      zdqmin=MAX(0.01_JPRB*zqenh(jl,ikb),1.e-10_JPRB)
      zdh=rcpd*(ptu(jl,ikb)-ztenh(jl,ikb))+rlvtt*zqumqe
      zdh=rg*MAX(zdh,1.e5_jprb*zdqmin)
      IF (zdhpbl(jl) > 0.0_JPRB) THEN
        zmfub(jl)=zdhpbl(jl)/zdh
        !EPS: temporary solution for explicit
        IF(ptsphy>(3.6E3_JPRB/2.0_JPRB).AND.phy_params%mfcfl==1.0_jprb) THEN
          zmfub(jl)=MIN(zmfub(jl),3._jprb*zmfmax)
        ELSE
          zmfub(jl)=MIN(zmfub(jl),zmfmax)
        ENDIF
      ELSE
        zmfub(jl)=zmfmax*0.1_JPRB
        ldcum(jl)=.FALSE.
      ENDIF
      IF(lmfwstar) zmfub(jl)=zmf_shal(jl)
    ENDIF

  ELSE

   ! no buoyancy cloud base from surface
   ! set cloud base mass flux and mixing rate
   ! to default value for safety

    zmfub(jl)=0.0_JPRB
   ENDIF

ENDDO

!-----------------------------------------------------------------------

!*    4.0          DETERMINE CLOUD ASCENT FOR ENTRAINING PLUME
!                  -------------------------------------------

!*             (A) ESTIMATE CLOUD HEIGHT FOR ENTRAINMENT/DETRAINMENT
!*                 CALCULATIONS IN CUASC (MAX.POSSIBLE CLOUD HEIGHT
!*                 FOR NON-ENTRAINING PLUME, FOLLOWING A.-S.,1974)
!                  -------------------------------------------------

! CALCULATIONS NOW DONE IS SECTION 3 ABOVE SO THAT
! INITIAL CLOUD DEPTH CAN BE USED TO SPECIFY
! THE TYPE OF CONVECTION

!*             (B) DO ASCENT IN 'CUASC'IN ABSENCE OF DOWNDRAFTS
!                  --------------------------------------------

CALL cuascn &
  & ( kidia,    kfdia,    klon,   ktdia,   klev, phy_params%mfcfl, &
  & ptsphy,&
  & paer_ss, &
  & ztenh,    zqenh,&
  & ptenq, &
  & pten,     pqen,     pqsen,    plitot,&
  & pgeo,     pgeoh,    pap,      paph,&
  & zdph,     zdgeoh,                  &
  & pvervel,  zwubase, pcloudnum,      &
  & ldland,   ldlake,  ldcum,    ktype,    ilab,&
  & ptu,      pqu,      plu,&
  & pmfu,     zmfub,    zlglac,&
  & zmfus,    zmfuq,    zmful,    plude,    zdmfup,&
  & zdmfen,   pcape,    zcapethresh, &
  & kcbot,    kctop,    ictop0,   idpl,     pmfude_rate,   zkineu,   pwmean )

!*         (C) CHECK CLOUD DEPTH AND CHANGE ENTRAINMENT RATE ACCORDINGLY
!              CALCULATE PRECIPITATION RATE (FOR DOWNDRAFT CALCULATION)
!              -----------------------------------------------------
!DIR$ IVDEP
!OCL NOVREC
DO jl=kidia,kfdia
  IF (ldcum(jl)) THEN
    ikb=kcbot(jl)
    itopm2=kctop(jl)
    zpbmpt=paph(jl,ikb)-paph(jl,itopm2)
    IF(ktype(jl) == 1.AND.zpbmpt < rdepths) ktype(jl)=2
    IF(ktype(jl) == 2.AND.zpbmpt >= rdepths) ktype(jl)=1
    ! Reset to deep convection for extreme CAPE values
    IF(pcape(jl) > zcapethresh) ktype(jl) = 1
    ictop0(jl)=kctop(jl)
  ENDIF
  zrfl(jl)=zdmfup(jl,1)
ENDDO
DO jk=ktdia+1,klev
  DO jl=kidia,kfdia
    zrfl(jl)=zrfl(jl)+zdmfup(jl,jk)
  ENDDO
ENDDO
DO jk=ktdia,klev
  DO jl=kidia,kfdia
    pmfd(jl,jk)=0.0_JPRB
    zmfds(jl,jk)=0.0_JPRB
    zmfdq(jl,jk)=0.0_JPRB
    zdmfdp(jl,jk)=0.0_JPRB
    zdpmel(jl,jk)=0.0_JPRB
  ENDDO
ENDDO
IF(LMFUVDIS) THEN
  DO JK=ktdia,KLEV
    DO JL=KIDIA,KFDIA
      ZTENU(JL,JK)=PTENU(JL,JK)
      ZTENV(JL,JK)=PTENV(JL,JK)
    ENDDO
  ENDDO
ENDIF

!-----------------------------------------------------------------------

!*    5.0          CUMULUS DOWNDRAFT CALCULATIONS
!                  ------------------------------

IF(lmfdd) THEN

!*             (A) DETERMINE LFS IN 'CUDLFS'
!                  -------------------------

  CALL cudlfsn &
    & ( kidia,    kfdia,    klon,   ktdia,    klev,&
    & kcbot,    kctop,    ldcum,&
    & ztenh,    zqenh,         &
    & pten,     pqsen,    pgeo,&
    & pgeoh,    paph,     ptu,      pqu, &
    & zmfub,    zrfl,&
    & ztd,      zqd,&
    & pmfd,     zmfds,    zmfdq,    zdmfdp,&
    & idtop,    llddraf )

!*            (B)  DETERMINE DOWNDRAFT T,Q AND FLUXES IN 'CUDDRAF'
!                  -----------------------------------------------

  CALL cuddrafn &
    & ( kidia,    kfdia,    klon,   ktdia,  klev,&
    & phy_params%kcon3, llddraf,         &
    & ztenh,    zqenh                   ,&
    & pgeo,     pgeoh,    paph,     zrfl,&
    & zdph,     zdgeoh,                  &
    & ztd,      zqd,      pmfu,&
    & pmfd,     zmfds,    zmfdq,    zdmfdp,&
    & zdmfde,   pmfdde_rate,        zkined, zvbuo )

ENDIF

!-----------------------------------------------------------------------
!*    6.0          CLOSURE
!                  ------

!*                  RECALCULATE CLOUD BASE MASSFLUX FROM A
!*                 CAPE CLOSURE FOR DEEP CONVECTION (KTYPE=1)
!*                 AND BY PBL EQUILIBRUM TAKING DOWNDRAFTS INTO
!*                 ACCOUNT FOR SHALLOW CONVECTION (KTYPE=2)          
!                  --------------------------------------------

!   DEEP CONVECTION

DO jl=kidia,kfdia
  zheat(jl)=0.0_JPRB
  zcape(jl)=0.0_JPRB
  zmfub1(jl)=zmfub(jl)
ENDDO

DO jk=ktdia,klev
  DO jl=kidia,kfdia
    llo1=ldcum(jl).AND.ktype(jl) == 1
    IF(llo1.AND.jk <= kcbot(jl).AND.jk > kctop(jl)) THEN
      ZDZ=(PGEOH(JL,JK-1)-PGEOH(JL,JK))
      zheat(jl)=zheat(jl) +&
       & (  (pten(jl,jk-1)-pten(jl,jk) + zdz*zorcpd)/ztenh(jl,jk)&
       & +  retv*(pqen(jl,jk-1)-pqen(jl,jk))  ) *&
       & (rg*(pmfu(jl,jk)+pmfd(jl,jk)))
      zdz=(paph(JL,JK)-paph(JL,JK-1))
      zcape(jl)=zcape(jl) +&
       & ((ptu(jl,jk)-ztenh(jl,jk))/ztenh(jl,jk)&
       & +retv*(pqu(jl,jk)-zqenh(jl,jk))&
       & -plu(jl,jk) ) * zdz
    ENDIF
  ENDDO
ENDDO
! time scale and subcloud contribution to CAPE to be subtracted for better diurnal cycle over land
DO jl = kidia, kfdia
  zcapdcycl(jl) = 0.0_jprb
  IF (ldcum(jl) .AND. ktype(jl) == 1 .AND. icapdcycl == 3) THEN
    ikd = idpl(jl)
    ikb = kcbot(jl)
    ik  = kctop(jl)
    ztau(jl) = (pgeoh(jl,ik)-pgeoh(jl,ikb))/((2.0_jprb+MIN(15.0_jprb,pwmean(jl)))*rg)*phy_params%tau
    llo1 = (paph(jl,klev+1)-paph(jl,ikd)) < 50.e2_jprb
    IF (llo1 .AND. ldland(jl)) THEN
      zcapdcycl(jl) = capdcfac(jl)*zcappbl(jl)*ztau(jl)*phy_params%tau0
    ENDIF
    ! Reduce adjustment time scale for extreme CAPE values
    IF (pcape(jl) > zcapethresh) ztau(jl) = ztau(jl)/phy_params%tau
  ELSE IF (ldcum(jl) .AND. ktype(jl) == 1) THEN
    ikd = idpl(jl)
    ikb = kcbot(jl)
    ik  = kctop(jl)
    ztau(jl) = (pgeoh(jl,ik)-pgeoh(jl,ikb))/((2.0_jprb+MIN(15.0_jprb,pwmean(jl)))*rg)*phy_params%tau
    llo1 = (paph(jl,klev+1)-paph(jl,ikd)) < 50.e2_jprb
    IF (llo1 .AND. ldland(jl) .AND. icapdcycl==1) THEN
       zdz = MIN(1.e4_jprb,pgeoh(jl,ikb)-pgeoh(jl,klev+1))/rg
       zcapdcycl(jl) = ztau(jl)*MAX(0.0_jprb,zkhvfl(jl))*rcpd/zdz
    ENDIF
    IF (llo1 .AND. icapdcycl==2) THEN
      IF (ldland(jl)) THEN
        zcapdcycl(jl) = zcappbl(jl)*ztau(jl)*phy_params%tau0
      ELSE
        zduten = 2.0_jprb + SQRT(0.5*(puen(jl,ikb)**2 + pven(jl,ikb)**2 + &
          puen(jl,phy_params%kcon3)**2 + pven(jl,phy_params%kcon3)**2))
        ztaupbl(jl) = MIN(1.e4_jprb, pgeoh(jl,ikb)-pgeoh(jl,klev+1))/(rg*zduten)
        zcapdcycl(jl) = zcappbl(jl)*ztaupbl(jl)
      ENDIF
    ENDIF
  ENDIF
ENDDO

do jl=kidia,kfdia
  IF(ldcum(jl).AND.ktype(jl) == 1) THEN
    ikb=kcbot(jl)
    zcape(jl)=zcape(jl)-zcapdcycl(jl)
    zcape(jl)=MAX(0.0_jprb,MIN(zcape(jl),5000.0_jprb))
    zheat(jl)=MAX(1.e-4_jprb,zheat(jl))
    ztau(jl)=MAX(720._jprb,ztau(jl))
    zmfub1(jl)=(zcape(jl)*zmfub(jl))/(zheat(jl)*ztau(jl))
    zmfub1(jl)=MAX(zmfub1(jl),0.001_jprb)
    zmfmax=(paph(jl,ikb)-paph(jl,ikb-1))*zcons2*rmflic+rmflia
    zmfub1(jl)=MIN(zmfub1(jl),zmfmax)
  ENDIF
ENDDO

!  SHALLOW CONVECTION AND MID_LEVEL

!DIR$ IVDEP
!OCL NOVREC
DO jl=kidia,kfdia
  IF ( ldcum(jl) .AND. (ktype(jl) == 2.OR. ktype(jl) == 3) ) THEN
    ikb=kcbot(jl)
    IF(pmfd(jl,ikb) < 0.0_JPRB) THEN
      zeps=-pmfd(jl,ikb)/MAX(zmfub(jl),1.e-10_JPRB)
    ELSE
      zeps=0.0_JPRB
   ENDIF
    zqumqe=pqu(jl,ikb)+plu(jl,ikb)-&
      & zeps*zqd(jl,ikb)-(1.0_JPRB-zeps)*zqenh(jl,ikb)
    zdqmin=MAX(0.01_JPRB*zqenh(jl,ikb),1.e-10_JPRB)
    ! maximum permisable value of ud base mass flux
    zmfmax=(paph(jl,ikb)-paph(jl,ikb-1))*zcons2*rmflic+rmflia

    ! shallow convection

    IF(ktype(jl) == 2) THEN
      zdh=rcpd*(ptu(jl,ikb)-zeps*ztd(jl,ikb)-&
        & (1.0_JPRB-zeps)*ztenh(jl,ikb))+rlvtt*zqumqe
      zdh=rg*MAX(zdh,1.e5_jprb*zdqmin)
      IF(zdhpbl(jl) > 0.0_JPRB) THEN
        zmfub1(jl)=zdhpbl(jl)/zdh
      ELSE
        zmfub1(jl)=zmfub(jl)
      ENDIF

      !EPS: temporary solution for explicit
      IF(ptsphy>1800._jprb.AND.phy_params%mfcfl==1.0_jprb) THEN
        zmfub1(jl)=MIN(zmfub1(jl),3._jprb*zmfmax)
      ELSE
        zmfub1(jl)=MIN(zmfub1(jl),zmfmax)
      ENDIF
      IF(lmfwstar) zmfub1(jl)=zmf_shal(jl)
    ENDIF

! mid-level convection

    IF(ktype(jl) == 3)THEN
      zmfub1(jl)=zmfub(jl)*(1.0_JPRB+zeps)
      zmfub1(jl)=MIN(zmfub1(jl),zmfmax)
    ENDIF

  ENDIF
ENDDO

! rescale DD fluxes if deep and shallow convection

DO jk=ktdia,klev
  DO jl=kidia,kfdia
    IF ( llddraf(jl) .AND.( ktype(jl) == 1.OR. ktype(jl) == 2 ) ) THEN
      zfac=zmfub1(jl)/MAX(zmfub(jl),1.e-10_JPRB)
      pmfd(jl,jk)=pmfd(jl,jk)*zfac
      zmfds(jl,jk)=zmfds(jl,jk)*zfac
      zmfdq(jl,jk)=zmfdq(jl,jk)*zfac
      zdmfdp(jl,jk)=zdmfdp(jl,jk)*zfac
!  also rescale detrainment flux for ERA pp
      pmfdde_rate(jl,jk)=pmfdde_rate(jl,jk)*zfac
    ENDIF
  ENDDO
ENDDO

IF(lmfit) THEN

  DO jk=ktdia+1,klev-1
    DO jl=kidia,kfdia
      zuu(jl,jk)=puen(jl,jk-1)
      zvu(jl,jk)=pven(jl,jk-1)
    ENDDO
  ENDDO

  ! reset updraught mass flux at cloud base

  DO jl=kidia,kfdia
    zmfub(jl)=zmfub1(jl)
  ENDDO

  !-----------------------------------------------------------------------

  !*    6.0          DETERMINE FINAL CLOUD ASCENT FOR ENTRAINING PLUME
  !*                 FOR PENETRATIVE CONVECTION (TYPE=1),
  !*                 FOR SHALLOW TO MEDIUM CONVECTION (TYPE=2)
  !*                 AND FOR MID-LEVEL CONVECTION (TYPE=3).
  !                  -------------------------------------------------

  CALL cuascn &
    & ( kidia,    kfdia,    klon,   ktdia,   klev, phy_params%mfcfl, &
    & ptsphy,&
    & paer_ss,&
    & ztenh,    zqenh,    &
    & ptenq,            &
    & pten,     pqen,     pqsen,    plitot,&
    & pgeo,     pgeoh,    pap,      paph,&
    & zdph,     zdgeoh,         &
    & pvervel,  zwubase,  pcloudnum,     &
    & ldland,   ldlake,   ldcum,    ktype,    ilab,&
    & ptu,      pqu,      plu,&
    & pmfu,     zmfub,    zlglac,&
    & zmfus,    zmfuq,    zmful,    plude,    zdmfup,&
    & zdmfen,   pcape,    zcapethresh, &
    & kcbot,    kctop,    ictop0,   idpl,     pmfude_rate,    zkineu,   pwmean )

  
  DO jl=kidia,kfdia
    IF (ldcum(jl)) THEN
      ikb=kcbot(jl)
      itopm2=kctop(jl)
      zpbmpt=paph(jl,ikb)-paph(jl,itopm2)
      IF(ktype(jl) == 1.AND.zpbmpt < rdepths) ktype(jl)=2
      IF(ktype(jl) == 2.AND.zpbmpt >= rdepths) ktype(jl)=1
      ! Reset to deep convection for extreme CAPE values
      IF(pcape(jl) > zcapethresh) ktype(jl) = 1
    ENDIF
  ENDDO

ELSE

  DO jl=kidia,kfdia
    IF(ldcum(jl)) THEN
      zmfs(jl)=zmfub1(jl)/MAX(rmfcmin,zmfub(jl))
    ENDIF
  ENDDO
  DO jk=ktdia+1,klev
    DO jl=kidia,kfdia
      IF(ldcum(jl).AND.jk>=kctop(jl)-1) THEN
        ikb=kcbot(jl)
        IF(jk>ikb) THEN
          zdz=((paph(jl,klev+1)-paph(jl,jk))/(paph(jl,klev+1)-paph(jl,ikb)))
          pmfu(jl,jk)=pmfu(jl,ikb)*zdz
        ENDIF
        zmfmax=(paph(jl,jk)-paph(jl,jk-1))*zcons2*rmflic+rmflia
        IF(pmfu(jl,jk)*zmfs(jl)>zmfmax) &
          & zmfs(jl)=MIN(zmfs(jl),zmfmax/pmfu(jl,jk))
      ENDIF
    ENDDO
  ENDDO
  DO jk=ktdia+1,klev
    DO jl=kidia,kfdia
      IF(ldcum(jl).AND.jk<=kcbot(jl).AND.jk>=kctop(jl)-1) THEN
        pmfu(jl,jk)=pmfu(jl,jk)*zmfs(jl)
        zmfus(jl,jk)=zmfus(jl,jk)*zmfs(jl)
        zmfuq(jl,jk)=zmfuq(jl,jk)*zmfs(jl)
        zmful(jl,jk)=zmful(jl,jk)*zmfs(jl)
        zdmfup(jl,jk)=zdmfup(jl,jk)*zmfs(jl)
        zdmfen(jl,jk)=zdmfen(jl,jk)*zmfs(jl)
        plude(jl,jk)=plude(jl,jk)*zmfs(jl)
        pmfude_rate(jl,jk)=pmfude_rate(jl,jk)*zmfs(jl)
      ENDIF
    ENDDO
  ENDDO
ENDIF

!-----------------------------------------------------------------------

!*    6.5          IN CASE THAT EITHER DEEP OR SHALLOW IS SWITCHED OFF
!                  RESET LDCUM TO FALSE-> FLUXES SET TO ZERO IN CUFLXN
!                  ---------------------------------------------------

!                 exclude pathological KTYPE=2 KCBOT=KCTOP=KLEV-1

DO jl=kidia,kfdia
  IF(ktype(jl)==2.AND.kcbot(jl)==kctop(jl).AND.kcbot(jl)>=klev-1) THEN
    ldcum(jl)=.FALSE.
    ktype(jl)=0
  ENDIF
ENDDO

!                  turn off shallow convection if stratocumulus PBL type
DO JL=KIDIA,KFDIA
  LLO2(JL)=.FALSE.
!xmk IF((.NOT.LDSHCV(JL) .AND. KTYPE(JL)==2)) THEN
!RN added condition: maintain shallow cumulus starting above lowest level (KLEV)
  IF((.NOT.LDSHCV(JL) .AND. KTYPE(JL)==2 .AND. IDPL(JL)==KLEV)) THEN
!xxx
    LLO2(JL)=.TRUE.
    LDCUM(JL)=.FALSE.
  ENDIF
ENDDO


IF (.NOT.lmfscv .OR. .NOT.lmfpen) THEN
  DO jl=kidia,kfdia
    llo2(jl)=.FALSE.
    IF((.NOT.lmfscv .AND. ktype(jl)==2).OR.(.NOT.lmfpen .AND. ktype(jl)==1))THEN
      llo2(jl)=.TRUE.
      ldcum(jl)=.FALSE.
    ENDIF
  ENDDO
ENDIF

!-----------------------------------------------------------------------

!*    7.0          DETERMINE FINAL CONVECTIVE FLUXES IN 'CUFLX'
!                  ------------------------------------------

!- set DD mass fluxes to zero above cloud top
!  (because of inconsistency with second updraught)

DO jl=kidia,kfdia
  IF(llddraf(jl).AND.idtop(jl)<=kctop(jl)) THEN
    idtop(jl)=kctop(jl)+1
  ENDIF
ENDDO

DO jk=ktdia+1,klev
  DO jl=kidia,kfdia
    IF (llddraf(jl)) THEN
      IF (jk<idtop(jl)) THEN
        pmfd(jl,jk)=0.0_JPRB
        zmfds(jl,jk)=0.0_JPRB
        zmfdq(jl,jk)=0.0_JPRB
        pmfdde_rate(jl,jk)=0.0_JPRB
        zdmfdp(jl,jk)=0.0_JPRB
      ELSEIF (jk==idtop(jl)) THEN
        pmfdde_rate(jl,jk)=0.0_JPRB
      ENDIF
    ENDIF
  ENDDO
ENDDO

CALL cuflxn &
  & ( kidia,    kfdia,    klon,   ktdia,    klev, phy_params%mfcfl, &
  & phy_params%rhebc_land, phy_params%rhebc_ocean, ptsphy,          &
  & pten,     pqen,     pqsen,    ztenh,    zqenh,&
  & paph,     pap,      pgeoh,    ldland,   ldlake, ldcum,&
  & kcbot,    kctop,    idtop,    itopm2,&
  & ktype,    llddraf,&
  & pmfu,     pmfd,     zmfus,    zmfds,&
  & zmfuq,    zmfdq,    zmful,    plude,&
  & zdmfup,   zdmfdp,   zdpmel,   zlglac,&
  & pmflxr,   pmflxs,   prain,    pmfdde_rate )

!- rescale DD fluxes if total mass flux becomes negative
!- correct DD detrainment rates if entrainment becomes negative
!- correct UD detrainment rates if entrainment becomes negative
!- conservation correction for precip

zmfs(:)=1.0_JPRB
!DO JK=2,KLEV-1
DO jk=ktdia+1,klev ! change for stability
  DO jl=kidia,kfdia
    IF ( llddraf(jl) .AND. jk>=idtop(jl)-1 ) THEN
      zmfmax=pmfu(jl,jk)*0.98_JPRB
      IF(pmfd(jl,jk)+zmfmax+1.e-15_JPRB<0.0_JPRB) THEN
        zmfs(jl)=MIN(zmfs(jl),-zmfmax/pmfd(jl,jk))
      ENDIF
    ENDIF
  ENDDO
ENDDO
zmfuub(:)=0.0_JPRB
DO jk=ktdia+1,klev
  DO jl=kidia,kfdia
    IF ( zmfs(jl)<1.0_JPRB .AND. jk>=idtop(jl)-1 ) THEN
      pmfd(jl,jk)=pmfd(jl,jk)*zmfs(jl)
      zmfds(jl,jk)=zmfds(jl,jk)*zmfs(jl)
      zmfdq(jl,jk)=zmfdq(jl,jk)*zmfs(jl)
      pmfdde_rate(jl,jk)=pmfdde_rate(jl,jk)*zmfs(jl)
      zmfuub(jl)=zmfuub(jl)-(1.0_JPRB-zmfs(jl))*zdmfdp(jl,jk)
      pmflxr(jl,jk+1)=pmflxr(jl,jk+1)+zmfuub(jl)
      zdmfdp(jl,jk)=zdmfdp(jl,jk)*zmfs(jl)
    ENDIF
  ! ZDMFUPC(JL,JK)=ZDMFUP(JL,JK)
  ! ZDMFDPC(JL,JK)=ZDMFDP(JL,JK)
  ENDDO
ENDDO

DO jk=ktdia+1,klev-1
  DO jl=kidia,kfdia
    IF ( llddraf(jl) .AND. jk>=idtop(jl)-1 ) THEN
      zerate=-pmfd(jl,jk)+pmfd(jl,jk-1)+pmfdde_rate(jl,jk)
      IF(zerate<0.0_JPRB) THEN
        pmfdde_rate(jl,jk)=pmfdde_rate(jl,jk)-zerate
      ENDIF
    ENDIF
    IF ( ldcum(jl) .AND. jk>=kctop(jl)-1 ) THEN
      zerate=pmfu(jl,jk)-pmfu(jl,jk+1)+pmfude_rate(jl,jk)
      IF(zerate<0.0_JPRB) THEN
        pmfude_rate(jl,jk)=pmfude_rate(jl,jk)-zerate
      ENDIF
      ! ZDMFUP(JL,JK)=ZDMFUP(JL,JK)+ZDMFDP(JL,JK)
      zdmfup(jl,jk)=pmflxr(jl,jk+1)+pmflxs(jl,jk+1)&
        & -pmflxr(jl,jk)-pmflxs(jl,jk)
      zdmfdp(jl,jk)=0.0_JPRB
    ENDIF
  ENDDO
ENDDO

! avoid negative humidities at ddraught top
DO jl=kidia,kfdia
  IF(llddraf(jl)) THEN
    jk=idtop(jl)
    ik=MIN(jk+1,klev)
    IF(zmfdq(jl,jk)<0.3_JPRB*zmfdq(jl,ik)) THEN
      IF(rmfsoltq==0.0_JPRB) THEN
        zmfdq(jl,jk)=0.3_JPRB*zmfdq(jl,ik)
      ELSE
        pmfd(jl,jk)=0.3_JPRB*pmfd(jl,ik)
      ENDIF
    ENDIF
  ENDIF
ENDDO

! avoid negative humidities near cloud top because gradient of precip flux
! and detrainment / liquid water flux too large
DO jk=ktdia+1,klev
  DO jl=kidia,kfdia
    IF(ldcum(jl).AND.jk>=kctop(jl)-1.AND.jk<kcbot(jl)) THEN
      ZDZ=PTSPHY*RG/(PAPH(JL,JK+1)-PAPH(JL,JK))
      zmfa=zmfuq(jl,jk+1)+zmfdq(jl,jk+1)-zmfuq(jl,jk)-zmfdq(jl,jk)+&
      &zmful(jl,jk+1)-zmful(jl,jk)+zdmfup(jl,jk)
      zmfa=(zmfa-plude(jl,jk))*zdz
      IF(pqen(jl,jk)+zmfa<0.0_JPRB) THEN
        plude(jl,jk)=plude(jl,jk)+2.0_JPRB*(pqen(jl,jk)+zmfa)/zdz
      ENDIF
      IF(plude(jl,jk)<0.0_JPRB) THEN
        plude(jl,jk)=0.0_JPRB
      ENDIF
    ENDIF
    IF(.NOT.LDCUM(JL)) THEN
      PMFUDE_RATE(JL,JK)=0.0_JPRB
    ENDIF
    IF(PMFD(JL,JK-1)==0.0_JPRB) THEN
      PMFDDE_RATE(JL,JK)=0.0_JPRB
    ENDIF
  ENDDO
ENDDO

!*UPG change to operations
IF ( llconscheck ) THEN
  ALLOCATE(ztent(klon,klev))
  ALLOCATE(ztenq(klon,klev))
  DO jk=ktdia+1,klev
    DO jl=kidia,kfdia
      IF ( ldcum(jl) ) THEN
        ztent(jl,jk)=ptent(jl,jk)
        ztenq(jl,jk)=ptenq(jl,jk)
        ztenu(jl,jk)=ptenu(jl,jk)
        ztenv(jl,jk)=ptenv(jl,jk)
      ENDIF
    ENDDO
  ENDDO

   IF ( lmftrac .AND. ktrac>0 ) THEN
     ALLOCATE(ztenc(klon,klev,ktrac))
     ALLOCATE(zsumc(klon,4+ktrac))
     DO jn=1,ktrac
       DO jk=ktdia+1,klev
         DO jl=kidia,kfdia
           IF ( ldcum(jl) ) THEN
!             ztenc(jl,jk,jn)=ptenc(jl,jk,jn)
             ztenc(jl,jk,jn)=ptenc(jn)%ptr(jl,jk)
           ENDIF
         ENDDO
       ENDDO
     ENDDO
   ELSE
    ALLOCATE(zsumc(klon,4))
   ENDIF
ENDIF
!*UPG change to operations

! Calculation of kinetic energy production by the convective buoyant heat flux:
DO jk=ktdia+1,klev
  DO jl=kidia,kfdia
    IF ( ldcum(jl) ) THEN
      zcvfl_s  =  zmfus (jl,jk) + zmfds (jl,jk)
      zcvfl_q  =  zmfuq (jl,jk) + zmfdq (jl,jk)

      pdtke_con(jl,jk) = MAX( 0.0_JPRB, rg*rd/paph(jl,jk) * ( (1.0_JPRB+retv*zqenh(jl,jk))*zcvfl_s/rcpd + &
                                                              retv*ztenh(jl,jk)*zcvfl_q ) )
    ENDIF
  ENDDO
ENDDO
!----------------------------------------------------------------------

!*    8.0          UPDATE TENDENCIES FOR T AND Q IN SUBROUTINE CUDTDQ
!                  --------------------------------------------------

IF( rmfsoltq>0.0_JPRB) THEN
! derive draught properties for implicit

  DO jk=klev,ktdia+1,-1
    DO jl=kidia,kfdia
      IF(ldcum(jl)) THEN
        IF(jk>kcbot(jl)) THEN
          zmfa=1.0_JPRB/MAX(1.e-15_JPRB,pmfu(jl,jk))
          pqu(jl,jk)=zqenh(jl,jk)+zmfuq(jl,jk)*zmfa
          ptu(jl,jk)=ztenh(jl,jk)+zmfus(jl,jk)*zmfa*zorcpd
          zmfus(jl,jk)=pmfu(jl,jk)*(rcpd*ptu(jl,jk)+pgeoh(jl,jk))
          zmfuq(jl,jk)=pmfu(jl,jk)*pqu(jl,jk)
          IF(llddraf(jl)) THEN
            zmfa=1.0_JPRB/MIN(-1.e-15_JPRB,pmfd(jl,jk))
            zqd(jl,jk)=zqenh(jl,jk)+zmfdq(jl,jk)*zmfa
            ztd(jl,jk)=ztenh(jl,jk)+zmfds(jl,jk)*zmfa*zorcpd
            zmfdq(jl,jk)=pmfd(jl,jk)*zqd(jl,jk)
            zmfds(jl,jk)=pmfd(jl,jk)*(rcpd*ztd(jl,jk)+pgeoh(jl,jk))
          ENDIF
        ELSEIF(jk<=kcbot(jl).AND.jk>=kctop(jl)) THEN
          zmfus(jl,jk)=pmfu(jl,jk)*(rcpd*ptu(jl,jk)+pgeoh(jl,jk))
          zmfuq(jl,jk)=pmfu(jl,jk)*pqu(jl,jk)
          zmfds(jl,jk)=pmfd(jl,jk)*(rcpd*ztd(jl,jk)+pgeoh(jl,jk))
          zmfdq(jl,jk)=pmfd(jl,jk)*zqd(jl,jk)
        ENDIF
      ENDIF
    ENDDO
  ENDDO
  
ENDIF

CALL cudtdqn &
  & ( kidia,    kfdia,    klon,   ktdia,    klev,&
  & itopm2,   ktype,    kctop,    idtop,    ldcum,    llddraf,   ptsphy,&
  & paph,     pgeoh,    pgeo,&
  & zdph,                    &
  & pten,     ztenh,    pqen,     zqenh,    pqsen,&
  & zlglac,   plude,    pmfu,     pmfd,&
  & zmfus,    zmfds,    zmfuq,    zmfdq,&
  & zmful,    zdmfup,   zdpmel,&
  & ptent,    ptenq,    penth )


!----------------------------------------------------------------------

!*    9.0          COMPUTE MOMENTUM IN UPDRAUGHT AND DOWNDRAUGHT
!                  ---------------------------------------------

IF(lmfdudv) THEN

  DO jk=klev-1,ktdia+1,-1
    ik=jk+1
    DO jl=kidia,kfdia
      IF(ldcum(jl)) THEN
        IF(jk==kcbot(jl).AND.ktype(jl)<3) THEN
          ikb=idpl(jl)
          zuu(jl,jk)=puen(jl,ikb-1)
          zvu(jl,jk)=pven(jl,ikb-1)
        ELSEIF(jk==kcbot(jl).AND.ktype(jl)==3) THEN
          zuu(jl,jk)=puen(jl,jk-1)
          zvu(jl,jk)=pven(jl,jk-1)
        ENDIF
        IF( jk<kcbot(jl).AND.jk>=kctop(jl)) THEN
          zfac=0.0_JPRB
! ** suggestion by P. Bechtold (40r3) - delete following to lines to improve momentum transport **
          IF(ktype(jl)==1.OR.ktype(jl)==3) zfac=2.0_JPRB
          IF(ktype(jl)==1.AND.jk<=kctop(jl)+2) zfac=3.0_jprb
          zerate=pmfu(jl,jk)-pmfu(jl,ik)+(1.0_JPRB+zfac)*pmfude_rate(jl,jk)
          zderate=(1.0_JPRB+zfac)*pmfude_rate(jl,jk)
          zmfa=1.0_JPRB/MAX(rmfcmin,pmfu(jl,jk))
          zuu(jl,jk)=(zuu(jl,ik)*pmfu(jl,ik)+zerate*puen(jl,jk)-zderate*zuu(jl,ik))*zmfa
          zvu(jl,jk)=(zvu(jl,ik)*pmfu(jl,ik)+zerate*pven(jl,jk)-zderate*zvu(jl,ik))*zmfa
        ENDIF
      ENDIF
    ENDDO
  ENDDO
  DO jk=ktdia+2,klev
    ik=jk-1
    DO jl=kidia,kfdia
      IF( ldcum(jl)) THEN
        IF(jk==idtop(jl)) THEN
          zud(jl,jk)=0.5_JPRB*(zuu(jl,jk)+puen(jl,ik))
          zvd(jl,jk)=0.5_JPRB*(zvu(jl,jk)+pven(jl,ik))
        ELSEIF(jk>idtop(jl)) THEN
          zerate=-pmfd(jl,jk)+pmfd(jl,ik)+pmfdde_rate(jl,jk)
          zmfa=1.0_JPRB/MIN(-rmfcmin,pmfd(jl,jk))
          zud(jl,jk)=(zud(jl,ik)*pmfd(jl,ik)-zerate*puen(jl,ik)&
            & + pmfdde_rate(jl,jk)*zud(jl,ik))*zmfa
          zvd(jl,jk)=(zvd(jl,ik)*pmfd(jl,ik)-zerate*pven(jl,ik)&
            & +pmfdde_rate(jl,jk)*zvd(jl,ik))*zmfa
        ENDIF
      ENDIF
    ENDDO
  ENDDO

!*    9.1          UPDATE TENDENCIES FOR U AND V IN SUBROUTINE CUDUDV
!                  --------------------------------------------------

! for explicit/semi-implicit rescale massfluxes for stability in Momentum
!------------------------------------------------------------------------

  zmfs(:)=1.0_JPRB
! IF(RMFSOLUV<=0.5_JPRB) THEN
  IF(rmfsoluv<=1.0_JPRB) THEN
    DO jk=ktdia+1,klev
      DO jl=kidia,kfdia
        IF(ldcum(jl).AND.jk>=kctop(jl)-1) THEN
          zmfmax=(paph(jl,jk)-paph(jl,jk-1))*zcons
          IF(pmfu(jl,jk)>zmfmax.AND.jk>=kctop(jl)) &
           & zmfs(jl)=MIN(zmfs(jl),zmfmax/pmfu(jl,jk))  
        ENDIF
      ENDDO
    ENDDO
  ENDIF
  DO jk=ktdia,klev
    DO jl=kidia,kfdia
      zmfuus(jl,jk)=pmfu(jl,jk)
      zmfdus(jl,jk)=pmfd(jl,jk)
      IF(ldcum(jl).AND.jk>=kctop(jl)-1) THEN
        zmfuus(jl,jk)=pmfu(jl,jk)*zmfs(jl)
        zmfdus(jl,jk)=pmfd(jl,jk)*zmfs(jl)
      ENDIF
    ENDDO
  ENDDO

! recompute Draught properties below for Implicit
! based on linear flux profiles

  IF(rmfsoluv>0.0_JPRB) THEN

    DO jl=kidia,kfdia
      IF(ldcum(jl)) THEN
        jk=kcbot(jl)
        ik=jk-1
        zmfuub(jl)=zmfuus(jl,jk)*(zuu(jl,jk)-puen(jl,ik))
        zmfuvb(jl)=zmfuus(jl,jk)*(zvu(jl,jk)-pven(jl,ik))
      ENDIF
    ENDDO

    DO jk=ktdia+1,klev
      ik=jk-1
      DO jl=kidia,kfdia
        IF ( ldcum(jl).AND.jk>kcbot(jl) ) THEN
          ikb=kcbot(jl)
          zdz=((paph(jl,klev+1)-paph(jl,jk))/(paph(jl,klev+1)-paph(jl,ikb)))
          IF(ktype(jl) == 3) THEN
            zdz=zdz*zdz
          ENDIF
          zmfa=1.0_JPRB/MAX(rmfcmin,zmfuus(jl,jk))
          zuu(jl,jk)=puen(jl,ik)+zmfuub(jl)*zdz*zmfa
          zvu(jl,jk)=pven(jl,ik)+zmfuvb(jl)*zdz*zmfa

          zmfdus(jl,jk)=zmfdus(jl,ikb)*zdz
          zud(jl,jk)=puen(jl,ik)+zud(jl,ikb)-puen(jl,ikb-1)
          zvd(jl,jk)=pven(jl,ik)+zvd(jl,ikb)-pven(jl,ikb-1)

!DR              ! calculate downdraft wind speed
!DR              pvddraf(jl) = zud(jl,jk)**2 + zvd(jl,jk)**2
        ENDIF
    ! add UV perturb to correct wind bias
        IF ( ldcum(jl).AND.jk>=kctop(jl) ) THEN
          zuu(jl,jk)=zuu(jl,jk)-ruvper*SIGN(1.0_JPRB,zuu(jl,jk))
          zvu(jl,jk)=zvu(jl,jk)-ruvper*SIGN(1.0_JPRB,zvu(jl,jk))
        ENDIF
      ENDDO
    ENDDO

  ENDIF

!DR We currently make use of an alternative parameterization of 
!DR convective gusts. Thus, the computation of pvddraf is deactivated
!DR!     Maximum possible convective gust
!DR      DO jl = kidia, kfdia
!DR        pvddraf(jl) = SQRT( conv_gust_buoy*MAX( zvbuo(jl),0._jprb)   &
!DR          &                + conv_gust_v*pvddraf(jl) )
!DR        pvddraf(jl) = MIN( pvddraf(jl), conv_gust_max)
!DR      ENDDO

!-------------------------------------------------------------------
! End
! Intermediate Solution for stability in EPS: 
! For original code replace line
!  &, PUEN,     PVEN,     ZMFUUS,   ZMFDUS &
!by
!  &, PUEN,     PVEN,     PMFU,     PMFD

  CALL cududv &
    & ( kidia,  kfdia,    klon,     ktdia,    klev,&
    & itopm2,   ktype,    kcbot,    kctop,    ldcum,    ptsphy,&
    & zdph,                                          &
    & paph,     puen,     pven,     zmfuus,   zmfdus,&
    & zuu,      zud,      zvu,      zvd,&
    & ptenu,    ptenv     )
  
  IF(LMFUVDIS) THEN
! add KE dissipation
    DO JL=KIDIA,KFDIA
      ZSUM12(JL)=0.0_JPRB
      ZSUM22(JL)=0.0_JPRB
    ENDDO
    DO JK=ktdia,KLEV
      DO JL=KIDIA,KFDIA
        ZUV2(JL,JK)=0.0_JPRB
        IF (LDCUM(JL).AND.JK>=KCTOP(JL)-1) THEN
          ZDZ=(PAPH(JL,JK+1)-PAPH(JL,JK))
          ZDUTEN=PTENU(JL,JK)-ZTENU(JL,JK)
          ZDVTEN=PTENV(JL,JK)-ZTENV(JL,JK)
          ZUV2(JL,JK)=SQRT(ZDUTEN**2+ZDVTEN**2)
          ZSUM22(JL)=ZSUM22(JL)+ZUV2(JL,JK)*ZDZ
          ZSUM12(JL)=ZSUM12(JL)-(PUEN(JL,JK)*ZDUTEN+PVEN(JL,JK)*ZDVTEN)*ZDZ
        ENDIF
      ENDDO
    ENDDO
    DO JK=ktdia,KLEV
      DO JL=KIDIA,KFDIA
        IF (LDCUM(JL).AND.JK>=KCTOP(JL)-1) THEN
          ZDZ=(PAPH(JL,JK+1)-PAPH(JL,JK))
          ZTDIS=ZORCPD*ZSUM12(JL)*&
               &             ZUV2(JL,JK)/MAX(1.E-15_JPRB,ZSUM22(JL))
          PTENT(JL,JK)=PTENT(JL,JK)+ZTDIS
        ENDIF
      ENDDO
    ENDDO
  ENDIF


ENDIF

!----------------------------------------------------------------------

!*   10.           IN CASE THAT EITHER DEEP OR SHALLOW IS SWITCHED OFF
!                  NEED TO SET SOME VARIABLES A POSTERIORI TO ZERO
!                  ---------------------------------------------------

IF (.NOT.lmfscv .OR. .NOT.lmfpen) THEN
  DO jk=ktdia+1,klev
    DO jl=kidia,kfdia
      IF(llo2(jl).AND.jk>=kctop(jl)-1) THEN
        ptu(jl,jk)  =pten(jl,jk)
        pqu(jl,jk)  =pqen(jl,jk)
        plu(jl,jk)  =0.0_JPRB
        penth(jl,jk) =0.0_JPRB
        pmfude_rate(jl,jk) =0.0_JPRB
        pmfdde_rate(jl,jk) =0.0_JPRB
      ENDIF
    ENDDO
  ENDDO
  DO jl=kidia,kfdia
    IF(llo2(jl)) THEN
      kctop(jl)=klev-1
      kcbot(jl)=klev-1
    ENDIF
  ENDDO
ENDIF

!----------------------------------------------------------------------

!*   11.0          CHEMICAL TRACER TRANSPORT
!                  -------------------------


IF ( lmftrac .AND. ktrac>0 ) THEN

  ! transport switched off for mid-level convection
  DO jl=kidia,kfdia
    !IF( LDCUM(JL).AND.KTYPE(JL)/=3 ) THEN
    IF( ldcum(jl).AND.ktype(jl)/=3.AND.kcbot(jl)-kctop(jl)>=1 ) THEN
      lldcum(jl)=.TRUE.
      llddraf3(jl)=llddraf(jl)
    ELSE
      lldcum(jl)=.FALSE.
      llddraf3(jl)=.FALSE.
    ENDIF
  ENDDO

  ! check and correct mass fluxes for CFL criterium

  zmfs(:)=1.0_JPRB
  IF(rmfsolct<=3.0_JPRB) THEN
    DO jk=ktdia+1,klev
      DO jl=kidia,kfdia
        IF(lldcum(jl).AND.jk>=kctop(jl)) THEN
          zmfmax=(paph(jl,jk)-paph(jl,jk-1))*0.8_JPRB*zcons
          IF(pmfu(jl,jk)>zmfmax) &
            & zmfs(jl)=MIN(zmfs(jl),zmfmax/pmfu(jl,jk))
        ENDIF
      ENDDO
    ENDDO
  ENDIF
  DO jk=ktdia,klev
    DO jl=kidia,kfdia
      IF(lldcum(jl).AND.jk>=kctop(jl)-1) THEN
        zmfuus(jl,jk)=pmfu(jl,jk)*zmfs(jl)
        zmfudr(jl,jk)=pmfude_rate(jl,jk)*zmfs(jl)
      ELSE
        zmfuus(jl,jk)=0._jprb
        zmfudr(jl,jk)=0._jprb
      ENDIF
      IF ( llddraf3(jl) .AND. jk>=idtop(jl)-1) THEN
        zmfdus(jl,jk)=pmfd(jl,jk)*zmfs(jl)
        zmfddr(jl,jk)=pmfdde_rate(jl,jk)*zmfs(jl)
      ELSE
        zmfdus(jl,jk)=0._jprb
        zmfddr(jl,jk)=0._jprb
      ENDIF
    ENDDO
  ENDDO

  IF( lmfsmooth ) THEN
    ! smmoothing of mass fluxes (gradients) at top and bottom of draughts
    DO jk=ktdia+1,klev-1
      DO jl=kidia,kfdia
        IF(llddraf3(jl).AND.zmfdus(jl,jk)<0.0_JPRB .AND. zmfdus(jl,jk+1)==0.0_JPRB) THEN
          zerate=MIN(0._jprb,zmfdus(jl,jk)-0.5_JPRB*zmfdus(jl,jk-1))
          zmfdus(jl,jk)=zmfdus(jl,jk)-zerate
          zmfddr(jl,jk)=zmfddr(jl,jk)-zerate
          zmfddr(jl,jk+1)=-zmfdus(jl,jk)
        ENDIF
        IF(lldcum(jl).AND.jk==kctop(jl)) THEN
          zerate=MAX(0.0_JPRB,zmfuus(jl,jk)-0.5_JPRB*zmfuus(jl,jk+1))
          zmfuus(jl,jk)=zmfuus(jl,jk)-zerate
          zmfudr(jl,jk)=zmfudr(jl,jk)+zerate
          zmfudr(jl,jk-1)=zmfuus(jl,jk)
        ENDIF
      ENDDO
    ENDDO
    DO jk=klev-1,ktdia+1,-1
      DO jl=kidia,kfdia
        IF(lldcum(jl)) THEN
          IF(zmfudr(jl,jk)==0.0_JPRB.AND.zmfudr(jl,jk-1)>0.0_JPRB) THEN
            zmfudr(jl,jk)=0.5_JPRB*zmfudr(jl,jk-1)
          ENDIF
        ENDIF
      ENDDO
    ENDDO
  ENDIF

  IF ( ktrac > 0 ) THEN
    CALL cuctracer &
      & ( kidia,    kfdia,    klon,  ktdia,  klev,     ktrac,&
      &   kctop,     idtop,&
      & lldcum,   llddraf3,  ptsphy,  &
      & paph,     zdph,                      &
      & zmfuus,   zmfdus,   zmfudr,   zmfddr,&
      & pcen,     ptenc     )
  ENDIF
ENDIF

!----------------------------------------------------------------------

!*   12.           PUT DETRAINMENT RATES FROM MFLX UNITS IN UNITS MFLX/M 
!                  FOR ERA40
!                  ---------------------------------------------------

DO jk=ktdia+1,klev
  DO jl=kidia,kfdia
    IF ( ldcum(jl) ) THEN
      zro=rg/(pgeoh(jl,jk)-pgeoh(jl,jk+1))  ! 1/dz
      pmfude_rate(jl,jk)=pmfude_rate(jl,jk)*zro
      pmfdde_rate(jl,jk)=pmfdde_rate(jl,jk)*zro
      IF(jk<kctop(jl)) THEN
        plu(jl,jk)=0.0_JPRB
        ptu(jl,jk)=pten(jl,jk)
        pqu(jl,jk)=pqen(jl,jk)
      ENDIF
    ENDIF
  ENDDO
ENDDO

!----------------------------------------------------------------------
!*UPG change to operations

IF ( llconscheck ) THEN

!*   13.0          CONSERVATION CHECK and CORRECTION
!                  ---------------------------------

  DO jl=kidia,kfdia
    zsumc(jl,:)=0._jprb
  ENDDO
  DO jk=klev,ktdia+1,-1
    DO jl=kidia,kfdia
      IF ( ldcum(jl) .AND. jk>=kctop(jl)-1 ) THEN
        ZDZ=(PAPH(JL,JK+1)-PAPH(JL,JK))/RG
        zsumc(jl,1)=zsumc(jl,1)+(ptenq(jl,jk)-ztenq(jl,jk))*zdz+plude(jl,jk)
        zalv=foelhmcu(pten(jl,jk))
        zsumc(jl,2)=zsumc(jl,2)+rcpd*(ptent(jl,jk)-ztent(jl,jk))*zdz-zalv*plude(jl,jk)
        zsumc(jl,3)=zsumc(jl,3)+(ptenu(jl,jk)-ztenu(jl,jk))*zdz
        zsumc(jl,4)=zsumc(jl,4)+(ptenv(jl,jk)-ztenv(jl,jk))*zdz
      ENDIF
    ENDDO
  ENDDO
  IF ( lmftrac .AND. ktrac>0 ) THEN
    DO jn=1,ktrac
      DO jk=klev,ktdia+1,-1
        DO jl=kidia,kfdia
          IF ( ldcum(jl) .AND. jk>=kctop(jl)-1) THEN
            zdz=(paph(jl,jk+1)-paph(jl,jk))/rg
       !     zsumc(jl,4+jn)=zsumc(jl,4+jn)+(ptenc(jl,jk,jn)-ztenc(jl,jk,jn))*zdz
            zsumc(jl,4+jn)=zsumc(jl,4+jn)+(ptenc(jn)%ptr(jl,jk)-ztenc(jl,jk,jn))*zdz
          ENDIF
        ENDDO
      ENDDO
    ENDDO
  ENDIF

  DO jl=kidia,kfdia
    IF ( ldcum(jl) ) THEN
      zalv=foelhmcu(pten(jl,klev))
      zsfl(jl)=pmflxr(jl,klev+1)+pmflxs(jl,klev+1)

      WRITE(61,'(i4,a9,2f15.8,i4,a9,f15.8,a10,2f15.8)')jl,' CONS q: ',&
       & -zsumc(jl,1)*zalv,zsfl(jl)*zalv,ktype(jl),&
       & ' CONS h: ',zsumc(jl,2),' CONS uv: ',zsumc(jl,3),zsumc(jl,4)

      ikb=kctop(jl)
      zdz=(paph(jl,klev+1)-paph(jl,ikb-1))/rg
      zsumc(jl,1)=(zsumc(jl,1)+zsfl(jl))/zdz
      zsumc(jl,2)=(zsumc(jl,2)-zalv*zsfl(jl))/(zdz*rcpd)
    ENDIF
  END DO

  DEALLOCATE(zsumc)
  IF ( lmftrac .AND. ktrac>0 ) THEN
    DEALLOCATE(ztenc)
  ENDIF
  DEALLOCATE(ztenq)
  DEALLOCATE(ztent)

ENDIF
!----------------------------------------------------------------------

!*    14.0         COMPUTE CONVECTIVE TENDENCIES FOR LIQUID AND SOLID
!                  CLOUD CONDENSATE, CHANGE PRECIP UNITS IN M/S (if wanted, K. Froehlich, 19.01.2009)
!                  --------------------------------------------------

IF (PRESENT(ptens)) THEN
   ! KF calculate snow tendency
  DO jk=ktdia,klev
    DO jl=kidia,kfdia
      ptenl(jl,jk)=plude(jl,jk)*rg/(paph(jl,jk+1)-paph(jl,jk))
      pteni(jl,jk)=(1.0_JPRB-foealfa(pten(jl,jk)))*ptenl(jl,jk)
      !KF 20100409
      rtice2 = rtwat-38._jprb
      rtmix  = rtwat-5._jprb
      ptens(jl,jk)= MIN(1._jprb,((MAX(rtice2,MIN(rtmix,pten(jl,jk))) &
           & - rtice2)/(rtmix-rtice2)))*pteni(jl,jk)
      pteni(jl,jk)= pteni(jl,jk)- ptens(jl,jk)
      ptenl(jl,jk)= ptenl(jl,jk)-pteni(jl,jk)-ptens(jl,jk)
      !KF
      !    PTENL(JL,JK)=PTENL(JL,JK)-PTENI(JL,JK)
      !    PMFLXR(JL,JK)=PMFLXR(JL,JK)*1.E-3
      !    PMFLXS(JL,JK)=PMFLXS(JL,JK)*1.E-3
    ENDDO
  ENDDO
ELSE
  DO jk=ktdia,klev
     DO jl=kidia,kfdia
       ptenl(jl,jk)=plude(jl,jk)*rg/(paph(jl,jk+1)-paph(jl,jk))
       pteni(jl,jk)=(1.0_JPRB-foealfa(pten(jl,jk)))*ptenl(jl,jk)
       PTENL(JL,JK)= PTENL(jl,jk)-PTENI(JL,JK)
      !PMFLXR(JL,JK)=PMFLXR(JL,JK)*1.E-3
      !PMFLXS(JL,JK)=PMFLXS(JL,JK)*1.E-3
      
    ENDDO
  ENDDO
ENDIF

!  DO JL=KIDIA,KFDIA
!   PMFLXR(JL,KLEV+1)=PMFLXR(JL,KLEV+1)*1.E-3
!   PMFLXS(JL,KLEV+1)=PMFLXS(JL,KLEV+1)*1.E-3
!  ENDDO
!----------------------------------------------------------------------
!*UPG Change to operations


IF (lhook) CALL dr_hook('CUMASTRN',1,zhook_handle)
END SUBROUTINE cumastrn

END MODULE mo_cumaster

