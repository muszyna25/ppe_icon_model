#ifndef NOMPI
!
!   AUTOGENERATED FILE, DON'T MODIFY!
!
!    Base file: ppm/dist_array.f90.m4
!
!> @file dist_array.f90
!! @brief distributed array implementation,
!! optimized for read-only access in parallel phase
!!
!!
!! @copyright Copyright  (C)  2013  Thomas Jahns <jahns@dkrz.de>
!!
!! @version 1.0
!! @author Thomas Jahns <jahns@dkrz.de>
!!         Moritz Hanke <hanke@dkrz.de>
!
! Maintainer: Thomas Jahns <jahns@dkrz.de>
! URL: https://www.dkrz.de/redmine/projects/scales-ppm
!
! Redistribution and use in source and binary forms, with or without
! modification, are  permitted provided that the following conditions are
! met:
!
! Redistributions of source code must retain the above copyright notice,
! this list of conditions and the following disclaimer.
!
! Redistributions in binary form must reproduce the above copyright
! notice, this list of conditions and the following disclaimer in the
! documentation and/or other materials provided with the distribution.
!
! Neither the name of the DKRZ GmbH nor the names of its contributors
! may be used to endorse or promote products derived from this software
! without specific prior written permission.
!
! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
! IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
! TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
! PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
! OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
! EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
! PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
! PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
! LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
! NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
!
MODULE ppm_distributed_array
  USE mo_kind, ONLY: i4, i8, sp, dp
  USE mo_mpi, ONLY: mp_i4_extent => p_int_i4_byte, &
       mp_i8_extent => p_int_i8_byte, &
       mp_l_extent => p_int_byte, &
       mp_sp_extent => p_real_sp_byte, &
       mp_dp_extent => p_real_dp_byte
  USE ppm_extents, ONLY: extent, extent_shape, extent_size, is_contained_in, &
       extent_start
  USE iso_c_binding, ONLY: c_ptr, c_f_pointer
  USE mpi
  IMPLICIT NONE
  PRIVATE
  !INCLUDE 'ftype_size.inc'
  INTEGER, PARAMETER :: max_rank = 7
  INTEGER, PARAMETER :: extent_mp = MPI_2INTEGER
  INTEGER, PARAMETER :: ppm_address_kind = mpi_address_kind
  INTEGER(ppm_address_kind), PARAMETER :: ppm_maximum_alignment = 64

  TYPE global_array_desc
    INTEGER :: a_rank
    TYPE(extent) :: rect(max_rank)
    INTEGER :: element_dt
  END TYPE global_array_desc

  INTEGER, PARAMETER :: ppm_default_comm = mpi_comm_world

  INTEGER, PARAMETER :: &
       not_exposed = 0, &
       exposed = 1

  TYPE dm_array_cache_entry
    INTEGER(mpi_address_kind) :: win_size, base
    INTEGER :: composite_dt
    INTEGER :: rank
    INTEGER :: access_stamp
    INTEGER(mpi_address_kind), ALLOCATABLE :: offset(:)
  END TYPE dm_array_cache_entry

  TYPE dist_mult_array
    PRIVATE
    !> number of arrays that are distributed
    INTEGER :: num_sub_arrays
    !> Per distributed array information on global array shape and contents.\n
    !! The size of this array is 1:num_sub_arrays.
    TYPE(global_array_desc), ALLOCATABLE :: sub_arrays_global_desc(:)
    !> Stores local rectangular slices/chunks for each MPI rank.\n
    !! local_chunks(r, s, m) gives extent of rank r of sub-array s on MPI rank m
    TYPE(extent), ALLOCATABLE :: local_chunks(:, :, :)
    !> MPI communicator of all ranks holding the distributed array
    INTEGER :: comm
    !> group corresponding to communicator
    INTEGER :: comm_group
    !> size of above communicator
    INTEGER :: comm_size
    !> rank within above communicator
    INTEGER :: comm_rank
    !> MPI RDMA window associated with distributed array
    INTEGER :: win
    !> exposure status
    INTEGER :: exposure_status
    !> address of local MPI RDMA window memory
    INTEGER(mpi_address_kind) :: win_base
    !> base extent of datatype of each sub-array, shape = (/ num_sub_arrays /)
    INTEGER(mpi_address_kind), ALLOCATABLE :: dt_extent(:)
    !> stamp of most recent remote access
    INTEGER :: access_stamp, valid_stamp
    !> maximal window size over all members
    INTEGER(mpi_address_kind) :: max_win_size
    !> cache of remote data (index 0 contains local chunks)
    TYPE(dm_array_cache_entry), ALLOCATABLE :: cache(:)
  END TYPE dist_mult_array

  PUBLIC :: dist_mult_array, global_array_desc
  PUBLIC :: dist_mult_array_new, dist_mult_array_delete
  PUBLIC :: dist_mult_array_local_ptr, dist_mult_array_get
  PUBLIC :: dist_mult_array_expose, dist_mult_array_unexpose


  INTERFACE dist_mult_array_local_ptr
    MODULE PROCEDURE dist_mult_array_local_ptr_c
    MODULE PROCEDURE dist_mult_array_local_ptr_i4_1d
    MODULE PROCEDURE dist_mult_array_local_ptr_i4_2d
    MODULE PROCEDURE dist_mult_array_local_ptr_i4_3d
    MODULE PROCEDURE dist_mult_array_local_ptr_i4_4d
    MODULE PROCEDURE dist_mult_array_local_ptr_i4_5d
    MODULE PROCEDURE dist_mult_array_local_ptr_i4_6d
    MODULE PROCEDURE dist_mult_array_local_ptr_i4_7d
    MODULE PROCEDURE dist_mult_array_local_ptr_i8_1d
    MODULE PROCEDURE dist_mult_array_local_ptr_i8_2d
    MODULE PROCEDURE dist_mult_array_local_ptr_i8_3d
    MODULE PROCEDURE dist_mult_array_local_ptr_i8_4d
    MODULE PROCEDURE dist_mult_array_local_ptr_i8_5d
    MODULE PROCEDURE dist_mult_array_local_ptr_i8_6d
    MODULE PROCEDURE dist_mult_array_local_ptr_i8_7d
    MODULE PROCEDURE dist_mult_array_local_ptr_l_1d
    MODULE PROCEDURE dist_mult_array_local_ptr_l_2d
    MODULE PROCEDURE dist_mult_array_local_ptr_l_3d
    MODULE PROCEDURE dist_mult_array_local_ptr_l_4d
    MODULE PROCEDURE dist_mult_array_local_ptr_l_5d
    MODULE PROCEDURE dist_mult_array_local_ptr_l_6d
    MODULE PROCEDURE dist_mult_array_local_ptr_l_7d
    MODULE PROCEDURE dist_mult_array_local_ptr_sp_1d
    MODULE PROCEDURE dist_mult_array_local_ptr_sp_2d
    MODULE PROCEDURE dist_mult_array_local_ptr_sp_3d
    MODULE PROCEDURE dist_mult_array_local_ptr_sp_4d
    MODULE PROCEDURE dist_mult_array_local_ptr_sp_5d
    MODULE PROCEDURE dist_mult_array_local_ptr_sp_6d
    MODULE PROCEDURE dist_mult_array_local_ptr_sp_7d
    MODULE PROCEDURE dist_mult_array_local_ptr_dp_1d
    MODULE PROCEDURE dist_mult_array_local_ptr_dp_2d
    MODULE PROCEDURE dist_mult_array_local_ptr_dp_3d
    MODULE PROCEDURE dist_mult_array_local_ptr_dp_4d
    MODULE PROCEDURE dist_mult_array_local_ptr_dp_5d
    MODULE PROCEDURE dist_mult_array_local_ptr_dp_6d
    MODULE PROCEDURE dist_mult_array_local_ptr_dp_7d
  END INTERFACE dist_mult_array_local_ptr

  INTERFACE dist_mult_array_get
    MODULE PROCEDURE dist_mult_array_get_i4
    MODULE PROCEDURE dist_mult_array_get_i8
    MODULE PROCEDURE dist_mult_array_get_l
    MODULE PROCEDURE dist_mult_array_get_sp
    MODULE PROCEDURE dist_mult_array_get_dp
  END INTERFACE dist_mult_array_get

CONTAINS
  FUNCTION dist_mult_array_new(sub_arrays, local_chunk, comm, cache_size) &
       RESULT(dm_array)
    TYPE(global_array_desc), INTENT(in) :: sub_arrays(:)
    !> shape = (/ max_rank or more, num_sub_arrays /)
    TYPE(extent), INTENT(in) :: local_chunk(:, :)
    INTEGER, INTENT(in) :: comm
    INTEGER, OPTIONAL, INTENT(in) :: cache_size
    TYPE(dist_mult_array) :: dm_array

    INTEGER :: ierror, num_sub_arrays, max_sub_array_rank, &
         comm_rank, comm_size, i, rank
    INTEGER(mpi_address_kind) :: remote_win_size, max_remote_win_size
    INTEGER :: cache_size_

    num_sub_arrays = SIZE(sub_arrays)
    dm_array%num_sub_arrays = num_sub_arrays
    max_sub_array_rank = MAXVAL(sub_arrays%a_rank)
    CALL mpi_comm_size(comm, comm_size, ierror)
    dm_array%comm_size = comm_size
    CALL handle_mpi_error(ierror, comm, __LINE__)
    ALLOCATE(dm_array%sub_arrays_global_desc(num_sub_arrays), &
         dm_array%local_chunks(max_sub_array_rank, num_sub_arrays, &
         0:comm_size-1), &
         dm_array%dt_extent(num_sub_arrays))
    dm_array%sub_arrays_global_desc = sub_arrays
    CALL mpi_comm_rank(comm, comm_rank, ierror)
    CALL handle_mpi_error(ierror, comm, __LINE__)
    dm_array%comm_rank = comm_rank
    dm_array%local_chunks(1:max_sub_array_rank, :, comm_rank) &
         = local_chunk(1:max_sub_array_rank, :)
    CALL mpi_allgather(mpi_in_place, 0, mpi_datatype_null, &
         dm_array%local_chunks, max_sub_array_rank * num_sub_arrays, &
         extent_mp, comm, ierror)
    CALL handle_mpi_error(ierror, comm, __LINE__)
    CALL mpi_comm_dup(comm, dm_array%comm, ierror)
    CALL handle_mpi_error(ierror, comm, __LINE__)
    CALL mpi_comm_group(dm_array%comm, dm_array%comm_group, ierror)
    CALL handle_mpi_error(ierror, comm, __LINE__)

    IF (PRESENT(cache_size)) THEN
      cache_size_ = cache_size
    ELSE
      cache_size_ = MIN(CEILING(SQRT(REAL(comm_size))), max_sub_array_rank)
    END IF
    ALLOCATE(dm_array%cache(0:cache_size_))
    dm_array%access_stamp = 0
    dm_array%valid_stamp = 0
    DO i = 0, cache_size_
      dm_array%cache(i)%rank = -1
      dm_array%cache(i)%base = 0
      dm_array%cache(i)%composite_dt = mpi_datatype_null
      dm_array%cache(i)%access_stamp = -1
      ALLOCATE(dm_array%cache(i)%offset(num_sub_arrays))
    END DO

    CALL get_extents
    CALL init_local_mem

    max_remote_win_size = 0_mpi_address_kind
    DO rank = 0, comm_size - 1
      remote_win_size = 0_mpi_address_kind
      DO i = 1, num_sub_arrays
        remote_win_size = align_addr(remote_win_size + dm_array%dt_extent(i) &
             * INT(extent_size(dm_array%local_chunks(1: &
             sub_arrays(i)%a_rank, i, rank)), mpi_address_kind))
      END DO
      if (remote_win_size > max_remote_win_size) &
           max_remote_win_size = remote_win_size
    END DO
    dm_array%max_win_size = max_remote_win_size
    CALL mpi_win_lock(mpi_lock_exclusive, dm_array%comm_rank, &
         mpi_mode_nocheck, dm_array%win, ierror)
  CONTAINS
    SUBROUTINE get_extents
      INTEGER :: i
      INTEGER(mpi_address_kind) :: lb

      DO i = 1, num_sub_arrays
        CALL mpi_type_get_extent(sub_arrays(i)%element_dt, lb, &
             dm_array%dt_extent(i), ierror)
        CALL handle_mpi_error(ierror, comm, __LINE__)
      END DO
    END SUBROUTINE get_extents

    SUBROUTINE init_local_mem
      INTEGER(mpi_address_kind) :: local_win_size
      TYPE(c_ptr) :: baseptr_c
      INTEGER, POINTER :: baseptr

      CALL compute_cache_addr(dm_array%cache(0), sub_arrays, local_chunk, &
           dm_array%dt_extent, local_win_size)
      CALL mpi_alloc_mem(local_win_size, mpi_info_null, &
           dm_array%cache(0)%base, ierror)
      CALL handle_mpi_error(ierror, comm, __LINE__)

      baseptr_c = TRANSFER(dm_array%cache(0)%base, baseptr_c)
      CALL C_F_POINTER(baseptr_c, baseptr)
      CALL mpi_win_create(baseptr, local_win_size, 1, mpi_info_null, &
         dm_array%comm, dm_array%win, ierror)
      CALL handle_mpi_error(ierror, comm, __LINE__)
      dm_array%exposure_status = not_exposed
      dm_array%cache(0)%rank = comm_rank
    END SUBROUTINE init_local_mem
  END FUNCTION dist_mult_array_new

  SUBROUTINE dist_mult_array_delete(dm_array)
    TYPE(dist_mult_array), INTENT(inout) :: dm_array

    INTEGER :: ierror, i

    IF (dm_array%exposure_status == exposed) THEN
      CALL dist_mult_array_unexpose(dm_array)
    END IF
    CALL mpi_win_unlock(dm_array%comm_rank, dm_array%win, ierror)
    CALL mpi_win_free(dm_array%win, ierror)
    CALL handle_mpi_error(ierror, dm_array%comm, __LINE__)
    DO i = LBOUND(dm_array%cache, 1), UBOUND(dm_array%cache, 1)
      CALL delete_cache_entry(dm_array%cache(i), dm_array%comm)
    END DO

    CALL mpi_group_free(dm_array%comm_group, ierror)
    CALL handle_mpi_error(ierror, dm_array%comm, __LINE__)

    CALL mpi_comm_free(dm_array%comm, ierror)
    CALL handle_mpi_error(ierror, ppm_default_comm, __LINE__)
    dm_array%comm = mpi_comm_null

    DEALLOCATE(dm_array%sub_arrays_global_desc, dm_array%local_chunks, &
         dm_array%dt_extent)

  END SUBROUTINE dist_mult_array_delete

  SUBROUTINE delete_cache_entry(cache_entry, comm)
    TYPE(dm_array_cache_entry), INTENT(inout) :: cache_entry
    INTEGER, INTENT(in) :: comm

    CALL free_cache_entry_dt(cache_entry, comm)
    IF (cache_entry%base /= 0) THEN
      CALL free_mpi_allocation(cache_entry%base, comm)
    END IF
  END SUBROUTINE delete_cache_entry

  SUBROUTINE free_cache_entry_dt(cache_entry, comm)
    TYPE(dm_array_cache_entry), INTENT(inout) :: cache_entry
    INTEGER, INTENT(in) :: comm

    INTEGER :: ierror

    IF (cache_entry%rank >= 0) THEN
      IF (cache_entry%composite_dt /= mpi_datatype_null) THEN
        CALL mpi_type_free(cache_entry%composite_dt, ierror)
        CALL handle_mpi_error(ierror, comm, __LINE__)
      END IF
    END IF
  END SUBROUTINE free_cache_entry_dt

  SUBROUTINE free_mpi_allocation(address, comm)
    INTEGER(mpi_address_kind), INTENT(inout) :: address
    INTEGER, INTENT(in) :: comm

    TYPE(c_ptr) :: baseptr_c
    INTEGER, POINTER :: baseptr
    INTEGER :: ierror

    baseptr_c = TRANSFER(address, baseptr_c)
    CALL C_F_POINTER(baseptr_c, baseptr)
    CALL mpi_free_mem(baseptr, ierror)
    CALL handle_mpi_error(ierror, comm, __LINE__)
  END SUBROUTINE free_mpi_allocation

  SUBROUTINE compute_cache_addr(cache_entry, sub_arrays, chunk, dt_extent, &
       win_size)
    TYPE(dm_array_cache_entry), INTENT(inout) :: cache_entry
    TYPE(global_array_desc), INTENT(in) :: sub_arrays(:)
    TYPE(extent), INTENT(in) :: chunk(:, :)
    INTEGER(mpi_address_kind), INTENT(in) :: dt_extent(:)
    INTEGER(mpi_address_kind), OPTIONAL, INTENT(out) :: win_size

    INTEGER :: i, num_sub_arrays
    INTEGER(mpi_address_kind) :: win_size_

    num_sub_arrays = SIZE(sub_arrays)
    win_size_ = 0_mpi_address_kind
    DO i = 1, num_sub_arrays
      cache_entry%offset(i) = win_size_
      win_size_ = align_addr(win_size_ + dt_extent(i) &
           * INT(extent_size(chunk(1:sub_arrays(i)%a_rank, i)), &
           &     mpi_address_kind))
    END DO
    IF (PRESENT(win_size)) win_size = win_size_
  END SUBROUTINE compute_cache_addr

  FUNCTION align_addr(addr) RESULT(aligned_addr)
    INTEGER(mpi_address_kind), INTENT(in) :: addr
    INTEGER(mpi_address_kind) :: aligned_addr

    ! round up to next multiple of ppm_maximum_alignment
    IF (IAND(ppm_maximum_alignment, &
         ppm_maximum_alignment - 1_ppm_address_kind) &
         == 0_ppm_address_kind) THEN
      aligned_addr = IAND(addr + ppm_maximum_alignment - 1, &
           -ppm_maximum_alignment)
    ELSE
      aligned_addr = ((addr + ppm_maximum_alignment - 1) &
           / ppm_maximum_alignment) * ppm_maximum_alignment
    END IF
  END FUNCTION align_addr

  SUBROUTINE dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    TYPE(c_ptr), INTENT(out) :: sub_array_ptr
    sub_array_ptr = TRANSFER(dm_array%cache(cache_idx)%base &
         + dm_array%cache(cache_idx)%offset(sub_array_idx), sub_array_ptr)
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_c

  SUBROUTINE dist_mult_array_local_ptr_c(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    TYPE(c_ptr), INTENT(out) :: sub_array_ptr
    sub_array_ptr = TRANSFER(dm_array%cache(0)%base &
         + dm_array%cache(0)%offset(sub_array_idx), sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_c

  SUBROUTINE dist_mult_array_expose(dm_array)
    TYPE(dist_mult_array), INTENT(inout) :: dm_array

    INTEGER :: ierror
    CALL assertion(dm_array%exposure_status == not_exposed, &
         __FILE__, &
         __LINE__, "distributed multi-array must not already be exposed!")
    CALL mpi_win_unlock(dm_array%comm_rank, dm_array%win, ierror)
    CALL mpi_barrier(dm_array%comm, ierror)
    CALL handle_mpi_error(ierror, dm_array%comm, __LINE__)
    dm_array%exposure_status = exposed
    dm_array%valid_stamp = dm_array%access_stamp + 1
  END SUBROUTINE dist_mult_array_expose

  SUBROUTINE dist_mult_array_unexpose(dm_array)
    TYPE(dist_mult_array), INTENT(inout) :: dm_array

    INTEGER :: ierror
    CALL assertion(dm_array%exposure_status == exposed, &
         __FILE__, &
         __LINE__, &
         "distributed multi-array must have previously been made accessible!")
    CALL mpi_barrier(dm_array%comm, ierror)
    CALL mpi_win_lock(mpi_lock_exclusive, dm_array%comm_rank, &
         mpi_mode_nocheck, dm_array%win, ierror)

    CALL handle_mpi_error(ierror, dm_array%comm, __LINE__)
    dm_array%exposure_status = not_exposed
  END SUBROUTINE dist_mult_array_unexpose

  FUNCTION dist_mult_array_cache_rank(dm_array, rank) RESULT(cache_entry)
    TYPE(dist_mult_array), INTENT(inout) :: dm_array
    INTEGER, INTENT(in) :: rank
    INTEGER :: cache_entry

    INTEGER :: i, oldest, stamp, oldest_stamp, ierror
    INTEGER :: component_count(dm_array%num_sub_arrays)
    INTEGER :: a_rank, num_sub_arrays

    IF (rank == dm_array%comm_rank) THEN
      cache_entry = 0
      RETURN
    END IF
    CALL assertion(dm_array%exposure_status == exposed, &
         __FILE__, &
         __LINE__, &
         "distributed multi-array must have previously been made accessible!")
    stamp = dm_array%access_stamp + 1
    oldest_stamp = stamp
    DO i = 1, UBOUND(dm_array%cache, 1)
      IF (dm_array%cache(i)%rank == rank) THEN
        IF (dm_array%cache(i)%access_stamp < dm_array%valid_stamp) &
             CALL cache_get(i, rank)
        dm_array%cache(i)%access_stamp = stamp
        dm_array%access_stamp = stamp
        cache_entry = i
        RETURN
      ELSE IF (dm_array%cache(i)%access_stamp < oldest_stamp) THEN
        oldest_stamp = dm_array%cache(i)%access_stamp
        oldest = i
      END IF
    END DO
    IF (dm_array%cache(oldest)%rank >= 0) THEN
      ! free cache resources here
      CALL free_cache_entry_dt(dm_array%cache(oldest), dm_array%comm)
    END IF
    ! populate free cache entry
    IF (dm_array%cache(oldest)%base == 0) THEN
      CALL mpi_alloc_mem(dm_array%max_win_size, mpi_info_null, &
           dm_array%cache(oldest)%base, ierror)
      CALL handle_mpi_error(ierror, dm_array%comm, __LINE__)
    END IF
    ! create datatype for mpi_get
    CALL compute_cache_addr(dm_array%cache(oldest), &
         dm_array%sub_arrays_global_desc, &
         dm_array%local_chunks(:, :, rank), dm_array%dt_extent)

    num_sub_arrays = dm_array%num_sub_arrays
    DO i = 1, num_sub_arrays
      a_rank = dm_array%sub_arrays_global_desc(i)%a_rank
      component_count(i) = extent_size(dm_array%local_chunks(1:a_rank, i, rank))
    END DO
    CALL mpi_type_create_struct(num_sub_arrays, component_count, &
         dm_array%cache(oldest)%offset, &
         dm_array%sub_arrays_global_desc(:)%element_dt, &
         dm_array%cache(oldest)%composite_dt, ierror)
    CALL handle_mpi_error(ierror, dm_array%comm, __LINE__)
    CALL mpi_type_commit(dm_array%cache(oldest)%composite_dt, ierror)
    CALL handle_mpi_error(ierror, dm_array%comm, __LINE__)
    CALL cache_get(oldest, rank)

    dm_array%cache(oldest)%rank = rank

    dm_array%cache(oldest)%access_stamp = stamp
    dm_array%access_stamp = stamp

    cache_entry = oldest
  CONTAINS
    SUBROUTINE cache_get(cache_entry, rank)
      INTEGER, INTENT(in) :: cache_entry, rank

      INTEGER :: ierror
      TYPE(c_ptr) :: baseptr_c
      INTEGER, POINTER :: baseptr

      baseptr_c = TRANSFER(dm_array%cache(cache_entry)%base, baseptr_c)
      CALL C_F_POINTER(baseptr_c, baseptr)
      CALL mpi_win_lock(mpi_lock_shared, rank, mpi_mode_nocheck, &
           dm_array%win, ierror)
      CALL handle_mpi_error(ierror, dm_array%comm, __LINE__)
      CALL mpi_get(baseptr, 1, dm_array%cache(cache_entry)%composite_dt, &
           rank, 0_mpi_address_kind, 1,&
           dm_array%cache(cache_entry)%composite_dt, dm_array%win, ierror)
      CALL handle_mpi_error(ierror, dm_array%comm, __LINE__)
      CALL mpi_win_unlock(rank, dm_array%win, ierror)
      CALL handle_mpi_error(ierror, dm_array%comm, __LINE__)
    END SUBROUTINE cache_get
  END FUNCTION dist_mult_array_cache_rank



  SUBROUTINE dist_mult_array_get_cache_val_i4(dm_array, sub_array_idx, &
       cache_idx, coord, v)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx, cache_idx
    INTEGER, INTENT(in) :: coord(:)
    INTEGER(i4), INTENT(out) :: v

    INTEGER(i4), POINTER :: p1(:), &
         &         p2(:,:), &
         &         p3(:,:,:), &
         &         p4(:,:,:,:), &
         &         p5(:,:,:,:,:), &
         &         p6(:,:,:,:,:,:), &
         &         p7(:,:,:,:,:,:,:)

    SELECT CASE (SIZE(coord))

    CASE (1)
      CALL dist_mult_array_cache_chunk_ptr_i4_1d(dm_array, sub_array_idx, &
           cache_idx, p1)
      v = p1(coord(1))
    CASE (2)
      CALL dist_mult_array_cache_chunk_ptr_i4_2d(dm_array, sub_array_idx, &
           cache_idx, p2)
      v = p2(coord(1),coord(2))
    CASE (3)
      CALL dist_mult_array_cache_chunk_ptr_i4_3d(dm_array, sub_array_idx, &
           cache_idx, p3)
      v = p3(coord(1),coord(2),coord(3))
    CASE (4)
      CALL dist_mult_array_cache_chunk_ptr_i4_4d(dm_array, sub_array_idx, &
           cache_idx, p4)
      v = p4(coord(1),coord(2),coord(3),coord(4))
    CASE (5)
      CALL dist_mult_array_cache_chunk_ptr_i4_5d(dm_array, sub_array_idx, &
           cache_idx, p5)
      v = p5(coord(1),coord(2),coord(3),coord(4),coord(5))
    CASE (6)
      CALL dist_mult_array_cache_chunk_ptr_i4_6d(dm_array, sub_array_idx, &
           cache_idx, p6)
      v = p6(coord(1),coord(2),coord(3),coord(4),coord(5),coord(6))
    CASE (7)
      CALL dist_mult_array_cache_chunk_ptr_i4_7d(dm_array, sub_array_idx, &
           cache_idx, p7)
      v = p7(coord(1),coord(2),coord(3),coord(4),coord(5),coord(6),coord(7))
    CASE default
      CALL abort_ppm("invalid array rank", &
           __FILE__, &
           __LINE__, dm_array%comm)
    END SELECT
  END SUBROUTINE dist_mult_array_get_cache_val_i4


  SUBROUTINE dist_mult_array_cache_chunk_ptr_i4_1d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    INTEGER(i4), POINTER :: sub_array_ptr(:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(1)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:1, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_i4_1d

  SUBROUTINE dist_mult_array_local_ptr_i4_1d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER(i4), POINTER :: sub_array_ptr(:)

    CALL dist_mult_array_cache_chunk_ptr_i4_1d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_i4_1d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_i4_2d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    INTEGER(i4), POINTER :: sub_array_ptr(:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(2)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:2, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_i4_2d

  SUBROUTINE dist_mult_array_local_ptr_i4_2d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER(i4), POINTER :: sub_array_ptr(:,:)

    CALL dist_mult_array_cache_chunk_ptr_i4_2d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_i4_2d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_i4_3d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    INTEGER(i4), POINTER :: sub_array_ptr(:,:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(3)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:3, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(3, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_i4_3d

  SUBROUTINE dist_mult_array_local_ptr_i4_3d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER(i4), POINTER :: sub_array_ptr(:,:,:)

    CALL dist_mult_array_cache_chunk_ptr_i4_3d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_i4_3d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_i4_4d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    INTEGER(i4), POINTER :: sub_array_ptr(:,:,:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(4)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:4, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(3, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(4, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_i4_4d

  SUBROUTINE dist_mult_array_local_ptr_i4_4d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER(i4), POINTER :: sub_array_ptr(:,:,:,:)

    CALL dist_mult_array_cache_chunk_ptr_i4_4d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_i4_4d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_i4_5d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    INTEGER(i4), POINTER :: sub_array_ptr(:,:,:,:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(5)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:5, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(3, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(4, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(5, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_i4_5d

  SUBROUTINE dist_mult_array_local_ptr_i4_5d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER(i4), POINTER :: sub_array_ptr(:,:,:,:,:)

    CALL dist_mult_array_cache_chunk_ptr_i4_5d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_i4_5d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_i4_6d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    INTEGER(i4), POINTER :: sub_array_ptr(:,:,:,:,:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(6)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:6, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(3, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(4, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(5, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(6, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_i4_6d

  SUBROUTINE dist_mult_array_local_ptr_i4_6d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER(i4), POINTER :: sub_array_ptr(:,:,:,:,:,:)

    CALL dist_mult_array_cache_chunk_ptr_i4_6d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_i4_6d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_i4_7d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    INTEGER(i4), POINTER :: sub_array_ptr(:,:,:,:,:,:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(7)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:7, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(3, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(4, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(5, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(6, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(7, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_i4_7d

  SUBROUTINE dist_mult_array_local_ptr_i4_7d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER(i4), POINTER :: sub_array_ptr(:,:,:,:,:,:,:)

    CALL dist_mult_array_cache_chunk_ptr_i4_7d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_i4_7d

  SUBROUTINE dist_mult_array_get_i4(dm_array, sub_array, coord, v)
    TYPE(dist_mult_array), INTENT(inout) :: dm_array
    INTEGER, INTENT(in) :: sub_array
    INTEGER, INTENT(in) :: coord(:)
    INTEGER(i4), INTENT(out) :: v

    INTEGER :: ref_rank, dist, comm_rank, comm_size, max_dist
    INTEGER :: cache_idx, ierror
    INTEGER(mpi_address_kind) :: lb, extent

    CALL assertion(sub_array >= 1 &
         .AND. sub_array <= SIZE(dm_array%sub_arrays_global_desc), &
         __FILE__, &
         __LINE__, "invalid subarray index")
    ref_rank = SIZE(coord)
    CALL assertion(ref_rank &
         == dm_array%sub_arrays_global_desc(sub_array)%a_rank, &
         __FILE__, &
         __LINE__, "rank mismatch in array reference")
    CALL assertion(is_contained_in(coord, &
         dm_array%sub_arrays_global_desc(sub_array)%rect(1:ref_rank)), &
         __FILE__, &
         __LINE__, "invalid coordinate")
    call mpi_type_get_extent(&
         dm_array%sub_arrays_global_desc(sub_array)%element_dt, &
         lb, extent, ierror)
    CALL handle_mpi_error(ierror, dm_array%comm, __LINE__)
    CALL assertion(extent == mp_i4_extent, &
         __FILE__, &
         __LINE__, "extent mismatch")
    comm_rank = dm_array%comm_rank
    comm_size = dm_array%comm_size
    max_dist = (comm_size + 1)/2
    cache_idx = -1
    DO dist = 0, max_dist
      IF (is_contained_in(coord, dm_array%local_chunks(1:ref_rank, sub_array, &
           MOD(comm_rank + dist, comm_size)))) THEN
        cache_idx = dist_mult_array_cache_rank(dm_array, &
             MOD(comm_rank + dist, comm_size))
        EXIT
      ELSE IF (is_contained_in(coord, &
           dm_array%local_chunks(1:ref_rank, sub_array, &
           MODULO(comm_rank - dist, comm_size)))) THEN
        cache_idx = dist_mult_array_cache_rank(dm_array, &
             MODULO(comm_rank - dist, comm_size))
        EXIT
      END IF
    END DO
    CALL assertion(cache_idx >= 0, &
         __FILE__, &
         __LINE__, "invalid coordinate")
    CALL dist_mult_array_get_cache_val_i4(dm_array, sub_array, &
         cache_idx, coord, v)
  END SUBROUTINE dist_mult_array_get_i4


  SUBROUTINE dist_mult_array_get_cache_val_i8(dm_array, sub_array_idx, &
       cache_idx, coord, v)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx, cache_idx
    INTEGER, INTENT(in) :: coord(:)
    INTEGER(i8), INTENT(out) :: v

    INTEGER(i8), POINTER :: p1(:), &
         &         p2(:,:), &
         &         p3(:,:,:), &
         &         p4(:,:,:,:), &
         &         p5(:,:,:,:,:), &
         &         p6(:,:,:,:,:,:), &
         &         p7(:,:,:,:,:,:,:)

    SELECT CASE (SIZE(coord))

    CASE (1)
      CALL dist_mult_array_cache_chunk_ptr_i8_1d(dm_array, sub_array_idx, &
           cache_idx, p1)
      v = p1(coord(1))
    CASE (2)
      CALL dist_mult_array_cache_chunk_ptr_i8_2d(dm_array, sub_array_idx, &
           cache_idx, p2)
      v = p2(coord(1),coord(2))
    CASE (3)
      CALL dist_mult_array_cache_chunk_ptr_i8_3d(dm_array, sub_array_idx, &
           cache_idx, p3)
      v = p3(coord(1),coord(2),coord(3))
    CASE (4)
      CALL dist_mult_array_cache_chunk_ptr_i8_4d(dm_array, sub_array_idx, &
           cache_idx, p4)
      v = p4(coord(1),coord(2),coord(3),coord(4))
    CASE (5)
      CALL dist_mult_array_cache_chunk_ptr_i8_5d(dm_array, sub_array_idx, &
           cache_idx, p5)
      v = p5(coord(1),coord(2),coord(3),coord(4),coord(5))
    CASE (6)
      CALL dist_mult_array_cache_chunk_ptr_i8_6d(dm_array, sub_array_idx, &
           cache_idx, p6)
      v = p6(coord(1),coord(2),coord(3),coord(4),coord(5),coord(6))
    CASE (7)
      CALL dist_mult_array_cache_chunk_ptr_i8_7d(dm_array, sub_array_idx, &
           cache_idx, p7)
      v = p7(coord(1),coord(2),coord(3),coord(4),coord(5),coord(6),coord(7))
    CASE default
      CALL abort_ppm("invalid array rank", &
           __FILE__, &
           __LINE__, dm_array%comm)
    END SELECT
  END SUBROUTINE dist_mult_array_get_cache_val_i8


  SUBROUTINE dist_mult_array_cache_chunk_ptr_i8_1d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    INTEGER(i8), POINTER :: sub_array_ptr(:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(1)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:1, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_i8_1d

  SUBROUTINE dist_mult_array_local_ptr_i8_1d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER(i8), POINTER :: sub_array_ptr(:)

    CALL dist_mult_array_cache_chunk_ptr_i8_1d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_i8_1d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_i8_2d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    INTEGER(i8), POINTER :: sub_array_ptr(:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(2)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:2, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_i8_2d

  SUBROUTINE dist_mult_array_local_ptr_i8_2d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER(i8), POINTER :: sub_array_ptr(:,:)

    CALL dist_mult_array_cache_chunk_ptr_i8_2d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_i8_2d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_i8_3d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    INTEGER(i8), POINTER :: sub_array_ptr(:,:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(3)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:3, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(3, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_i8_3d

  SUBROUTINE dist_mult_array_local_ptr_i8_3d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER(i8), POINTER :: sub_array_ptr(:,:,:)

    CALL dist_mult_array_cache_chunk_ptr_i8_3d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_i8_3d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_i8_4d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    INTEGER(i8), POINTER :: sub_array_ptr(:,:,:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(4)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:4, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(3, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(4, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_i8_4d

  SUBROUTINE dist_mult_array_local_ptr_i8_4d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER(i8), POINTER :: sub_array_ptr(:,:,:,:)

    CALL dist_mult_array_cache_chunk_ptr_i8_4d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_i8_4d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_i8_5d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    INTEGER(i8), POINTER :: sub_array_ptr(:,:,:,:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(5)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:5, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(3, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(4, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(5, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_i8_5d

  SUBROUTINE dist_mult_array_local_ptr_i8_5d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER(i8), POINTER :: sub_array_ptr(:,:,:,:,:)

    CALL dist_mult_array_cache_chunk_ptr_i8_5d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_i8_5d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_i8_6d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    INTEGER(i8), POINTER :: sub_array_ptr(:,:,:,:,:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(6)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:6, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(3, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(4, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(5, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(6, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_i8_6d

  SUBROUTINE dist_mult_array_local_ptr_i8_6d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER(i8), POINTER :: sub_array_ptr(:,:,:,:,:,:)

    CALL dist_mult_array_cache_chunk_ptr_i8_6d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_i8_6d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_i8_7d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    INTEGER(i8), POINTER :: sub_array_ptr(:,:,:,:,:,:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(7)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:7, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(3, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(4, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(5, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(6, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(7, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_i8_7d

  SUBROUTINE dist_mult_array_local_ptr_i8_7d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER(i8), POINTER :: sub_array_ptr(:,:,:,:,:,:,:)

    CALL dist_mult_array_cache_chunk_ptr_i8_7d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_i8_7d

  SUBROUTINE dist_mult_array_get_i8(dm_array, sub_array, coord, v)
    TYPE(dist_mult_array), INTENT(inout) :: dm_array
    INTEGER, INTENT(in) :: sub_array
    INTEGER, INTENT(in) :: coord(:)
    INTEGER(i8), INTENT(out) :: v

    INTEGER :: ref_rank, dist, comm_rank, comm_size, max_dist
    INTEGER :: cache_idx, ierror
    INTEGER(mpi_address_kind) :: lb, extent

    CALL assertion(sub_array >= 1 &
         .AND. sub_array <= SIZE(dm_array%sub_arrays_global_desc), &
         __FILE__, &
         __LINE__, "invalid subarray index")
    ref_rank = SIZE(coord)
    CALL assertion(ref_rank &
         == dm_array%sub_arrays_global_desc(sub_array)%a_rank, &
         __FILE__, &
         __LINE__, "rank mismatch in array reference")
    CALL assertion(is_contained_in(coord, &
         dm_array%sub_arrays_global_desc(sub_array)%rect(1:ref_rank)), &
         __FILE__, &
         __LINE__, "invalid coordinate")
    call mpi_type_get_extent(&
         dm_array%sub_arrays_global_desc(sub_array)%element_dt, &
         lb, extent, ierror)
    CALL handle_mpi_error(ierror, dm_array%comm, __LINE__)
    CALL assertion(extent == mp_i8_extent, &
         __FILE__, &
         __LINE__, "extent mismatch")
    comm_rank = dm_array%comm_rank
    comm_size = dm_array%comm_size
    max_dist = (comm_size + 1)/2
    cache_idx = -1
    DO dist = 0, max_dist
      IF (is_contained_in(coord, dm_array%local_chunks(1:ref_rank, sub_array, &
           MOD(comm_rank + dist, comm_size)))) THEN
        cache_idx = dist_mult_array_cache_rank(dm_array, &
             MOD(comm_rank + dist, comm_size))
        EXIT
      ELSE IF (is_contained_in(coord, &
           dm_array%local_chunks(1:ref_rank, sub_array, &
           MODULO(comm_rank - dist, comm_size)))) THEN
        cache_idx = dist_mult_array_cache_rank(dm_array, &
             MODULO(comm_rank - dist, comm_size))
        EXIT
      END IF
    END DO
    CALL assertion(cache_idx >= 0, &
         __FILE__, &
         __LINE__, "invalid coordinate")
    CALL dist_mult_array_get_cache_val_i8(dm_array, sub_array, &
         cache_idx, coord, v)
  END SUBROUTINE dist_mult_array_get_i8


  SUBROUTINE dist_mult_array_get_cache_val_l(dm_array, sub_array_idx, &
       cache_idx, coord, v)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx, cache_idx
    INTEGER, INTENT(in) :: coord(:)
    LOGICAL, INTENT(out) :: v

    LOGICAL, POINTER :: p1(:), &
         &         p2(:,:), &
         &         p3(:,:,:), &
         &         p4(:,:,:,:), &
         &         p5(:,:,:,:,:), &
         &         p6(:,:,:,:,:,:), &
         &         p7(:,:,:,:,:,:,:)

    SELECT CASE (SIZE(coord))

    CASE (1)
      CALL dist_mult_array_cache_chunk_ptr_l_1d(dm_array, sub_array_idx, &
           cache_idx, p1)
      v = p1(coord(1))
    CASE (2)
      CALL dist_mult_array_cache_chunk_ptr_l_2d(dm_array, sub_array_idx, &
           cache_idx, p2)
      v = p2(coord(1),coord(2))
    CASE (3)
      CALL dist_mult_array_cache_chunk_ptr_l_3d(dm_array, sub_array_idx, &
           cache_idx, p3)
      v = p3(coord(1),coord(2),coord(3))
    CASE (4)
      CALL dist_mult_array_cache_chunk_ptr_l_4d(dm_array, sub_array_idx, &
           cache_idx, p4)
      v = p4(coord(1),coord(2),coord(3),coord(4))
    CASE (5)
      CALL dist_mult_array_cache_chunk_ptr_l_5d(dm_array, sub_array_idx, &
           cache_idx, p5)
      v = p5(coord(1),coord(2),coord(3),coord(4),coord(5))
    CASE (6)
      CALL dist_mult_array_cache_chunk_ptr_l_6d(dm_array, sub_array_idx, &
           cache_idx, p6)
      v = p6(coord(1),coord(2),coord(3),coord(4),coord(5),coord(6))
    CASE (7)
      CALL dist_mult_array_cache_chunk_ptr_l_7d(dm_array, sub_array_idx, &
           cache_idx, p7)
      v = p7(coord(1),coord(2),coord(3),coord(4),coord(5),coord(6),coord(7))
    CASE default
      CALL abort_ppm("invalid array rank", &
           __FILE__, &
           __LINE__, dm_array%comm)
    END SELECT
  END SUBROUTINE dist_mult_array_get_cache_val_l


  SUBROUTINE dist_mult_array_cache_chunk_ptr_l_1d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    LOGICAL, POINTER :: sub_array_ptr(:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(1)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:1, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_l_1d

  SUBROUTINE dist_mult_array_local_ptr_l_1d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    LOGICAL, POINTER :: sub_array_ptr(:)

    CALL dist_mult_array_cache_chunk_ptr_l_1d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_l_1d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_l_2d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    LOGICAL, POINTER :: sub_array_ptr(:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(2)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:2, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_l_2d

  SUBROUTINE dist_mult_array_local_ptr_l_2d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    LOGICAL, POINTER :: sub_array_ptr(:,:)

    CALL dist_mult_array_cache_chunk_ptr_l_2d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_l_2d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_l_3d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    LOGICAL, POINTER :: sub_array_ptr(:,:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(3)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:3, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(3, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_l_3d

  SUBROUTINE dist_mult_array_local_ptr_l_3d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    LOGICAL, POINTER :: sub_array_ptr(:,:,:)

    CALL dist_mult_array_cache_chunk_ptr_l_3d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_l_3d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_l_4d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    LOGICAL, POINTER :: sub_array_ptr(:,:,:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(4)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:4, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(3, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(4, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_l_4d

  SUBROUTINE dist_mult_array_local_ptr_l_4d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    LOGICAL, POINTER :: sub_array_ptr(:,:,:,:)

    CALL dist_mult_array_cache_chunk_ptr_l_4d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_l_4d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_l_5d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    LOGICAL, POINTER :: sub_array_ptr(:,:,:,:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(5)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:5, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(3, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(4, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(5, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_l_5d

  SUBROUTINE dist_mult_array_local_ptr_l_5d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    LOGICAL, POINTER :: sub_array_ptr(:,:,:,:,:)

    CALL dist_mult_array_cache_chunk_ptr_l_5d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_l_5d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_l_6d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    LOGICAL, POINTER :: sub_array_ptr(:,:,:,:,:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(6)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:6, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(3, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(4, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(5, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(6, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_l_6d

  SUBROUTINE dist_mult_array_local_ptr_l_6d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    LOGICAL, POINTER :: sub_array_ptr(:,:,:,:,:,:)

    CALL dist_mult_array_cache_chunk_ptr_l_6d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_l_6d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_l_7d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    LOGICAL, POINTER :: sub_array_ptr(:,:,:,:,:,:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(7)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:7, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(3, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(4, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(5, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(6, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(7, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_l_7d

  SUBROUTINE dist_mult_array_local_ptr_l_7d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    LOGICAL, POINTER :: sub_array_ptr(:,:,:,:,:,:,:)

    CALL dist_mult_array_cache_chunk_ptr_l_7d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_l_7d

  SUBROUTINE dist_mult_array_get_l(dm_array, sub_array, coord, v)
    TYPE(dist_mult_array), INTENT(inout) :: dm_array
    INTEGER, INTENT(in) :: sub_array
    INTEGER, INTENT(in) :: coord(:)
    LOGICAL, INTENT(out) :: v

    INTEGER :: ref_rank, dist, comm_rank, comm_size, max_dist
    INTEGER :: cache_idx, ierror
    INTEGER(mpi_address_kind) :: lb, extent

    CALL assertion(sub_array >= 1 &
         .AND. sub_array <= SIZE(dm_array%sub_arrays_global_desc), &
         __FILE__, &
         __LINE__, "invalid subarray index")
    ref_rank = SIZE(coord)
    CALL assertion(ref_rank &
         == dm_array%sub_arrays_global_desc(sub_array)%a_rank, &
         __FILE__, &
         __LINE__, "rank mismatch in array reference")
    CALL assertion(is_contained_in(coord, &
         dm_array%sub_arrays_global_desc(sub_array)%rect(1:ref_rank)), &
         __FILE__, &
         __LINE__, "invalid coordinate")
    call mpi_type_get_extent(&
         dm_array%sub_arrays_global_desc(sub_array)%element_dt, &
         lb, extent, ierror)
    CALL handle_mpi_error(ierror, dm_array%comm, __LINE__)
    CALL assertion(extent == mp_l_extent, &
         __FILE__, &
         __LINE__, "extent mismatch")
    comm_rank = dm_array%comm_rank
    comm_size = dm_array%comm_size
    max_dist = (comm_size + 1)/2
    cache_idx = -1
    DO dist = 0, max_dist
      IF (is_contained_in(coord, dm_array%local_chunks(1:ref_rank, sub_array, &
           MOD(comm_rank + dist, comm_size)))) THEN
        cache_idx = dist_mult_array_cache_rank(dm_array, &
             MOD(comm_rank + dist, comm_size))
        EXIT
      ELSE IF (is_contained_in(coord, &
           dm_array%local_chunks(1:ref_rank, sub_array, &
           MODULO(comm_rank - dist, comm_size)))) THEN
        cache_idx = dist_mult_array_cache_rank(dm_array, &
             MODULO(comm_rank - dist, comm_size))
        EXIT
      END IF
    END DO
    CALL assertion(cache_idx >= 0, &
         __FILE__, &
         __LINE__, "invalid coordinate")
    CALL dist_mult_array_get_cache_val_l(dm_array, sub_array, &
         cache_idx, coord, v)
  END SUBROUTINE dist_mult_array_get_l


  SUBROUTINE dist_mult_array_get_cache_val_sp(dm_array, sub_array_idx, &
       cache_idx, coord, v)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx, cache_idx
    INTEGER, INTENT(in) :: coord(:)
    REAL(sp), INTENT(out) :: v

    REAL(sp), POINTER :: p1(:), &
         &         p2(:,:), &
         &         p3(:,:,:), &
         &         p4(:,:,:,:), &
         &         p5(:,:,:,:,:), &
         &         p6(:,:,:,:,:,:), &
         &         p7(:,:,:,:,:,:,:)

    SELECT CASE (SIZE(coord))

    CASE (1)
      CALL dist_mult_array_cache_chunk_ptr_sp_1d(dm_array, sub_array_idx, &
           cache_idx, p1)
      v = p1(coord(1))
    CASE (2)
      CALL dist_mult_array_cache_chunk_ptr_sp_2d(dm_array, sub_array_idx, &
           cache_idx, p2)
      v = p2(coord(1),coord(2))
    CASE (3)
      CALL dist_mult_array_cache_chunk_ptr_sp_3d(dm_array, sub_array_idx, &
           cache_idx, p3)
      v = p3(coord(1),coord(2),coord(3))
    CASE (4)
      CALL dist_mult_array_cache_chunk_ptr_sp_4d(dm_array, sub_array_idx, &
           cache_idx, p4)
      v = p4(coord(1),coord(2),coord(3),coord(4))
    CASE (5)
      CALL dist_mult_array_cache_chunk_ptr_sp_5d(dm_array, sub_array_idx, &
           cache_idx, p5)
      v = p5(coord(1),coord(2),coord(3),coord(4),coord(5))
    CASE (6)
      CALL dist_mult_array_cache_chunk_ptr_sp_6d(dm_array, sub_array_idx, &
           cache_idx, p6)
      v = p6(coord(1),coord(2),coord(3),coord(4),coord(5),coord(6))
    CASE (7)
      CALL dist_mult_array_cache_chunk_ptr_sp_7d(dm_array, sub_array_idx, &
           cache_idx, p7)
      v = p7(coord(1),coord(2),coord(3),coord(4),coord(5),coord(6),coord(7))
    CASE default
      CALL abort_ppm("invalid array rank", &
           __FILE__, &
           __LINE__, dm_array%comm)
    END SELECT
  END SUBROUTINE dist_mult_array_get_cache_val_sp


  SUBROUTINE dist_mult_array_cache_chunk_ptr_sp_1d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    REAL(sp), POINTER :: sub_array_ptr(:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(1)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:1, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_sp_1d

  SUBROUTINE dist_mult_array_local_ptr_sp_1d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    REAL(sp), POINTER :: sub_array_ptr(:)

    CALL dist_mult_array_cache_chunk_ptr_sp_1d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_sp_1d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_sp_2d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    REAL(sp), POINTER :: sub_array_ptr(:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(2)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:2, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_sp_2d

  SUBROUTINE dist_mult_array_local_ptr_sp_2d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    REAL(sp), POINTER :: sub_array_ptr(:,:)

    CALL dist_mult_array_cache_chunk_ptr_sp_2d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_sp_2d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_sp_3d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    REAL(sp), POINTER :: sub_array_ptr(:,:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(3)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:3, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(3, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_sp_3d

  SUBROUTINE dist_mult_array_local_ptr_sp_3d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    REAL(sp), POINTER :: sub_array_ptr(:,:,:)

    CALL dist_mult_array_cache_chunk_ptr_sp_3d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_sp_3d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_sp_4d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    REAL(sp), POINTER :: sub_array_ptr(:,:,:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(4)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:4, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(3, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(4, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_sp_4d

  SUBROUTINE dist_mult_array_local_ptr_sp_4d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    REAL(sp), POINTER :: sub_array_ptr(:,:,:,:)

    CALL dist_mult_array_cache_chunk_ptr_sp_4d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_sp_4d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_sp_5d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    REAL(sp), POINTER :: sub_array_ptr(:,:,:,:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(5)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:5, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(3, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(4, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(5, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_sp_5d

  SUBROUTINE dist_mult_array_local_ptr_sp_5d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    REAL(sp), POINTER :: sub_array_ptr(:,:,:,:,:)

    CALL dist_mult_array_cache_chunk_ptr_sp_5d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_sp_5d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_sp_6d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    REAL(sp), POINTER :: sub_array_ptr(:,:,:,:,:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(6)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:6, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(3, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(4, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(5, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(6, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_sp_6d

  SUBROUTINE dist_mult_array_local_ptr_sp_6d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    REAL(sp), POINTER :: sub_array_ptr(:,:,:,:,:,:)

    CALL dist_mult_array_cache_chunk_ptr_sp_6d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_sp_6d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_sp_7d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    REAL(sp), POINTER :: sub_array_ptr(:,:,:,:,:,:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(7)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:7, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(3, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(4, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(5, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(6, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(7, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_sp_7d

  SUBROUTINE dist_mult_array_local_ptr_sp_7d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    REAL(sp), POINTER :: sub_array_ptr(:,:,:,:,:,:,:)

    CALL dist_mult_array_cache_chunk_ptr_sp_7d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_sp_7d

  SUBROUTINE dist_mult_array_get_sp(dm_array, sub_array, coord, v)
    TYPE(dist_mult_array), INTENT(inout) :: dm_array
    INTEGER, INTENT(in) :: sub_array
    INTEGER, INTENT(in) :: coord(:)
    REAL(sp), INTENT(out) :: v

    INTEGER :: ref_rank, dist, comm_rank, comm_size, max_dist
    INTEGER :: cache_idx, ierror
    INTEGER(mpi_address_kind) :: lb, extent

    CALL assertion(sub_array >= 1 &
         .AND. sub_array <= SIZE(dm_array%sub_arrays_global_desc), &
         __FILE__, &
         __LINE__, "invalid subarray index")
    ref_rank = SIZE(coord)
    CALL assertion(ref_rank &
         == dm_array%sub_arrays_global_desc(sub_array)%a_rank, &
         __FILE__, &
         __LINE__, "rank mismatch in array reference")
    CALL assertion(is_contained_in(coord, &
         dm_array%sub_arrays_global_desc(sub_array)%rect(1:ref_rank)), &
         __FILE__, &
         __LINE__, "invalid coordinate")
    call mpi_type_get_extent(&
         dm_array%sub_arrays_global_desc(sub_array)%element_dt, &
         lb, extent, ierror)
    CALL handle_mpi_error(ierror, dm_array%comm, __LINE__)
    CALL assertion(extent == mp_sp_extent, &
         __FILE__, &
         __LINE__, "extent mismatch")
    comm_rank = dm_array%comm_rank
    comm_size = dm_array%comm_size
    max_dist = (comm_size + 1)/2
    cache_idx = -1
    DO dist = 0, max_dist
      IF (is_contained_in(coord, dm_array%local_chunks(1:ref_rank, sub_array, &
           MOD(comm_rank + dist, comm_size)))) THEN
        cache_idx = dist_mult_array_cache_rank(dm_array, &
             MOD(comm_rank + dist, comm_size))
        EXIT
      ELSE IF (is_contained_in(coord, &
           dm_array%local_chunks(1:ref_rank, sub_array, &
           MODULO(comm_rank - dist, comm_size)))) THEN
        cache_idx = dist_mult_array_cache_rank(dm_array, &
             MODULO(comm_rank - dist, comm_size))
        EXIT
      END IF
    END DO
    CALL assertion(cache_idx >= 0, &
         __FILE__, &
         __LINE__, "invalid coordinate")
    CALL dist_mult_array_get_cache_val_sp(dm_array, sub_array, &
         cache_idx, coord, v)
  END SUBROUTINE dist_mult_array_get_sp


  SUBROUTINE dist_mult_array_get_cache_val_dp(dm_array, sub_array_idx, &
       cache_idx, coord, v)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx, cache_idx
    INTEGER, INTENT(in) :: coord(:)
    REAL(dp), INTENT(out) :: v

    REAL(dp), POINTER :: p1(:), &
         &         p2(:,:), &
         &         p3(:,:,:), &
         &         p4(:,:,:,:), &
         &         p5(:,:,:,:,:), &
         &         p6(:,:,:,:,:,:), &
         &         p7(:,:,:,:,:,:,:)

    SELECT CASE (SIZE(coord))

    CASE (1)
      CALL dist_mult_array_cache_chunk_ptr_dp_1d(dm_array, sub_array_idx, &
           cache_idx, p1)
      v = p1(coord(1))
    CASE (2)
      CALL dist_mult_array_cache_chunk_ptr_dp_2d(dm_array, sub_array_idx, &
           cache_idx, p2)
      v = p2(coord(1),coord(2))
    CASE (3)
      CALL dist_mult_array_cache_chunk_ptr_dp_3d(dm_array, sub_array_idx, &
           cache_idx, p3)
      v = p3(coord(1),coord(2),coord(3))
    CASE (4)
      CALL dist_mult_array_cache_chunk_ptr_dp_4d(dm_array, sub_array_idx, &
           cache_idx, p4)
      v = p4(coord(1),coord(2),coord(3),coord(4))
    CASE (5)
      CALL dist_mult_array_cache_chunk_ptr_dp_5d(dm_array, sub_array_idx, &
           cache_idx, p5)
      v = p5(coord(1),coord(2),coord(3),coord(4),coord(5))
    CASE (6)
      CALL dist_mult_array_cache_chunk_ptr_dp_6d(dm_array, sub_array_idx, &
           cache_idx, p6)
      v = p6(coord(1),coord(2),coord(3),coord(4),coord(5),coord(6))
    CASE (7)
      CALL dist_mult_array_cache_chunk_ptr_dp_7d(dm_array, sub_array_idx, &
           cache_idx, p7)
      v = p7(coord(1),coord(2),coord(3),coord(4),coord(5),coord(6),coord(7))
    CASE default
      CALL abort_ppm("invalid array rank", &
           __FILE__, &
           __LINE__, dm_array%comm)
    END SELECT
  END SUBROUTINE dist_mult_array_get_cache_val_dp


  SUBROUTINE dist_mult_array_cache_chunk_ptr_dp_1d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    REAL(dp), POINTER :: sub_array_ptr(:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(1)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:1, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_dp_1d

  SUBROUTINE dist_mult_array_local_ptr_dp_1d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    REAL(dp), POINTER :: sub_array_ptr(:)

    CALL dist_mult_array_cache_chunk_ptr_dp_1d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_dp_1d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_dp_2d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    REAL(dp), POINTER :: sub_array_ptr(:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(2)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:2, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_dp_2d

  SUBROUTINE dist_mult_array_local_ptr_dp_2d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    REAL(dp), POINTER :: sub_array_ptr(:,:)

    CALL dist_mult_array_cache_chunk_ptr_dp_2d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_dp_2d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_dp_3d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    REAL(dp), POINTER :: sub_array_ptr(:,:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(3)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:3, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(3, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_dp_3d

  SUBROUTINE dist_mult_array_local_ptr_dp_3d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    REAL(dp), POINTER :: sub_array_ptr(:,:,:)

    CALL dist_mult_array_cache_chunk_ptr_dp_3d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_dp_3d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_dp_4d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    REAL(dp), POINTER :: sub_array_ptr(:,:,:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(4)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:4, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(3, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(4, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_dp_4d

  SUBROUTINE dist_mult_array_local_ptr_dp_4d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    REAL(dp), POINTER :: sub_array_ptr(:,:,:,:)

    CALL dist_mult_array_cache_chunk_ptr_dp_4d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_dp_4d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_dp_5d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    REAL(dp), POINTER :: sub_array_ptr(:,:,:,:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(5)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:5, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(3, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(4, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(5, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_dp_5d

  SUBROUTINE dist_mult_array_local_ptr_dp_5d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    REAL(dp), POINTER :: sub_array_ptr(:,:,:,:,:)

    CALL dist_mult_array_cache_chunk_ptr_dp_5d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_dp_5d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_dp_6d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    REAL(dp), POINTER :: sub_array_ptr(:,:,:,:,:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(6)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:6, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(3, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(4, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(5, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(6, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_dp_6d

  SUBROUTINE dist_mult_array_local_ptr_dp_6d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    REAL(dp), POINTER :: sub_array_ptr(:,:,:,:,:,:)

    CALL dist_mult_array_cache_chunk_ptr_dp_6d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_dp_6d

  SUBROUTINE dist_mult_array_cache_chunk_ptr_dp_7d(dm_array, sub_array_idx, &
       cache_idx, sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    INTEGER, INTENT(in) :: cache_idx
    REAL(dp), POINTER :: sub_array_ptr(:,:,:,:,:,:,:)
    TYPE(c_ptr) :: a_ptr
    INTEGER :: res_shape(7)
    ! such a check as follows would be nice here, but is impossible with
    ! current mpi standard
    ! CALL assertion(dm_array%sub_arrays_global_desc(sub_array_idx)%element_dt &
    !      == mp_i4, &
    !      __FILE__, &
    !      __LINE__, "invalid data type")
    res_shape = extent_shape(dm_array%local_chunks(1:7, sub_array_idx, &
         dm_array%cache(cache_idx)%rank))
    CALL dist_mult_array_cache_chunk_ptr_c(dm_array, sub_array_idx, &
         cache_idx, a_ptr)
    CALL C_F_POINTER(a_ptr, sub_array_ptr, res_shape)
    sub_array_ptr(extent_start(dm_array%local_chunks(1, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(2, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(3, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(4, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(5, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(6, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):, &
         &        extent_start(dm_array%local_chunks(7, sub_array_idx, &
         &                          dm_array%cache(cache_idx)%rank)):) &
         => sub_array_ptr
  END SUBROUTINE dist_mult_array_cache_chunk_ptr_dp_7d

  SUBROUTINE dist_mult_array_local_ptr_dp_7d(dm_array, sub_array_idx, &
       sub_array_ptr)
    TYPE(dist_mult_array), INTENT(in) :: dm_array
    INTEGER, INTENT(in) :: sub_array_idx
    REAL(dp), POINTER :: sub_array_ptr(:,:,:,:,:,:,:)

    CALL dist_mult_array_cache_chunk_ptr_dp_7d(dm_array, sub_array_idx, 0, &
         sub_array_ptr)
  END SUBROUTINE dist_mult_array_local_ptr_dp_7d

  SUBROUTINE dist_mult_array_get_dp(dm_array, sub_array, coord, v)
    TYPE(dist_mult_array), INTENT(inout) :: dm_array
    INTEGER, INTENT(in) :: sub_array
    INTEGER, INTENT(in) :: coord(:)
    REAL(dp), INTENT(out) :: v

    INTEGER :: ref_rank, dist, comm_rank, comm_size, max_dist
    INTEGER :: cache_idx, ierror
    INTEGER(mpi_address_kind) :: lb, extent

    CALL assertion(sub_array >= 1 &
         .AND. sub_array <= SIZE(dm_array%sub_arrays_global_desc), &
         __FILE__, &
         __LINE__, "invalid subarray index")
    ref_rank = SIZE(coord)
    CALL assertion(ref_rank &
         == dm_array%sub_arrays_global_desc(sub_array)%a_rank, &
         __FILE__, &
         __LINE__, "rank mismatch in array reference")
    CALL assertion(is_contained_in(coord, &
         dm_array%sub_arrays_global_desc(sub_array)%rect(1:ref_rank)), &
         __FILE__, &
         __LINE__, "invalid coordinate")
    call mpi_type_get_extent(&
         dm_array%sub_arrays_global_desc(sub_array)%element_dt, &
         lb, extent, ierror)
    CALL handle_mpi_error(ierror, dm_array%comm, __LINE__)
    CALL assertion(extent == mp_dp_extent, &
         __FILE__, &
         __LINE__, "extent mismatch")
    comm_rank = dm_array%comm_rank
    comm_size = dm_array%comm_size
    max_dist = (comm_size + 1)/2
    cache_idx = -1
    DO dist = 0, max_dist
      IF (is_contained_in(coord, dm_array%local_chunks(1:ref_rank, sub_array, &
           MOD(comm_rank + dist, comm_size)))) THEN
        cache_idx = dist_mult_array_cache_rank(dm_array, &
             MOD(comm_rank + dist, comm_size))
        EXIT
      ELSE IF (is_contained_in(coord, &
           dm_array%local_chunks(1:ref_rank, sub_array, &
           MODULO(comm_rank - dist, comm_size)))) THEN
        cache_idx = dist_mult_array_cache_rank(dm_array, &
             MODULO(comm_rank - dist, comm_size))
        EXIT
      END IF
    END DO
    CALL assertion(cache_idx >= 0, &
         __FILE__, &
         __LINE__, "invalid coordinate")
    CALL dist_mult_array_get_cache_val_dp(dm_array, sub_array, &
         cache_idx, coord, v)
  END SUBROUTINE dist_mult_array_get_dp


  SUBROUTINE handle_mpi_error(ierror, comm, line)
    INTEGER, INTENT(in) :: ierror, comm, line
    CHARACTER(256), SAVE :: source = &
__FILE__
    INTEGER :: msg_len, ierror_
    CHARACTER(len=mpi_max_error_string) :: msg

    IF (ierror /= MPI_SUCCESS) THEN
      CALL mpi_error_string(ierror, msg, msg_len, ierror_)
      CALL abort_ppm(msg(1:msg_len), TRIM(source), line, comm)
    END IF
  END SUBROUTINE handle_mpi_error

  SUBROUTINE assertion(cond, source, line, msg)
    LOGICAL, INTENT(in) :: cond
    CHARACTER(*), INTENT(in) :: source, msg
    INTEGER, INTENT(in) :: line
    IF (.NOT. cond) THEN
      CALL abort_ppm("assertion "//msg//" failed", source, line, mpi_comm_world)
    END IF
  END SUBROUTINE assertion

  SUBROUTINE abort_ppm(msg, source, line, comm)
    USE mo_mpi, ONLY: abort_mpi
    CHARACTER(*), INTENT(in) :: source, msg
    INTEGER, INTENT(in) :: line, comm
    WRITE(0, *) msg, "problem detected at", source, ":", line
    CALL abort_mpi
  END SUBROUTINE abort_ppm

END MODULE ppm_distributed_array
#endif
!
! Local Variables:
! license-project-url: "https://www.dkrz.de/redmine/projects/scales-ppm"
! mode: f90
! license-default: "bsd"
! license-markup: "doxygen"
! End:
!
