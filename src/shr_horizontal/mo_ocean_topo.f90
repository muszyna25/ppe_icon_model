!>
!!               The module <i>mo_ocean_topo</i>.
!!
!!               The module <i>mo_ocean_topo</i>
!! provides functionality to import information about the models computational
!! domain. This information is read from several files that were generated by
!! the patch generator programm. The data types describing the model domain are
!! contained in <i>mo_model_domain</i>.
!!
!! @par Revision History
!! Initial version  by: Peter Korn,  MPI-M, Hamburg, June 2005
!! Modification by Thomas Heinze (2006-02-21):
!! - renamed m_modules to mo_modules
!! Modification by Thomas Heinze (2006-09-20):
!! - added routine grid_and_patch_diagnosis
!! Modification by Pilar Ripodas, DWD, (2007-01-31)
!! - addapted to the new TYPE grid_edges (system_orientation added)
!! Modification by Peter Korn,  MPI-M, (2006-12)
!! - implementation of topography and boundary treatment, i.e.
!!   initialization of the grid & patch components that carry
!!   information about topography and the lateral boundaries of
!!   the domain; this is not related to patch boundaries.
!!   topography can either be computed by analytical l,eans or
!!   by reading from database files.
!! Modification by Hui Wan, MPI-M, (2007-02-23)
!! - Subroutine <i>init_import</i> was changed to <i>setup_grid</i>.
!!   Namelist hierarchy_ini was renamed to <i>grid_ctl</i>, moved
!!   from <i>mo_io_utilities</i> to this module and now read from
!!   an external file in subroutine <i>setup_grid</i>.
!! - Some changes in <i>init_ocean_patch_component</i> after
!!   discussion with Peter.
!! - Calculation of the min. primal edge length was added to
!!   <i>import_patches</i>. However, shouldn't it be an array with
!!   one element for each patch, rather than a scalar?
!! Modification by P. Ripodas, DWD, (2007-03-14):
!! - Now the output of "import_patches" is the min_dual_edge_lenght
!!   instead of the min_primal_edge_lenght. It will be used to set
!!   the horizontal diffusion parameter. Now it is done as it was
!!   in the prototype.
!! Modification by Almut Gassmann, MPI-M (2007-04)
!! - removed loptimize to make compatible with new grid generator
!! - removed itoa for good programming style
!! - reorganized patch input to be compatible with the new patch generator
!! - cleaning up "destruct_patches"
!! Modification by Almut Gassmann, MPI-M (2007-04-13)
!! - remove grid type and perform related adaptations
!!   (grid information comes now inside a patch)
!! - changed subroutine name form setup_grid to setup_files
!! Modified by Hui Wan, MPI-M, (2008-04-04)
!!  - control variable loce renamed locean
!!  - topography_file_dir renamed topo_file_dir
!!  - for the hydro_atmos, control variable testtype renamed ctest_name.
!! Modified by Almut Gassmann, MPI-M, (2008-04-23)
!!  - itopo distinguishes now shallow water (itopo=1) orography function
!!    from hydro_atmos orography function (itopo=2)
!! Modification by Jochen Foerstner, DWD, (2008-07-16)
!!  - new fields in the derived type for the edges:
!!    grid_edges%primal_cart_normal (Cartesian normal to edge),
!!    grid_edges%quad_idx, grid_edges%quad_area and grid_edges%quad_orientation
!!    (indices of edges and area of the quadrilateral formed by two adjacent cells)
!!    up to now these new fields are initialized in the new routines
!!    calculate_primal_cart_normal and init_quad_twoadjcells
!!    rather than read from a grid/patch file.
!! Modification by Almut Gassmann, MPI-M, (2008-09-21)
!!  - remove reference to mask and height files, they are never used
!!  - use cell_type to distinguish cells as triangles or hexagons
!! Modification by Almut Gassmann, MPI-M (2008-10-30)
!!  - add subroutine init_coriolis to initialize Coriolis parameter
!! Modification by Stephan Lorenz, MPI-M (2010-02-06)
!!  - add subroutines to init and read patch_oce for ocean component
!! Modification by Peter Korn, MPI-M, (2010-05-31)
!!  - fill new data types for patch_ocean for reconstruction process
!!  - routine <i>init_ocean_patch_component</i> deleted, use <i>init_ocean_patch</i>
!! Modification by Stephan Lorenz, MPI-M (2010-06-09)
!!  - add calculation of inv_dual_edge_length from intp_coeff for operator use
!! Modification by Stephan Lorenz, MPI-M (2010-10-26)
!!  - add calculations for data structures in patch_ocean for new "PtP" reconstructions
!! Modification by Stephan Lorenz, MPI-M (2010-11-02)
!!  - sbrts using "PtP" structures are moved to new module mo_scalar_product
!!
!! @par Copyright
!! 2002-2007 by DWD and MPI-M
!! This software is provided for non-commercial use only.
!! See the LICENSE and the WARRANTY conditions.
!!
!! @par License
!! The use of ICON is hereby granted free of charge for an unlimited time,
!! provided the following rules are accepted and applied:
!! <ol>
!! <li> You may use or modify this code for your own non commercial and non
!!    violent purposes.
!! <li> The code may not be re-distributed without the consent of the authors.
!! <li> The copyright notice and statement of authorship must appear in all
!!    copies.
!! <li> You accept the warranty conditions (see WARRANTY).
!! <li> In case you intend to use the code commercially, we oblige you to sign
!!    an according license agreement with DWD and MPI-M.
!! </ol>
!!
!! @par Warranty
!! This code has been tested up to a certain level. Defects and weaknesses,
!! which may be included in the code, do not establish any warranties by the
!! authors.
!! The authors do not make any warranty, express or implied, or assume any
!! liability or responsibility for the use, acquisition or application of this
!! software.
!!
!!
MODULE mo_ocean_topo
!-------------------------------------------------------------------------
!
!    ProTeX FORTRAN source: Style 2
!    modified for ICON project, DWD/MPI-M 2006
!
!-------------------------------------------------------------------------
!
!
!

USE mo_kind,               ONLY: wp
USE mo_io_units,           ONLY: filename_max!, nerr
USE mo_impl_constants,     ONLY: land, land_boundary, boundary, sea_boundary, sea,  &
  &                              success, max_char_length,                          &
  &                              min_rlcell, min_rledge, min_rlvert,                &
  &                              full_coriolis, beta_plane_coriolis,                &
  &                              f_plane_coriolis, zero_coriolis
USE mo_exception,          ONLY: message_text, message, finish
USE mo_model_domain,       ONLY: t_patch
USE mo_ocean_nml,          ONLY: n_zlev, dzlev_m, CORIOLIS_TYPE, basin_center_lat, basin_height_deg
USE mo_parallel_configuration,  ONLY: nproma
USE mo_math_utilities,     ONLY: gc2cc,cc2gc,       &
  &                              t_geographical_coordinates, t_cartesian_coordinates,   &
  &                              vector_product, arc_length
USE mo_math_constants,     ONLY: pi, deg2rad
USE mo_physical_constants, ONLY: re, omega!, rgrav
USE mo_loopindices,        ONLY: get_indices_c, get_indices_e, get_indices_v
USE mo_model_domimp_setup, ONLY: reshape_int, reshape_real
! USE mo_grid_nml,           ONLY: nroot

IMPLICIT NONE

PRIVATE

! required for testing/reading topography
INCLUDE 'netcdf.inc'

CHARACTER(len=*), PARAMETER :: version = '$Id$'

PUBLIC :: init_ocean_patch
PRIVATE :: init_scalar_product
PRIVATE :: calc_geo_factors
PRIVATE :: init_coriolis
TYPE(t_patch), POINTER :: ptr_patch ! patch on specific level
!-------------------------------------------------------------------------

CONTAINS



  !-------------------------------------------------------------------------
  !
  !
  !>
  !! Initializes parts of the general patch used for the ocean component.
  !! (Initializes extensions of patch used for the ocean component.)
  !!
  !! @par Revision History
  !! Initial release by Stephan Lorenz, MPI-M (2010-02)
  !! - developed from init_ocean_patch_component that is no longer used
  !!
  SUBROUTINE init_ocean_patch( p_patch )

    TYPE(t_patch), POINTER :: p_patch

    CHARACTER(len=MAX_CHAR_LENGTH), PARAMETER :: &
    &        routine = 'mo_ocean_topo:init_ocean_patch'

    INTEGER :: nblks_c, nblks_e, nblks_v, n_zlvp, n_zlvm, ie

    INTEGER :: ist  ! status variable

    !-----------------------------------------------------------------------
    ptr_patch => p_patch

    CALL message (TRIM(routine), 'start')

    !
    ! Allocation of topographically related elements - bathymetry and land-sea-mask
    !

    ! values for the blocking
    nblks_c = ptr_patch%nblks_c
    nblks_e = ptr_patch%nblks_e
    nblks_v = ptr_patch%nblks_v

    ! number of vertical levels from the namelist in mo_global_variables
    n_zlvp = n_zlev + 1
    n_zlvm = n_zlev - 1
    ptr_patch%patch_oce%n_zlev = n_zlev
    ptr_patch%patch_oce%n_zlvp = n_zlvp
    ptr_patch%patch_oce%n_zlvm = n_zlvm

    ! allocate and set vertical level thickness from the namelist
    ALLOCATE(ptr_patch%patch_oce%del_zlev_m(n_zlev),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating del_zlev_m failed')
    ENDIF
    ptr_patch%patch_oce%del_zlev_m(:) = dzlev_m(1:n_zlev)

    ! Output now in fill_vertical_ocean_domain only
    !WRITE(message_text,'(a)') 'Vertical level thicknesses of elemental prisms read from namelist:'
    !CALL message( TRIM(routine),TRIM(message_text))
    !132 chars only
    !WRITE(message_text,'(10f8.1)') dzlev_m(1:n_zlev)
    !CALL message('', TRIM(message_text))
    !WRITE(nerr,'(10f8.1)') dzlev_m(1:n_zlev)

    ! allocate vertical domain
    ALLOCATE(ptr_patch%patch_oce%zlev_m(n_zlev),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating zlev_m failed')
    ENDIF
    ALLOCATE(ptr_patch%patch_oce%zlev_i(n_zlvp),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating zlev_i failed')
    ENDIF
    ALLOCATE(ptr_patch%patch_oce%del_zlev_i(n_zlev),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating del_zlev_i failed')
    ENDIF

    !
    !! bathymetric depth at cells, edges and vertices
    !
    ! cells
    ALLOCATE(ptr_patch%patch_oce%bathymetry_c(nproma,nblks_c),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating bathymetry_c failed')
    ENDIF
    ! edges
    ALLOCATE(ptr_patch%patch_oce%bathymetry_e(nproma,nblks_e),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating bathymetry_e failed')
    ENDIF
    ! vertices - not needed for ocean
!   ALLOCATE(ptr_patch%patch_oce%bathymetry_v(nproma,nblks_v),STAT=ist)
!   IF (ist /= SUCCESS) THEN
!     CALL finish (routine,'allocating bathymetry_v failed')
!   ENDIF

    !
    !! 3-dim land-sea-mask at cells, edges and vertices
    !
    ! cells
    ALLOCATE(ptr_patch%patch_oce%lsm_oce_c(nproma,n_zlev,nblks_c),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating lsm_oce_c failed')
    ENDIF
    ! edges
    ALLOCATE(ptr_patch%patch_oce%lsm_oce_e(nproma,n_zlev,nblks_e),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating lsm_oce_e failed')
    ENDIF
    ! deepest ocean layer in column
    ALLOCATE(ptr_patch%patch_oce%dolic_c(nproma,nblks_c),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating dolic_c failed')
    ENDIF
    ALLOCATE(ptr_patch%patch_oce%dolic_e(nproma,nblks_e),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating dolic_e failed')
    ENDIF
    ! 3-dim real land-sea-mask
    ! cells
    ALLOCATE(ptr_patch%patch_oce%wet_c(nproma,n_zlev,nblks_c),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating wet_c failed')
    ENDIF
    ! edges
    ALLOCATE(ptr_patch%patch_oce%wet_e(nproma,n_zlev,nblks_e),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating wet_e failed')
    ENDIF
    ! intermediate vertical velocity layers
    !ALLOCATE(ptr_patch%patch_oce%wet_i(nproma,n_zlvp,nblks_c),STAT=ist)
    !IF (ist /= SUCCESS) THEN
    !  CALL finish (routine,'allocating wet_i failed')
    !ENDIF

    ! arrays that are required for #slo OLD# reconstruction
!     ALLOCATE(ptr_patch%patch_oce%cell2edge_vec(nproma,nblks_c,1:3),STAT=ist)
!      IF (ist /= SUCCESS) THEN
!        CALL finish (routine,'allocating cell2edge_vec failed')
!      ENDIF
!      ALLOCATE(ptr_patch%patch_oce%cell2edge_weight(nproma,nblks_c,1:3),STAT=ist)
!      IF (ist /= SUCCESS) THEN
!        CALL finish (routine,'allocating cell2edge_weight failed')
!      ENDIF
!      ALLOCATE(ptr_patch%patch_oce%vertex2dualedge_mid_vec(nproma,nblks_v,1:6),STAT=ist)
!      IF (ist /= SUCCESS) THEN
!        CALL finish (routine,'allocating vertex2dualedge_mid_vec failed')
!      ENDIF
!      ALLOCATE(ptr_patch%patch_oce%vertex2dualedge_mid_weight(nproma,nblks_v,1:6),STAT=ist)
!      IF (ist /= SUCCESS) THEN
!        CALL finish (routine,'allocating vertex2dualedge_mid_weight failed')
!      ENDIF
!      ALLOCATE(ptr_patch%patch_oce%mid_dual_edge(nproma,nblks_e),STAT=ist)
!      IF (ist /= SUCCESS) THEN
!        CALL finish (routine,'allocating mid_dual_edge failed')
!      ENDIF
     ALLOCATE(ptr_patch%patch_oce%dist_cell2edge(nproma,nblks_e,2),STAT=ist)
     IF (ist /= SUCCESS) THEN
       CALL finish (routine,'allocating dist_cell2edge failed')
     ENDIF

    ! arrays that are required for setting up the scalar product
    !
    !coefficients for edge to cell mapping, one half of the scalar product.
    !Dimension: nproma,nblks_c encode number of cells, 1:3 corresponds to number
    !of edges per cell, 1:2 is for u and v component of cell vector
!     ALLOCATE(ptr_patch%patch_oce%edge2cell_coeff(nproma,nblks_c,1:3, 1:2),STAT=ist)
!     IF (ist /= SUCCESS) THEN
!       CALL finish (routine,'allocating edge2cell_coeff failed')
!     ENDIF
    ALLOCATE(ptr_patch%patch_oce%edge2cell_coeff_cc(nproma,nblks_c,1:3),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating edge2cell_coeff_cc failed')
    ENDIF

    !coefficients for transposed of edge to cell mapping, second half of the scalar product.
    !Dimension: nproma,nblks_e encode number of edges, 1:2 is for cell neighbors of an edge
    ALLOCATE(ptr_patch%patch_oce%edge2cell_coeff_cc_t(nproma,nblks_e,1:2),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating transposed edge2cell_coeff failed')
    ENDIF
    !coefficients for edge to vertex mapping.
    !Dimension: nproma,nblks_v encode number of vertices, 1:6 is number of edges of a vertex,
    !1:2 is for u and v component of vertex vector
!     ALLOCATE(ptr_patch%patch_oce%edge2vert_coeff(nproma,nblks_v,1:6,1:2),STAT=ist)
!     IF (ist /= SUCCESS) THEN
!       CALL finish (routine,'allocating edge2vert_coeff failed')
!     ENDIF

    ALLOCATE(ptr_patch%patch_oce%edge2vert_coeff_cc(nproma,nblks_v,1:6),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating edge2vert_coeff failed')
    ENDIF

    ALLOCATE(ptr_patch%patch_oce%edge2vert_coeff_cc_t(nproma,nblks_e,1:2),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating edge2vert_coeff failed')
    ENDIF

   ALLOCATE(ptr_patch%patch_oce%edge2vert_vector_cc(nproma,nblks_e,1:6),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating edge2vert_vector failed')
    ENDIF


    !coefficients for transposed edge to vertex mapping.
    !Dimension: nproma,nblks_e encode number of edges,
    !1:2 is number of vertex neighbors per edge
!     ALLOCATE(ptr_patch%patch_oce%edge2vert_coeff_t(nproma,nblks_e,1:2),STAT=ist)
!     IF (ist /= SUCCESS) THEN
!       CALL finish (routine,'allocating transposed edge2vert_coeff failed')
!     ENDIF
!    ALLOCATE(ptr_patch%patch_oce%edge2vert_coeff_gc_t(nproma,nblks_e,1:2),STAT=ist)
!     IF (ist /= SUCCESS) THEN
!       CALL finish (routine,'allocating transposed edge2vert_coeff failed')
!     ENDIF

    !normalizing factors for edge to cell mapping.
    !Either by fixed volume or by variable one taking the surface elevation
    !into account. The later one depends on time and space.
    ALLOCATE(ptr_patch%patch_oce%fixed_vol_norm(nproma,nblks_c),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating fixed_vol_norm failed')
    ENDIF
    ALLOCATE(ptr_patch%patch_oce%variable_vol_norm(nproma,nblks_c,1:3),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating variable_vol_norm failed')
    ENDIF

    ALLOCATE(ptr_patch%patch_oce%variable_dual_vol_norm(nproma,nblks_v,1:6),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating variable_dual_vol_norm failed')
    ENDIF


    ! Init geometrical factors
    ! This part is copied from the interpolation modules.
    ! Interpolation module is no longer used in ocean model
    ! but some of the grid related information is stored in interpolation type.

    ALLOCATE (ptr_patch%patch_oce%geofac_div(nproma, ptr_patch%cell_type, nblks_c), STAT=ist )
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocation for geofac_div failed')
    ENDIF

    ALLOCATE (ptr_patch%patch_oce%geofac_qdiv(nproma, 4, nblks_e), STAT=ist )
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocation for geofac_qdiv failed')
    ENDIF

    SELECT CASE (ptr_patch%cell_type)
    CASE(3)
      ALLOCATE (ptr_patch%patch_oce%geofac_rot(nproma, 6, nblks_v), STAT=ist )
      IF (ist /= SUCCESS) THEN
        CALL finish (routine,'allocation for geofac_rot failed')
      ENDIF
    CASE(6)
      ALLOCATE (ptr_patch%patch_oce%geofac_rot(nproma, 4, nblks_e), STAT=ist )
      IF (ist /= SUCCESS) THEN
        CALL finish (routine,'allocation for geofac_rot failed')
      ENDIF
    END SELECT
    ALLOCATE (ptr_patch%patch_oce%geofac_n2s(nproma, ptr_patch%cell_type+1, nblks_c), STAT=ist )
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocation for geofac_n2s failed')
    ENDIF

!   ALLOCATE (ptr_patch%patch_oce%geofac_grg(nproma, ptr_patch%cell_type+1, nblks_c, 2), STAT=ist )
!   IF (ist /= SUCCESS) THEN
!     CALL finish (routine,'allocation for geofac_grg failed')
!   ENDIF


    ! Initialize variables to avoid false alarms when checking parallel runs

    ptr_patch%patch_oce%bathymetry_c = 0.0_wp
    ptr_patch%patch_oce%bathymetry_e = 0.0_wp
    !ptr_patch%patch_oce%bathymetry_v = 0.0_wp

    ptr_patch%patch_oce%lsm_oce_c = 0
    ptr_patch%patch_oce%lsm_oce_e = 0
    ptr_patch%patch_oce%dolic_c = 0
    ptr_patch%patch_oce%dolic_e = 0

    ptr_patch%patch_oce%wet_c = 0.0_wp
    ptr_patch%patch_oce%wet_e = 0.0_wp
    !ptr_patch%patch_oce%wet_i = 0.0_wp

    ! #slo# - Deallocation missing
!     ptr_patch%patch_oce%edge2cell_coeff     = 0.0_wp
!     ptr_patch%patch_oce%edge2vert_coeff     = 0.0_wp
    DO ie = 1,3
      ptr_patch%patch_oce%edge2cell_coeff_cc(:,:,:)%x(ie)    = 0.0_wp
      ptr_patch%patch_oce%edge2cell_coeff_cc_t(:,:,:)%x(ie)  = 0.0_wp
      !ptr_patch%patch_oce%edge2vert_coeff_t(:,:,:)%x(ie)    = 0.0_wp
      ptr_patch%patch_oce%edge2vert_coeff_cc(:,:,:)%x(ie)    = 0.0_wp
      ptr_patch%patch_oce%edge2vert_coeff_cc_t(:,:,:)%x(ie)  = 0.0_wp
      ptr_patch%patch_oce%edge2vert_vector_cc(:,:,:)%x(ie)   = 0.0_wp
    END DO
    ptr_patch%patch_oce%fixed_vol_norm      = 0.0_wp
    ptr_patch%patch_oce%variable_vol_norm   = 0.0_wp
    ptr_patch%patch_oce%variable_dual_vol_norm = 0.0_wp

!      ptr_patch%patch_oce%cell2edge_vec%v1              = 0.0_wp
!      ptr_patch%patch_oce%cell2edge_vec%v2              = 0.0_wp
!      ptr_patch%patch_oce%cell2edge_weight%v1           = 0.0_wp
!      ptr_patch%patch_oce%cell2edge_weight%v2           = 0.0_wp
!      ptr_patch%patch_oce%vertex2dualedge_mid_vec%v1    = 0.0_wp
!      ptr_patch%patch_oce%vertex2dualedge_mid_vec%v2    = 0.0_wp
!      ptr_patch%patch_oce%vertex2dualedge_mid_weight%v1 = 0.0_wp
!      ptr_patch%patch_oce%vertex2dualedge_mid_weight%v2 = 0.0_wp
!      ptr_patch%patch_oce%mid_dual_edge%lat             = 0.0_wp
!      ptr_patch%patch_oce%mid_dual_edge%lat             = 0.0_wp
     ptr_patch%patch_oce%dist_cell2edge              = 0.0_wp

    ptr_patch%patch_oce%geofac_div                    = 0.0_wp
    ptr_patch%patch_oce%geofac_qdiv                   = 0.0_wp
    ptr_patch%patch_oce%geofac_rot                    = 0.0_wp
    ptr_patch%patch_oce%geofac_n2s                    = 0.0_wp
    !ptr_patch%patch_oce%geofac_grg                    = 0.0_wp

    !
    ! Filling ocean patch with data provided by the grid generator
    !
    CALL read_netcdf_ocean_domain( )

    !
    ! Filling the vertical domain of the ocean w.r.t. bathymetry
    !
    CALL fill_vertical_ocean_domain( )

    !
    ! Calculate reconstruction weights needed in patch_ocean
    !
    CALL init_scalar_product( ptr_patch )
    !
    ! Calculate geometrical factors used in divergence and rotation
    !
    CALL calc_geo_factors( ptr_patch )
    !
    ! Init coriolis force:perform modification if f- or beta-plane approximation
    !is cosen in namlist
    CALL init_coriolis( ptr_patch )

    CALL message (TRIM(routine), 'end')

  END SUBROUTINE init_ocean_patch
!-------------------------------------------------------------------------
  !
  !
  !>
  !! Modifies the already calculated Coriolis force, if beta-, f-plane or the nonrotating case 
  !! is selected in the namelist. The tangent plane is associated to the center of the basin that is 
  !! specified in the namelist. An alternative would be to associate it to the nearest edge/vertex, but
  !! this is not implemented yet, and i expect it to have a minor effect.
  !!
  !! The Coriolis parameter is specified for edges (needed in RBF-discretization) and at vertices (needed
  !! in mimetic discreization).
  !! The land-sea masks are not taken into account here. This would require to extend the 2D-coriolis-structure
  !! to a 3D one
  !!
  !! @par Revision History
  !!  developed by Peter Korn, 2011
  !!
  SUBROUTINE init_coriolis( ptr_patch )
    !
    IMPLICIT NONE
    !
    !
    TYPE(t_patch), TARGET, INTENT(inout) :: ptr_patch
    !
    INTEGER :: jb, je, jv
    INTEGER :: rl_start_e, rl_end_e
    INTEGER :: i_startblk_e, i_endblk_e, i_startidx_e, i_endidx_e
    INTEGER :: rl_start_v, rl_end_v
    INTEGER :: i_startblk_v, i_endblk_v, i_startidx_v, i_endidx_v
    TYPE(t_geographical_coordinates) :: gc1,gc2 
    TYPE(t_cartesian_coordinates) :: xx1, xx2
    REAL(wp) :: z_y, z_lat_basin_center
    CHARACTER(len=MAX_CHAR_LENGTH), PARAMETER :: &
    & routine = ('mo_ocean_topo:init_coriolis')
    !-----------------------------------------------------------------------
   rl_start_e = 1
   rl_end_e   = min_rledge
   rl_start_v = 1
   rl_end_v   = min_rlvert

   i_startblk_e = ptr_patch%edges%start_blk(rl_start_e,1)
   i_endblk_e   = ptr_patch%edges%end_blk(rl_end_e,1)
   i_startblk_v = ptr_patch%verts%start_blk(rl_start_v,1)
   i_endblk_v   = ptr_patch%verts%end_blk(rl_end_v,1)

    CALL message (TRIM(routine), 'start')

    SELECT CASE (CORIOLIS_TYPE)

    CASE(FULL_CORIOLIS)
      !Nothing to do: full coriolis is already set
      RETURN

    CASE(BETA_PLANE_CORIOLIS)
      z_lat_basin_center = basin_center_lat * deg2rad
      gc1%lat = basin_center_lat* deg2rad - 0.5_wp*basin_height_deg*deg2rad
      gc1%lon = 0.0_wp
      xx1=gc2cc(gc1)

     DO jb = i_startblk_v, i_endblk_v
       CALL get_indices_v(ptr_patch, jb, i_startblk_v, i_endblk_v, &
                         i_startidx_v, i_endidx_v, rl_start_v, rl_end_v)
       DO jv = i_startidx_v, i_endidx_v
           !z_y = re*(ptr_patch%verts%vertex(jv,jb)%lat - z_lat_basin_center) 
           gc2%lat = ptr_patch%verts%vertex(jv,jb)%lat*deg2rad
           gc2%lon = 0.0_wp
           xx2=gc2cc(gc2)        
           z_y = re*arc_length(xx2,xx1)
           ptr_patch%verts%f_v(jv,jb) = 2.0_wp*omega*( sin(z_lat_basin_center)     &
           &                          + (cos(z_lat_basin_center)/re)*z_y)
! write(*,*)'beta', jv,jb,z_beta_plane_vort,2.0_wp*omega*sin(z_lat_basin_center),&
! &2.0_wp*omega*((cos(z_lat_basin_center)/re)*z_y)
       END DO
     END DO


     DO jb = i_startblk_e, i_endblk_e
       CALL get_indices_e(ptr_patch, jb, i_startblk_e, i_endblk_e, &
                         i_startidx_e, i_endidx_e, rl_start_e, rl_end_e)
       DO je = i_startidx_e, i_endidx_e
         ! depends on basin_center_lat only - not dependent on center_lon, basin_width or height 
         z_y = ptr_patch%edges%center(je,jb)%lat - z_lat_basin_center
         ptr_patch%edges%f_e(je,jb) = 2.0_wp*omega*( sin(z_lat_basin_center)     &
         &                          + (cos(z_lat_basin_center)/re)*z_y)
       END DO
     END DO


    CASE(F_PLANE_CORIOLIS)

     z_lat_basin_center = basin_center_lat * deg2rad

     ptr_patch%edges%f_e  = 2.0_wp*omega*sin(z_lat_basin_center)
     ptr_patch%verts%f_v  = 2.0_wp*omega*sin(z_lat_basin_center)


   CASE(ZERO_CORIOLIS)
     ptr_patch%verts%f_v = 0.0_wp
     ptr_patch%edges%f_e = 0.0_wp
   END SELECT


    CALL message (TRIM(routine), 'end')

  END SUBROUTINE init_coriolis

  !-----------------------------------------------------------------------------
  !>
  !! Reads in ocean bathymetry and surface land-sea-mask from netcdf file
  !!
  !! Reads in bathymetric depths and surface land-sea-mask of the ocean surface
  !! on cells and edges. The data sets are provided by the grid-generator.
  !! For the case of coupling with the atmosphere, the surface land-sea-mask
  !! must be used by the atmosphere to ensure the usage of the same distribution
  !! of continents in both components.
  !!
  !! @par Revision History
  !! Initial release by Stephan Lorenz, MPI-M (2010-02-19)
  !!
  SUBROUTINE read_netcdf_ocean_domain ()


    CHARACTER(filename_max) :: ogrid_file !< file name for reading
    CHARACTER(len=MAX_CHAR_LENGTH), PARAMETER :: &
               & routine = ('mo_ocean_topo:read_netcdf_ocean_domain')
    LOGICAL :: l_exist
    INTEGER :: i_lev, no_cells, no_edges
    INTEGER :: ncid, dimid, varid, nfloc_stat
    INTEGER :: array_c_int (ptr_patch%n_patch_cells), &  ! slo: todo: set zero!
            &  array_e_int (ptr_patch%n_patch_edges)
    REAL(wp):: array_c_real(ptr_patch%n_patch_cells), &
            &  array_e_real(ptr_patch%n_patch_edges)

    INTEGER :: jc, jb, nblks_c, npromz_c, no_sbd, no_sea, no_lnd, no_lbd, nlen
    !--------------------------------------------------------------------------

    CALL message (TRIM(routine), 'start')

    i_lev = ptr_patch%level

    ! generate file name
    ogrid_file = TRIM(ptr_patch%grid_filename)
!     WRITE (ogrid_file,'(a,i0,a,i2.2,a)') 'iconR',nroot,'B',i_lev, '-grid.nc'
    CALL message("read_netcdf_ocean_domain, ogrid_file=",ogrid_file)

    INQUIRE (FILE=ogrid_file, EXIST=l_exist)
    IF (.NOT.l_exist) THEN
      CALL finish(TRIM(routine),'ocean_grid file is not found.')
    END IF

    ! open file
    CALL nf(nf_open(TRIM(ogrid_file), NF_NOWRITE, ncid))
    WRITE(message_text,'(a,a)') 'Read from ocean_grid file ', TRIM(ogrid_file)
    CALL message( TRIM(routine),TRIM(message_text))

    ! get and check number of cells and edges
    CALL nf(nf_inq_dimid(ncid, 'cell', dimid))
    CALL nf(nf_inq_dimlen(ncid, dimid, no_cells))
    CALL nf(nf_inq_dimid(ncid, 'edge', dimid))
    CALL nf(nf_inq_dimlen(ncid, dimid, no_edges))

    WRITE(message_text,'(3(a,i6))') 'No of cells =', no_cells,'  no of edges =',no_edges, &
      &                           '  no of verts =', ptr_patch%n_patch_verts
    CALL message( TRIM(routine),TRIM(message_text))

    IF(ptr_patch%n_patch_cells /= no_cells) THEN
      CALL finish(TRIM(ROUTINE),&
      & 'Number of patch cells and cells in ocean_grid file do not match.')
    ENDIF
    IF(ptr_patch%n_patch_edges /= no_edges) THEN
      CALL finish(TRIM(ROUTINE),&
      & 'Number of patch edges and edges in ocean_grid file do not match.')
    ENDIF
    ! These arrays are not included in standard icon-grid, but they are
    ! created by "create_ocean_grid"

    ! get land-sea-mask on cells, integer marks are:
    ! inner sea (-2), boundary sea (-1, cells and vertices), boundary (0, edges),
    ! boundary land (1, cells and vertices), inner land (2)
    nfloc_stat = nf_inq_varid(ncid, 'cell_sea_land_mask', varid)
    IF (nfloc_stat == nf_noerr ) THEN
      CALL nf(nf_get_var_int(ncid, varid, array_c_int(:)))
      CALL reshape_int ( array_c_int (:), ptr_patch%nblks_c, ptr_patch%npromz_c, &
        &                ptr_patch%patch_oce%lsm_oce_c(:,1,:) )
    ELSE
      CALL message( TRIM(routine),'WARNING: no land-sea-mask for ocean cells read')
      ! set land-sea-mask to sea
      ptr_patch%patch_oce%lsm_oce_c(:,1,:) = -2
    END IF

    no_sbd = 0
    no_sea = 0
    no_lnd = 0
    no_lbd = 0
    nblks_c  = ptr_patch%nblks_int_c
    npromz_c = ptr_patch%npromz_int_c
    DO jb = 1, nblks_c
      IF (jb /= nblks_c) THEN
        nlen = nproma
      ELSE
        nlen = npromz_c
      ENDIF
      DO jc = 1, nlen
        IF (ptr_patch%patch_oce%lsm_oce_c(jc,1,jb) == -2) no_sea = no_sea+1
        IF (ptr_patch%patch_oce%lsm_oce_c(jc,1,jb) == -1) no_sbd = no_sbd+1
        IF (ptr_patch%patch_oce%lsm_oce_c(jc,1,jb) ==  1) no_lbd = no_lbd+1
        IF (ptr_patch%patch_oce%lsm_oce_c(jc,1,jb) ==  2) no_lnd = no_lnd+1
      END DO
    END DO

    WRITE(message_text,'(4(a,i6))') 'sea_boundary=', no_sbd,'  inner_sea   =',no_sea, &
      &                           '  inner_land  =', no_lnd,'  lnd_boundary=',no_lbd
    CALL message( TRIM(routine),TRIM(message_text))

    ! get land-sea-mask on edges
    nfloc_stat = nf_inq_varid(ncid, 'edge_sea_land_mask', varid)
    IF (nfloc_stat == nf_noerr ) THEN
      CALL nf(nf_get_var_int(ncid, varid, array_e_int(:)))
      CALL reshape_int ( array_e_int (:), ptr_patch%nblks_e, ptr_patch%npromz_e, &
        &                ptr_patch%patch_oce%lsm_oce_e(:,1,:) )
    ELSE
      CALL message( TRIM(routine),'WARNING: no land-sea-mask for ocean edges read')
      ! set land-sea-mask to sea
      ptr_patch%patch_oce%lsm_oce_e(:,1,:) = -2
    END IF

    ! get bathymetry (elevation) at cells - negative for ocean bathymetry
    nfloc_stat = nf_inq_varid(ncid, 'cell_elevation', varid)
    IF (nfloc_stat == nf_noerr ) THEN
      CALL nf(nf_get_var_double(ncid, varid, array_c_real(:)))
      CALL reshape_real( array_c_real(:), ptr_patch%nblks_c, ptr_patch%npromz_c, &
        &                ptr_patch%patch_oce%bathymetry_c )
    ELSE
      CALL message( TRIM(routine),'WARNING: no bathymetry for ocean cells read')
      ! set bathymetry to constant value
      ptr_patch%patch_oce%bathymetry_c(:,:) = -3000.0_wp
    END IF

    ! get bathymetry (elevation) at edges - negative for ocean bathymetry
    nfloc_stat = nf_inq_varid(ncid, 'edge_elevation', varid)
    IF (nfloc_stat == nf_noerr ) THEN
      CALL nf(nf_get_var_double(ncid, varid, array_e_real(:)))
      CALL reshape_real( array_e_real(:), ptr_patch%nblks_e, ptr_patch%npromz_e, &
        &                ptr_patch%patch_oce%bathymetry_e )
    ELSE
      CALL message( TRIM(routine),'WARNING: no bathymetry for ocean edges read')
      ! set bathymetry to constant value
      ptr_patch%patch_oce%bathymetry_e(:,:) = -3000.0_wp
    END IF

  END SUBROUTINE read_netcdf_ocean_domain

  !-----------------------------------------------------------------------------
  !>
  !! Fill 3-dimensional land-sea-mask vertically using ocean bathymetry
  !!
  !! Calculates the vertical grid levels in z (meter) using the thickness of the elemental
  !! prisms (del_zlev_i) that are read from the ocean namelist.
  !!
  !! The 3-dim land-sea-mask is filled with values for interieur ocean, boundary
  !! ocean, and land, where parameter values from mo_impl_constants are used. The three
  !! dimensions are two for the nproma-blocking  and the middle one for the vertical levels.
  !!
  !! @par Revision History
  !! Initial release by Stephan Lorenz, MPI-M (2010-02-19)
  !! Modified by Stephan Lorenz,        MPI-M (2010-08)
  !!  - fill dolic and sea_boundary as well
  !! Modified by Stephan Lorenz,        MPI-M (2011-05)
  !!  - level below surface receives same land-sea-mask
  !!
  SUBROUTINE fill_vertical_ocean_domain ()


    CHARACTER(len=MAX_CHAR_LENGTH), PARAMETER :: &
    & routine = ('mo_ocean_topo:fill_vertical_ocean_domain')

    INTEGER :: jb, jc, je, jk, ji, nblks_c, nblks_e, npromz_c, npromz_e
    INTEGER :: rl_start, rl_end, i_startblk, i_endblk, i_startidx, i_endidx
    INTEGER :: n_zlvp, noct1_c, noct1_e, noctb_e, nocsb_c, noclb_c, inolsm
    INTEGER :: nolnd_c(n_zlev), nosea_c(n_zlev), nogllnd_c, noglsea_c
    INTEGER :: nolnd_e(n_zlev), nosea_e(n_zlev), nogllnd_e, noglsea_e
    INTEGER :: nobnd_e(n_zlev), nosbd_c(n_zlev), nolbd_c(n_zlev)
    INTEGER :: noglbnd_e, noglsbd_c, nogllbd_c
    INTEGER :: iic1, ibc1, iic2, ibc2, idxe, ible

    REAL(wp):: perc_lnd_c(n_zlev), perc_gllnd_c
    REAL(wp):: perc_lnd_e(n_zlev), perc_gllnd_e

    !-----------------------------------------------------------------------------

    CALL message (TRIM(routine), 'start')

    !-----------------------------
    !
    ! Basic z-level configuration:
    !
    ! n_zlev    : number of z-coordinate surfaces - module global_variables, read in from namelist
    ! del_zlev_m: thickness of elemental prism - read in from namelist
    ! zlev_m    : position of coordinate surfaces in meters below zero surface
    ! zlev_i    : surface at the top of the respective z-coordinate surface (intermediate level)
    ! del_zlev_i: distance between two z-coordinate surfaces
    !
    !-----------------------------

!   WRITE(message_text,'(a,i4)') ' n_zlev =', n_zlev
!   CALL message( TRIM(routine),TRIM(message_text))

    ptr_patch%patch_oce%zlev_m(1) = 0.5_wp * ptr_patch%patch_oce%del_zlev_m(1)
    ptr_patch%patch_oce%zlev_i(1) = 0.0_wp

    ! zlev_i    : surface in the middle of two z-coordinate surfaces: n_zlev+1 levels
    DO jk = 2, n_zlev+1
      ptr_patch%patch_oce%zlev_i(jk) = ptr_patch%patch_oce%zlev_i(jk-1) + &
        &                            ptr_patch%patch_oce%del_zlev_m(jk-1)
    END DO

    ! zlev_m    : position of coordinate surfaces in meters below zero surface.
    DO jk = 2, n_zlev
      ptr_patch%patch_oce%zlev_m(jk) = 0.5_wp * ( ptr_patch%patch_oce%zlev_i(jk+1) + &
        &                                      ptr_patch%patch_oce%zlev_i(jk)  )
    END DO

    ! del_zlev_i: distance between two z-coordinate surfaces.
    !             The first is the distance from the ocean surface = zlev_m(1)
    ptr_patch%patch_oce%del_zlev_i(1) = ptr_patch%patch_oce%zlev_m(1)
    DO jk = 2, n_zlev
      ptr_patch%patch_oce%del_zlev_i(jk) = ptr_patch%patch_oce%zlev_m(jk) - &
        &                                ptr_patch%patch_oce%zlev_m(jk-1)
    END DO


    !-----------------------------
    !
    ! Fill the 3-dim land-sea-mask and number of deepest ocean layer in column 'dolic'
    !
    !  - 2011-04-01: missing condition that at least one layer below the surface layer exists
    !    which would be an analogon to the smoothing condition in grid.create_ocean_grid
    !    (at least 2 neighbours of a sea-cell must be a sea-cell as well, only 1 can be land)
    !                
    !
    !-----------------------------

    ! values for the blocking
    nblks_c = ptr_patch%nblks_c
    npromz_c = ptr_patch%npromz_c
    nblks_e = ptr_patch%nblks_e
    npromz_e = ptr_patch%npromz_e
    nogllnd_c = 0
    noglsea_c = 0
    nogllnd_e = 0
    noglsea_e = 0
    noglbnd_e = 0
    noglsbd_c = 0
    nogllbd_c = 0
    noct1_c = 0
    noct1_e = 0
    noctb_e = 0
    nocsb_c = 0
    noclb_c = 0

   !jk=0
   !do jc=1,nproma
   !do jb=1,nblks_c
   !IF ( ptr_patch%patch_oce%lsm_oce_c(jc,1,jb) == sea_boundary ) then
   !  jk=jk+1
   !  write(*,*) jk,'lsm_c, blk,idx : ',ptr_patch%patch_oce%lsm_oce_c(jc,1,jb),jb,jc
   !END IF
   !enddo
   !enddo

   !jk=0
   !do je=1,nproma
   !do jb=1,nblks_e
   !IF ( ptr_patch%patch_oce%lsm_oce_e(je,1,jb) == boundary ) then
   !  jk=jk+1
   !  write(*,*) jk,'lsm_e, blk,idx : ',ptr_patch%patch_oce%lsm_oce_e(je,1,jb),jb,je
   !END IF
   !enddo
   !enddo

    ! coordinate surfaces - n_zlev z-levels:
    ZLEVEL_LOOP: DO jk = 1, n_zlev

      !-----------------------------
      ! cells
      !  - values for BOUNDARY set below

      nolnd_c(jk)=0
      nosea_c(jk)=0

      !i_startblk = ptr_patch%cells%start_blk(1,1)
      !DO jb = i_startblk, nblks_c

      DO jb = 1, nblks_c

        !CALL get_indices_c(ptr_patch, jb, i_startblk, nblks_c, &
        !  &                i_startidx, i_endidx, 1)

        i_endidx=nproma
        IF (jb==nblks_c) i_endidx=npromz_c

        !-----------------------------
        ! set dolic and wet grid points:
        !  - if bathymetry is deeper than or equal to the coordinate surface (zlev_m)
        !    then grid point is wet; dolic is in that level

        DO je = 1, i_endidx

          !  surface level of lsm and dolic defined by gridgenerator, not the current bathymetry
          IF (jk == 1) THEN

            ! counts sea cells from lsm
            IF (ptr_patch%patch_oce%lsm_oce_c(je,jk,jb) <= -1) THEN
              nosea_c(jk) = nosea_c(jk)+1
              ptr_patch%patch_oce%dolic_c(je,jb) = jk
            ELSE IF (ptr_patch%patch_oce%lsm_oce_c(je,jk,jb) >=  1) THEN
              nolnd_c(jk) = nolnd_c(jk)+1
            ELSE ! 0 not defined
              STOP ' lsm_oce_c = 0'
            END IF

            ! counts sea points from bathymetry
            IF (ptr_patch%patch_oce%bathymetry_c(je,jb) <= -ptr_patch%patch_oce%zlev_m(jk)) &
              &   noct1_c = noct1_c+1

          !  second level of lsm and dolic defined by surface level, not the current bathymetry
          ELSE IF (jk == 2) THEN

            ! dependent on jk-1:
            ptr_patch%patch_oce%lsm_oce_c(je,jk,jb) = ptr_patch%patch_oce%lsm_oce_c(je,jk-1,jb)
            IF (ptr_patch%patch_oce%lsm_oce_c(je,jk,jb) <= -1) THEN
              nosea_c(jk) = nosea_c(jk)+1
              ptr_patch%patch_oce%dolic_c(je,jb) = jk
            ELSE IF (ptr_patch%patch_oce%lsm_oce_c(je,jk-1,jb) >=  1) THEN
              nolnd_c(jk) = nolnd_c(jk)+1
            ELSE ! 0 not defined
              STOP ' lsm_oce_c = 0'
            END IF

          ELSE  ! jk>2

            IF (ptr_patch%patch_oce%bathymetry_c(je,jb) <= -ptr_patch%patch_oce%zlev_m(jk)) THEN
              nosea_c(jk)=nosea_c(jk)+1
              ptr_patch%patch_oce%lsm_oce_c(je,jk,jb) = SEA
              ptr_patch%patch_oce%dolic_c(je,jb) = jk
            ELSE IF (ptr_patch%patch_oce%bathymetry_c(je,jb)>-ptr_patch%patch_oce%zlev_m(jk)) THEN
              nolnd_c(jk)=nolnd_c(jk)+1
              ptr_patch%patch_oce%lsm_oce_c(je,jk,jb) = LAND
            END IF

          END IF

        END DO

      END DO

      !  percentage of land area per level and global value
      inolsm = nolnd_c(jk) + nosea_c(jk)
      IF (inolsm == 0 ) THEN
        IF (jk == 1 ) CALL message (TRIM(routine), 'WARNING - number of cell points is zero?')
        !CALL finish('mo_ocean_topo - no cell points')
        perc_lnd_c(jk) = 0.0_wp
      ELSE
        perc_lnd_c(jk) = REAL(nolnd_c(jk),wp)/REAL(nosea_c(jk)+nolnd_c(jk),wp)*100.0_wp
        nogllnd_c = nogllnd_c + nolnd_c(jk)
        noglsea_c = noglsea_c + nosea_c(jk)
      END IF


      !-----------------------------
      ! edges
      !  - values for BOUNDARY set below, LAND, SEA only

      nolnd_e(jk)=0
      nosea_e(jk)=0

      DO jb = 1, nblks_e

        i_endidx=nproma
        IF (jb==nblks_e) i_endidx=npromz_e

        DO je = 1, i_endidx

          !  surface level of lsm and dolic defined by gridgenerator, not the current bathymetry
          IF (jk == 1) THEN

            ! count and define sea edges from lsm - boundary edges are counted as land
            IF (ptr_patch%patch_oce%lsm_oce_e(je,jk,jb) == -2 ) THEN
              nosea_e(jk)=nosea_e(jk)+1
              ptr_patch%patch_oce%dolic_e(je,jb) = jk
            ELSE
              nolnd_e(jk)=nolnd_e(jk)+1
            END IF

            ! counts sea points from bathymetry
            IF (ptr_patch%patch_oce%bathymetry_e(je,jb) <= -ptr_patch%patch_oce%zlev_m(jk)) THEN
              noct1_e = noct1_e+1
            ENDIF

          !  second level of lsm and dolic defined by surface level, not the current bathymetry
          ELSE IF (jk == 2) THEN

            ! dependent on jk-1:
            ptr_patch%patch_oce%lsm_oce_e(je,jk,jb) = ptr_patch%patch_oce%lsm_oce_e(je,jk-1,jb)
            IF (ptr_patch%patch_oce%lsm_oce_e(je,jk,jb) == -2 ) THEN
              nosea_e(jk)=nosea_e(jk)+1
              ptr_patch%patch_oce%dolic_e(je,jb) = jk
            ELSE
              nolnd_e(jk)=nolnd_e(jk)+1
            END IF

          ELSE  ! jk>2

            IF (ptr_patch%patch_oce%bathymetry_e(je,jb) <= -ptr_patch%patch_oce%zlev_m(jk)) THEN
              nosea_e(jk)=nosea_e(jk)+1
              ptr_patch%patch_oce%lsm_oce_e(je,jk,jb) = SEA
              ptr_patch%patch_oce%dolic_e(je,jb) =jk
            ELSE IF (ptr_patch%patch_oce%bathymetry_e(je,jb)>-ptr_patch%patch_oce%zlev_m(jk)) THEN
              nolnd_e(jk)=nolnd_e(jk)+1
              ptr_patch%patch_oce%lsm_oce_e(je,jk,jb) = LAND
            END IF

          END IF

        END DO

      END DO

      !  percentage of land area per level and global value
      inolsm = nolnd_e(jk) + nosea_e(jk)
      IF (inolsm == 0 ) THEN
        IF (jk == 1 ) CALL message (TRIM(routine), 'WARNING - number of edge points is zero?')
!       CALL finish('mo_ocean_topo - no edge points')
        perc_lnd_e(jk) = 0.0_wp
      ELSE
        perc_lnd_e(jk) = REAL(nolnd_e(jk),wp)/REAL(nosea_e(jk)+nolnd_e(jk),wp)*100.0_wp
        nogllnd_e = nogllnd_e + nolnd_e(jk)
        noglsea_e = noglsea_e + nosea_e(jk)
      END IF

      !-----------------------------
      ! set values for BOUNDARY at edges (get values of neighbouring cells)
      !  - if the two corresponding cells are differing then edge is BOUNDARY
      !    (they are not both LAND or SEA)
      !  - done for jk>2 only, checks for read lsm in jk=1

      nobnd_e(jk)=0

      rl_start = 1           !  #slo# - cannot run with holes on land in grid
      rl_end = min_rledge

      ! values for the blocking
      i_startblk = ptr_patch%edges%start_blk(rl_start,1)
      i_endblk   = ptr_patch%edges%end_blk(rl_end,1)
      !
      ! loop through all patch edges
      BLK_LOOP_E: DO jb = i_startblk, i_endblk

        CALL get_indices_e  &
          &  (ptr_patch, jb, i_startblk, i_endblk, i_startidx, i_endidx, rl_start, rl_end)

        IDX_LOOP_E: DO je =  i_startidx, i_endidx

          ! Get indices/blks of cells 1 and 2 adjacent to edge (je,jb)
          ! #slo# 2011-05-17:
          !  - set all layers except for the two surface layers which are set by gridgen
          !  - count numbers for all layers
          !  - check number for surface layer
          iic1 = ptr_patch%edges%cell_idx(je,jb,1)
          ibc1 = ptr_patch%edges%cell_blk(je,jb,1)
          iic2 = ptr_patch%edges%cell_idx(je,jb,2)
          ibc2 = ptr_patch%edges%cell_blk(je,jb,2)
          !
          ! cells may have -2, -1, 1, 2 for sea, sea_boundary, land_boundary, land:
          IF (jk == 1) THEN
            ! counts number of boundaries for jk=1
            IF ( (ptr_patch%patch_oce%lsm_oce_c(iic1,jk,ibc1) < 0)  .and.   &
              &  (ptr_patch%patch_oce%lsm_oce_c(iic2,jk,ibc2) > 0) )        &
              &   noctb_e=noctb_e + 1
            IF ( (ptr_patch%patch_oce%lsm_oce_c(iic1,jk,ibc1) > 0)  .and.   &
              &  (ptr_patch%patch_oce%lsm_oce_c(iic2,jk,ibc2) < 0) )        &
              &   noctb_e=noctb_e + 1
          END IF  !  jk = 1
          IF (jk > 2) THEN
            IF ( (ptr_patch%patch_oce%lsm_oce_c(iic1,jk,ibc1) < 0)  .and.   &
              &  (ptr_patch%patch_oce%lsm_oce_c(iic2,jk,ibc2) > 0) )        &
              &   ptr_patch%patch_oce%lsm_oce_e(je,jk,jb) = BOUNDARY
            IF ( (ptr_patch%patch_oce%lsm_oce_c(iic1,jk,ibc1) > 0)  .and.   &
              &  (ptr_patch%patch_oce%lsm_oce_c(iic2,jk,ibc2) < 0) )        &
              &   ptr_patch%patch_oce%lsm_oce_e(je,jk,jb) = BOUNDARY
          END IF  !  jk > 2
          IF ( ptr_patch%patch_oce%lsm_oce_e(je,jk,jb) == BOUNDARY )      &
            &  nobnd_e(jk)=nobnd_e(jk)+1


        END DO IDX_LOOP_E

      END DO BLK_LOOP_E

      !-----------------------------
      ! set values for LAND_BOUNDARY and SEA_BOUNDARY at cells
      !  - get values of neighbouring edges
      !  - if one of 3 edges of a sea-cell is BOUNDARY then cell is SEA_BOUNDARY
      !  - if one of 3 edges of a land-cell is BOUNDARY then cell is LAND_BOUNDARY
      !  - done for jk>2 only, checks for read lsm in jk=1

      nosbd_c(jk)=0
      nolbd_c(jk)=0

      rl_start = 1           !  #slo# - cannot run with holes on land in grid
      rl_end = min_rlcell

      ! values for the blocking
      i_startblk = ptr_patch%cells%start_blk(rl_start,1)
      i_endblk   = ptr_patch%cells%end_blk(rl_end,1)
      !
      ! loop through all patch cells
      BLK_LOOP_C: DO jb = i_startblk, i_endblk

        CALL get_indices_c  &
          &  (ptr_patch, jb, i_startblk, i_endblk, i_startidx, i_endidx, rl_start, rl_end)

        IDX_LOOP_C: DO jc =  i_startidx, i_endidx

          ! #slo# 2011-05-17
          !  - set all layers except for the two surface layers which are set by gridgen
          !  - count numbers for all layers
          !  - check number for surface layer

          ! sea points
          IF (ptr_patch%patch_oce%lsm_oce_c(jc,jk,jb) < 0) THEN
          ! #slo# 2010-12-16 - corrected in read-bathy for wrong slm,
          ! could also be done here with:
          ! ptr_patch%patch_oce%lsm_oce_c(jc,jk,jb) = SEA
            DO ji = 1, 3
              ! Get indices/blks of edges 1 to 3 adjacent to cell (jc,jb)
              idxe = ptr_patch%cells%edge_idx(jc,jb,ji)
              ible = ptr_patch%cells%edge_blk(jc,jb,ji)
              ! if one of lsm_e is boundary then lsm_c is sea_boundary
              IF ( ptr_patch%patch_oce%lsm_oce_e(idxe,jk,ible) == BOUNDARY .AND. jk  > 2) &
                &  ptr_patch%patch_oce%lsm_oce_c(jc,jk,jb) = SEA_BOUNDARY
              ! counts number of sea-boundaries for jk=1 - only one boundary is allowed
              IF ( ptr_patch%patch_oce%lsm_oce_e(idxe,jk,ible) == BOUNDARY .AND. jk == 1) &
                &  nocsb_c=nocsb_c + 1

            END DO
            IF ( ptr_patch%patch_oce%lsm_oce_c(jc,jk,jb) == SEA_BOUNDARY )  &
              &  nosbd_c(jk)=nosbd_c(jk)+1
          END IF  !  lsm_c < 0

          ! land points
          IF (ptr_patch%patch_oce%lsm_oce_c(jc,jk,jb) > 0) THEN

            DO ji = 1, 3
              ! Get indices/blks of edges 1 to 3 adjacent to cell (jc,jb)
              idxe = ptr_patch%cells%edge_idx(jc,jb,ji)
              ible = ptr_patch%cells%edge_blk(jc,jb,ji)
              ! if one of lsm_e is boundary then lsm_c is land_boundary
              IF ( ptr_patch%patch_oce%lsm_oce_e(idxe,jk,ible) == BOUNDARY .AND. jk  > 2 ) &
                &  ptr_patch%patch_oce%lsm_oce_c(jc,jk,jb) = LAND_BOUNDARY
              ! counts number of land-boundaries for jk=1 - one land cell may have 2 boundaries
              IF ( ptr_patch%patch_oce%lsm_oce_e(idxe,jk,ible) == BOUNDARY .AND. jk == 1 ) THEN
                   noclb_c=noclb_c + 1
                   EXIT
              END IF
            END DO

            IF ( ptr_patch%patch_oce%lsm_oce_c(jc,jk,jb) == LAND_BOUNDARY )   &
              &  nolbd_c(jk)=nolbd_c(jk)+1

          END IF  !  lsm_c > 0

        END DO  IDX_LOOP_C

      END DO  BLK_LOOP_C
      noglbnd_e = noglbnd_e + nobnd_e(jk)
      noglsbd_c = noglsbd_c + nosbd_c(jk)
      nogllbd_c = nogllbd_c + nolbd_c(jk)

    END DO ZLEVEL_LOOP

    ! Output the levels
    WRITE(message_text,'(a,a)') &
    &     'LEVEL   zlev_m  Thickness   zlev_i  Distance ', &
    &     '    SEA_c    LAND_c  PERC_LND     SEA_e    LAND_e   BND_e   SEA_B. LAND_B.'
    CALL message('', TRIM(message_text))
    DO jk = 1, n_zlev
      WRITE(message_text,'(a,i3,4f10.2,2i10,f10.2,2i10,3i8)') '.',  &
        &   jk, ptr_patch%patch_oce%zlev_m(jk), ptr_patch%patch_oce%del_zlev_m(jk), &
        &       ptr_patch%patch_oce%zlev_i(jk), ptr_patch%patch_oce%del_zlev_i(jk), &
        &   nosea_c(jk), nolnd_c(jk), perc_lnd_c(jk), nosea_e(jk), nolnd_e(jk),     &
        &   nobnd_e(jk), nosbd_c(jk), nolbd_c(jk)
      CALL message('', message_text)
    END DO

    ! Output last level
    inolsm = nogllnd_c + noglsea_c
    IF ( inolsm == 0 ) THEN
      CALL message (TRIM(routine), 'WARNING - number of global cell points is zero?')
      perc_gllnd_c = 0.0_wp
    ELSE
      perc_gllnd_c = REAL(nogllnd_c,wp)/REAL(noglsea_c+nogllnd_c,wp)*100.0_wp
    END IF
    inolsm = nogllnd_e + noglsea_e
    IF ( inolsm == 0 ) THEN
      CALL message (TRIM(routine), 'WARNING - number of global edge points is zero?')
      perc_gllnd_e = 0.0_wp
    ELSE
      perc_gllnd_e = REAL(nogllnd_e,wp)/REAL(noglsea_e+nogllnd_e,wp)*100.0_wp
    END IF
    n_zlvp = n_zlev + 1
    WRITE(message_text,'(a,f20.2,a,i9,i10,f10.2,2i10,3i8)') &
    &     'Bottom Level: ', ptr_patch%patch_oce%zlev_i(n_zlvp), &
    &     '    GLOBAL:',     noglsea_c, nogllnd_c, perc_gllnd_c, &
    &                        noglsea_e, nogllnd_e, noglbnd_e, noglsbd_c, nogllbd_c
    CALL message('', TRIM(message_text))

    ! Warnings occur if create_ocean_grid parameter mindepth is not half the
    ! depth of the surface level dzlev_m(1) in ocean_ctl (must not be an error)
    IF ( nosea_c(1) /= noct1_c ) THEN
      WRITE(message_text,'(a,i8,a,i8)') &
        &   'WARNING - surface sea-cells read = ',nosea_c(1), &
        &   ' - calculated from bathymetry = ',noct1_c
      CALL message(routine, TRIM(message_text))
    END IF
    IF ( nosea_e(1) /= noct1_e ) THEN
      WRITE(message_text,'(a,i8,a,i8)') &
        &   'WARNING - surface sea-edges read = ',nosea_e(1), &
        &   ' - calculated from bathymetry = ',noct1_e
      CALL message(routine, TRIM(message_text))
    END IF

    ! Boundary warnings in case of inconsistency in read land-sea-mask
    IF ( nobnd_e(1) /= noctb_e ) THEN
      WRITE(message_text,'(a,i8,a,i8)') &
        &   'WARNING - surface boundary edges read = ',nobnd_e(1), &
        &   ' - calculated from bathymetry = ',noctb_e
      CALL message(routine, TRIM(message_text))
    END IF
    IF ( nosbd_c(1) /= nocsb_c ) THEN
      WRITE(message_text,'(a,i8,a,i8)') &
        &   'WARNING - surface sea-boundary cells read = ',nosbd_c(1), &
        &   ' - calculated from bathymetry = ',nocsb_c
      CALL message(routine, TRIM(message_text))
    END IF
    IF ( nolbd_c(1) /= noclb_c ) THEN
      WRITE(message_text,'(a,i8,a,i8)') &
        &   'WARNING - surface land-boundary cells read = ',nolbd_c(1), &
        &   ' - calculated from bathymetry = ',noclb_c
      CALL message(routine, TRIM(message_text))
    END IF

    !-----------------------------
    ! real bathymetry should not be used since individual bottom layer thickness is not implemented
    ! set values of bathymetry to new non-individual dolic values

    DO jb = 1, nblks_c
      i_endidx=nproma
      IF (jb==nblks_c) i_endidx=npromz_c
        DO jc = 1, i_endidx
          ptr_patch%patch_oce%bathymetry_c(jc,jb) = &
            &  -ptr_patch%patch_oce%zlev_i(ptr_patch%patch_oce%dolic_c(jc,jb)+1)
      ENDDO
    ENDDO

    DO jb = 1, nblks_e
      i_endidx=nproma
      IF (jb==nblks_e) i_endidx=npromz_e
        DO je = 1, i_endidx
          ptr_patch%patch_oce%bathymetry_e(je,jb) = &
            &  -ptr_patch%patch_oce%zlev_i(ptr_patch%patch_oce%dolic_e(je,jb)+1)
      ENDDO
    ENDDO

    !-----------------------------
    ! set wet_c and wet_e to 1 at sea points including boundaries

    ! cells
    WHERE ( ptr_patch%patch_oce%lsm_oce_c(:,:,:) <= SEA_BOUNDARY )
      ptr_patch%patch_oce%wet_c(:,:,:) = 1.0_wp
    END WHERE

    ! edges
    WHERE ( ptr_patch%patch_oce%lsm_oce_e(:,:,:) <= SEA_BOUNDARY )
      ptr_patch%patch_oce%wet_e(:,:,:) = 1.0_wp
    END WHERE

    ! intermediate levels: same as wet_c
    !WHERE ( ptr_patch%patch_oce%lsm_oce_c(:,:,:) <= SEA_BOUNDARY )
    !  ptr_patch%patch_oce%wet_i(:,:,:) = 1.0_wp
    !END WHERE

    CALL message (TRIM(routine), 'end')

  END SUBROUTINE fill_vertical_ocean_domain
  !-------------------------------------------------------------------------
  !
  !>
  !! Computes the coefficients that determine the scalar product on the primal grid. This
  !! scalar product depends on the grid geometry only and  is used to formulate the primitive
  !! equations in weak form. The coefficients are applied in module "mo_scalar_product".
  !! The following components of the data type "ocean_patch" are filled:
  !!   edge2cell_coeff  : coefficients for edge to cell mapping
  !!   edge2cell_coeff_t: coefficients for transposed of edge to cell mappings
  !!   edge2vert_coeff  : coefficients for edge to vertex mapping
  !!   edge2vert_coeff_t: coefficients for transposed of edge to vertex mappings
  !!   fixed_vol_norm   : summed volume weight of moved cell
  !!   variable_vol_norm: volume weight at the edges of moved cell
  !!
  !! @par Revision History
  !!  developed by Peter Korn, MPI-M  2010-09
  !!  Modification by Stephan Lorenz, 2010-11
  !!
  SUBROUTINE init_scalar_product( p_patch)

    !  patch on which computation is performed
    !
    TYPE(t_patch), TARGET, INTENT(inout) :: p_patch

    CHARACTER(len=MAX_CHAR_LENGTH), PARAMETER :: &
    & routine = ('mo_ocean_topo:init_scalar_product')

    INTEGER, PARAMETER :: no_cell_edges = 3
    INTEGER, PARAMETER :: no_vert_edges = 6
    INTEGER :: jb, je, jv, ie, ie_1, ie_2
    INTEGER :: il_e,ib_e,it_vertedges,k  
    INTEGER :: il_c1, ib_c1, il_c2, ib_c2
    INTEGER :: il_v1, il_v2, ib_v1, ib_v2
    !INTEGER :: jc, ile,ibe
    !INTEGER :: jl_v1, jl_v2!, jb_v1, jb_v2

    INTEGER :: iil_c1(no_cell_edges), iil_c2(no_cell_edges)
    INTEGER :: iib_c1(no_cell_edges), iib_c2(no_cell_edges)

    !INTEGER :: il_c1_e1, ib_c1_e1, il_c1_e2, ib_c1_e2!, il_c1_e3, ib_c1_e3
    !INTEGER :: il_c2_e1, il_c2_e2, il_c2_e3!, ib_c2_e3!ib_c2_e1, ib_c2_e2,

    INTEGER :: jil_c1, jib_c1,jil_c2, jib_c2
    INTEGER :: rl_start_e, rl_end_e
    INTEGER :: i_startblk_e, i_endblk_e, i_startidx_e, i_endidx_e
    INTEGER :: rl_start, rl_end
    INTEGER :: i_startblk, i_endblk, i_startidx, i_endidx

    !REAL(wp) :: z_lon, z_lat, z_rlong, z_rlat, z_long_c, z_lat_c
    REAL(wp) :: z_tmp!z_twopi, z_longmax, z_longmin
    !REAL(wp) :: cell_edge_dist(no_cell_edges,2)
    !REAL(wp) :: cell_edge_distance
    REAL(wp) :: norm_c1_c2, norm_v1_v2, norm!, norm_v1_e0, norm_v2_e0
    !REAL(wp) :: dual_edge_length_v1(no_vert_edges)
    !REAL(wp) :: dual_edge_length_v2(no_vert_edges)
    REAL(wp) :: dual_edge_length(no_vert_edges)
!    REAL(wp) :: edge_length(no_cell_edges)
!     REAL(wp) :: vert_edge_dist_v1(no_vert_edges,2)
!     REAL(wp) :: vert_edge_dist_v2(no_vert_edges,2)
    REAL(wp) :: vert_edge_dist(no_vert_edges,2)!, new_lon,new_lat
!     REAL(wp) :: vert_dual_mid_dist_v1(no_vert_edges,2)
!     REAL(wp) :: vert_dual_mid_dist_v2(no_vert_edges,2)
    REAL(wp) :: vert_dual_mid_dist(no_vert_edges,2)
    !REAL(wp) :: vert2vert_dist
    REAL(wp) :: vert_edge_distance, vert_dual_mid_distance
    TYPE(t_geographical_coordinates) :: gc_mid_dual_edge(no_vert_edges)!gc_edge(no_cell_edges) 
    !TYPE(t_geographical_coordinates) :: gc_v0,gc_e0,gc_c0, gc_dual_edge(no_vert_edges)!gc_v1, gc_v2,
    !TYPE(t_geographical_coordinates) :: ll1, ll2!, ll3
    TYPE(t_cartesian_coordinates)    :: cc_dual_edge(no_vert_edges), cc_edge(no_cell_edges)
    TYPE(t_cartesian_coordinates)    :: xx1,xx2!,xx3
    !TYPE(t_cartesian_coordinates)    :: vert2vert_cc(nproma,p_patch%nblks_v,no_vert_edges)
    TYPE(t_cartesian_coordinates)    :: vert1_midedge_cc(nproma,p_patch%nblks_v,no_vert_edges)
    TYPE(t_cartesian_coordinates)    :: vert2_midedge_cc(nproma,p_patch%nblks_v,no_vert_edges)
    !TYPE(t_cartesian_coordinates)    :: normal_cc(no_cell_edges)!, norm_c0_e
    TYPE(t_cartesian_coordinates)    :: cell2cell_cc
    TYPE(t_cartesian_coordinates)    :: cc_e0, cc_c1,cc_c2,cc_v0!, cc_c0, cc_v1, cc_v2
    TYPE(t_cartesian_coordinates)    :: cv_c1_e0, cv_c2_e0, cv_c1_c2
    !TYPE(t_cartesian_coordinates)    :: cv_v1_e0, cv_v2_e0!, cv_v1_v2
    TYPE(t_cartesian_coordinates)    :: cc_mid_dual_edge(no_vert_edges)
    TYPE(t_cartesian_coordinates)    :: recon_vec_cc
    !TYPE(t_geographical_coordinates) :: recon_vec_gc(no_vert_edges), gc_tmp
    !TYPE(t_geographical_coordinates) :: normal_gc(no_cell_edges)
    !TYPE(t_cartesian_coordinates)    :: recon_vec_cc1(no_vert_edges), recon_vec_cc2(no_vert_edges)

    !TYPE(t_cartesian_coordinates)    :: cc_c1_e1, cc_c1_e2, cc_c1_e3
    !TYPE(t_cartesian_coordinates)    :: cc_c2_e1, cc_c2_e2, cc_c2_e3
    !TYPE(t_cartesian_coordinates)    :: cv_c1_e1, cv_c1_e2, cv_c1_e3
    !TYPE(t_cartesian_coordinates)    :: cv_c2_e1, cv_c2_e2, cv_c2_e3
    TYPE(t_cartesian_coordinates)    :: z_vec_c1(no_cell_edges),z_vec_c2(no_cell_edges)
    TYPE(t_cartesian_coordinates)    :: recon_vec_cc_v1(no_vert_edges) 
    TYPE(t_cartesian_coordinates)    :: recon_vec_cc_v2(no_vert_edges)
    !TYPE(t_cartesian_coordinates)    :: vec_mid_dual_edge_2v1(no_vert_edges)
    !TYPE(t_cartesian_coordinates)    :: vec_mid_dual_edge_2v2(no_vert_edges)
    !REAL(wp) :: length
    REAL(wp) :: z_edge_length(no_cell_edges)!, z_e_length!, z_ce_dist
    REAL(wp) :: z_cell_edge_dist_c1(no_cell_edges,2),z_cell_edge_dist_c2(no_cell_edges,2)
    !REAL(wp) :: z_cell_edge_dist(no_cell_edges,2)

    !REAL(wp) :: p_c(3), r1(3,3), r2(3,3), rot_p_c(3), barlon, barlat
    !REAL(wp) :: edge_length_c1_e1, edge_length_c1_e2,edge_length_c1_e3
    !REAL(wp) :: edge_length_c2_e1, edge_length_c2_e2,edge_length_c2_e3
    LOGICAL, PARAMETER :: MID_POINT_DUAL_EDGE = .TRUE. !Please do not change this unless
                                                       !you are sure, you know what you do.
    LOGICAL, PARAMETER :: LARC_LENGTH = .FALSE.
    !-----------------------------------------------------------------------
    CALL message (TRIM(routine), 'start')

    rl_start = 1 
    rl_end = min_rlcell

    i_startblk = p_patch%cells%start_blk(rl_start,1)
    i_endblk   = p_patch%cells%end_blk(rl_end,1)

     rl_start_e = 1
     rl_end_e = min_rledge

     i_startblk_e = p_patch%edges%start_blk(rl_start_e,1)
     i_endblk_e   = p_patch%edges%end_blk(rl_end_e,1)

     !STEP 1: edge2cell and cell2edge coefficients
     EDGE_BLK_LOOP_PRIMAL: DO jb = i_startblk_e, i_endblk_e

       CALL get_indices_e(p_patch, jb,&
                        & i_startblk_e, i_endblk_e,&
                        & i_startidx_e, i_endidx_e,&
                        & rl_start_e, rl_end_e)

       EDGE_IDX_LOOP_PRIMAL: DO je =  i_startidx_e, i_endidx_e

         !Get indices of two adjacent triangles
         il_c1 = p_patch%edges%cell_idx(je,jb,1)
         ib_c1 = p_patch%edges%cell_blk(je,jb,1)
         il_c2 = p_patch%edges%cell_idx(je,jb,2)
         ib_c2 = p_patch%edges%cell_blk(je,jb,2)

         cc_c1 = gc2cc(p_patch%cells%center(il_c1, ib_c1))
         cc_c2 = gc2cc(p_patch%cells%center(il_c2, ib_c2))

         z_cell_edge_dist_c1 = 0.0_wp
         z_cell_edge_dist_c2 = 0.0_wp

         !normals in cell 1
         DO ie=1,no_cell_edges

           !actual edges of cell c1
           iil_c1(ie) = p_patch%cells%edge_idx(il_c1,ib_c1,ie)
           iib_c1(ie) = p_patch%cells%edge_blk(il_c1,ib_c1,ie)

           cc_edge(ie)   = gc2cc(p_patch%edges%center(iil_c1(ie),iib_c1(ie)))

           !calculate edge length
           !get vertex indices adjacent to actual edge
           il_v1 = p_patch%edges%vertex_idx(iil_c1(ie),iib_c1(ie),1)
           ib_v1 = p_patch%edges%vertex_blk(iil_c1(ie),iib_c1(ie),1)
           il_v2 = p_patch%edges%vertex_idx(iil_c1(ie),iib_c1(ie),2)
           ib_v2 = p_patch%edges%vertex_blk(iil_c1(ie),iib_c1(ie),2)

           !get vertex positions
           xx1 = gc2cc(p_patch%verts%vertex(il_v1,ib_v1))
           xx2 = gc2cc(p_patch%verts%vertex(il_v2,ib_v2))
 
           IF(LARC_LENGTH)THEN
             norm=SQRT(SUM(xx1%x*xx1%x))
             xx1%x= xx1%x/norm
             norm=SQRT(SUM(xx2%x*xx2%x))
             xx2%x= xx2%x/norm
             z_edge_length(ie) = arc_length(xx2,xx1)
             !z_edge_length(ie) = p_patch%edges%primal_edge_length(iil_c1(ie),iib_c1(ie))/re
           ELSE
             z_edge_length(ie) = SQRT(SUM((xx2%x-xx1%x)*(xx2%x-xx1%x)))
            !write(*,*)'length 3:', z_edge_length(ie),arc_length(xx1,xx2) 
           ENDIF

           !calculate cell-edge distance as half of cell-cell distance
           !get cell indices adjacent to actual edge
           jil_c1 = p_patch%edges%cell_idx(iil_c1(ie),iib_c1(ie),1)
           jib_c1 = p_patch%edges%cell_blk(iil_c1(ie),iib_c1(ie),1)
           jil_c2 = p_patch%edges%cell_idx(iil_c1(ie),iib_c1(ie),2)
           jib_c2 = p_patch%edges%cell_blk(iil_c1(ie),iib_c1(ie),2)

           !get cell positions
           xx1 = gc2cc(p_patch%cells%center(jil_c1,jib_c1))
           xx2 = gc2cc(p_patch%cells%center(jil_c2,jib_c2))

           IF(jil_c1==il_c1.AND.jib_c1==ib_c1)THEN
            k=1
           ELSEIF(jil_c2==il_c1.AND.jib_c2==ib_c1)THEN
            k=2
           ENDIF

           IF(LARC_LENGTH)THEN
             norm=SQRT(SUM(xx1%x*xx1%x))
             xx1%x= xx1%x/norm
             norm=SQRT(SUM(xx2%x*xx2%x))
             xx2%x= xx2%x/norm
             norm          = SQRT(SUM(cc_edge(ie)%x*cc_edge(ie)%x))
             cc_edge(ie)%x = cc_edge(ie)%x/norm
             z_cell_edge_dist_c1(ie,1) = arc_length(cc_edge(ie),xx1)
             z_cell_edge_dist_c1(ie,2) = arc_length(cc_edge(ie),xx2)
             !z_cell_edge_dist_c1(ie,1) = p_patch%edges%edge_cell_length(iil_c1(ie),iib_c1(ie),k)/re 
             !z_cell_edge_dist_c1(ie,2) = p_patch%edges%edge_cell_length(iil_c1(ie),iib_c1(ie),k)/re 
           ELSE
             z_cell_edge_dist_c1(ie,1) = SQRT(SUM((cc_edge(ie)%x-xx1%x)*(cc_edge(ie)%x-xx1%x)))
             z_cell_edge_dist_c1(ie,2) = SQRT(SUM((cc_edge(ie)%x-xx2%x)*(cc_edge(ie)%x-xx2%x)))  
             !write(*,*)'length 4',z_cell_edge_dist_c1(ie,1), z_cell_edge_dist_c1(ie,1),&
             !&p_patch%edges%edge_cell_length(iil_c1(ie),iib_c1(ie),1)/re 
           ENDIF
           p_patch%patch_oce%dist_cell2edge(iil_c1(ie),iib_c1(ie),1) = z_cell_edge_dist_c1(ie,1)
           p_patch%patch_oce%dist_cell2edge(iil_c1(ie),iib_c1(ie),2) = z_cell_edge_dist_c1(ie,2)

           z_vec_c1(ie)%x =  cc_edge(ie)%x - cc_c1%x     !p_patch%edges%primal_cart_normal(iil_c1(ie),iib_c1(ie))
           norm = SQRT(SUM( z_vec_c1(ie)%x* z_vec_c1(ie)%x))

           p_patch%patch_oce%edge2cell_coeff_cc(il_c1,ib_c1,ie)%x&
           & = z_vec_c1(ie)%x*p_patch%cells%edge_orientation(il_c1,ib_c1,ie)*z_edge_length(ie)

!test
!z_vec_c1(ie)%x =z_vec_c1(ie)%x/norm
!write(*,*)'vec:normal:',z_vec_c1(ie)%x,p_patch%edges%primal_cart_normal(iil_c1(ie),iib_c1(ie))%x 
!---------
                 p_patch%patch_oce%fixed_vol_norm(il_c1,ib_c1) = &
             &   p_patch%patch_oce%fixed_vol_norm(il_c1,ib_c1) + 0.5_wp*norm*z_edge_length(ie)
           p_patch%patch_oce%variable_vol_norm(il_c1,ib_c1,ie) = 0.5_wp*norm*z_edge_length(ie)

           !write(*,*)'edge length   :',z_edge_length(ie),p_patch%edges%primal_edge_length(iil_c1(ie),iib_c1(ie))/re
           !write(*,*)'cell-edge dist:', z_cell_edge_dist_c1(ie,k),p_patch%edges%edge_cell_length(iil_c1(ie),iib_c1(ie),k)/re
         END DO

         !normals in cell 2
         DO ie=1,no_cell_edges

           !actual edges of cell c2
           iil_c2(ie) = p_patch%cells%edge_idx(il_c2,ib_c2,ie)
           iib_c2(ie) = p_patch%cells%edge_blk(il_c2,ib_c2,ie)

           cc_edge(ie) = gc2cc(p_patch%edges%center(iil_c2(ie),iib_c2(ie)))

           !calculate edge length
           !get vertex indices adjacent to actual edge
           il_v1 = p_patch%edges%vertex_idx(iil_c2(ie),iib_c2(ie),1)
           ib_v1 = p_patch%edges%vertex_blk(iil_c2(ie),iib_c2(ie),1)
           il_v2 = p_patch%edges%vertex_idx(iil_c2(ie),iib_c2(ie),2)
           ib_v2 = p_patch%edges%vertex_blk(iil_c2(ie),iib_c2(ie),2)

           !get vertex positions
           xx1 = gc2cc(p_patch%verts%vertex(il_v1,ib_v1))
           xx2 = gc2cc(p_patch%verts%vertex(il_v2,ib_v2))

           IF(LARC_LENGTH)THEN
             norm=SQRT(SUM(xx1%x*xx1%x))
             xx1%x= xx1%x/norm

             norm=SQRT(SUM(xx2%x*xx2%x))
             xx2%x= xx2%x/norm

             z_edge_length(ie) = arc_length(xx2,xx1)
             !z_edge_length(ie) = p_patch%edges%primal_edge_length(iil_c2(ie),iib_c2(ie))/re
              !write(*,*)'arc length',arc_length(xx2,xx1),z_edge_length(ie),SQRT(SUM((xx2%x-xx1%x)*(xx2%x-xx1%x)))
           ELSE
             z_edge_length(ie) = SQRT(SUM((xx2%x-xx1%x)*(xx2%x-xx1%x)))
           ENDIF
           !calculate cell-edge distance as half of cell-cell distance
           !get cell indices adjacent to actual edge
           jil_c1 = p_patch%edges%cell_idx(iil_c2(ie),iib_c2(ie),1)
           jib_c1 = p_patch%edges%cell_blk(iil_c2(ie),iib_c2(ie),1)
           jil_c2 = p_patch%edges%cell_idx(iil_c2(ie),iib_c2(ie),2)
           jib_c2 = p_patch%edges%cell_blk(iil_c2(ie),iib_c2(ie),2)

           !get cell positions
           xx1 = gc2cc(p_patch%cells%center(jil_c1,jib_c1))  
           xx2 = gc2cc(p_patch%cells%center(jil_c2,jib_c2))

           IF(jil_c1==il_c2.AND.jib_c1==ib_c2)THEN
             k=1
           ELSEIF(jil_c2==il_c2.AND.jib_c2==ib_c2)THEN
             k=2
           ENDIF  

           IF(LARC_LENGTH)THEN
             norm=SQRT(SUM(xx1%x*xx1%x))
             xx1%x= xx1%x/norm
             norm=SQRT(SUM(xx2%x*xx2%x))
             xx2%x= xx2%x/norm
             norm=SQRT(SUM(cc_edge(ie)%x*cc_edge(ie)%x))
             cc_edge(ie)%x =  cc_edge(ie)%x/norm
             z_cell_edge_dist_c2(ie,1) = arc_length(cc_edge(ie),xx1)
             z_cell_edge_dist_c2(ie,2) = arc_length(cc_edge(ie),xx2)
             !z_cell_edge_dist_c2(ie,1) = p_patch%edges%edge_cell_length(iil_c2(ie),iib_c2(ie),1)/re
             !z_cell_edge_dist_c2(ie,2) = p_patch%edges%edge_cell_length(iil_c2(ie),iib_c2(ie),2)/re
             !write(*,*)'arc length',0.5_wp*arc_length(xx2,xx1),z_cell_edge_dist_c2(ie,k),0.5_wp*SQRT(SUM((xx2%x-xx1%x)*(xx2%x-xx1%x)))
           ELSE 
             z_cell_edge_dist_c2(ie,1) = SQRT(SUM((cc_edge(ie)%x-xx1%x)*(cc_edge(ie)%x-xx1%x)))
             z_cell_edge_dist_c2(ie,2) = SQRT(SUM((cc_edge(ie)%x-xx2%x)*(cc_edge(ie)%x-xx2%x)))
           ENDIF
           p_patch%patch_oce%dist_cell2edge(iil_c2(ie),iib_c2(ie),1) = z_cell_edge_dist_c1(ie,1)
           p_patch%patch_oce%dist_cell2edge(iil_c2(ie),iib_c2(ie),2) = z_cell_edge_dist_c1(ie,2)

           z_vec_c2(ie)%x =  cc_edge(ie)%x - cc_c2%x  !p_patch%edges%primal_cart_normal(iil_c2(ie),iib_c2(ie))
           norm = SQRT(SUM( z_vec_c2(ie)%x* z_vec_c2(ie)%x))

           p_patch%patch_oce%edge2cell_coeff_cc(il_c2,ib_c2,ie)%x&
             & = z_vec_c2(ie)%x*p_patch%cells%edge_orientation(il_c2,ib_c2,ie)*z_edge_length(ie)

           p_patch%patch_oce%fixed_vol_norm(il_c2,ib_c2) &
             & = p_patch%patch_oce%fixed_vol_norm(il_c2,ib_c2) + 0.5_wp*norm*z_edge_length(ie)

           p_patch%patch_oce%variable_vol_norm(il_c2,ib_c2,ie) = 0.5_wp*norm*z_edge_length(ie)


         END DO
       END DO EDGE_IDX_LOOP_PRIMAL
     END DO EDGE_BLK_LOOP_PRIMAL
    rl_start = 1 
    rl_end = min_rledge

    i_startblk = p_patch%edges%start_blk(rl_start,1)
    i_endblk   = p_patch%edges%end_blk(rl_end,1)

    EDGE_BLK_LOOP_0: DO jb = i_startblk, i_endblk
      CALL get_indices_e(p_patch, jb, i_startblk, i_endblk,&
                       & i_startidx, i_endidx, rl_start, rl_end)
      EDGE_IDX_LOOP_0: DO je =  i_startidx, i_endidx

        !Get indices of two adjacent triangles
        il_c1 = p_patch%edges%cell_idx(je,jb,1)
        ib_c1 = p_patch%edges%cell_blk(je,jb,1)
        il_c2 = p_patch%edges%cell_idx(je,jb,2)
        ib_c2 = p_patch%edges%cell_blk(je,jb,2)

        !cartesian coordinates of edge and neighbor cells on 1-sphere
        cc_e0 = gc2cc(p_patch%edges%center(je,jb))
        cc_c1 = gc2cc(p_patch%cells%center(il_c1,ib_c1))
        cc_c2 = gc2cc(p_patch%cells%center(il_c2,ib_c2))

        !cartesian vectors from:
        !cell 2 to cell 1, cell 1 to edge je and cell 2 to edge je
        cv_c1_c2%x = cc_c1%x - cc_c2%x
        cv_c1_e0%x = cc_e0%x - cc_c1%x
        cv_c2_e0%x = cc_e0%x - cc_c2%x

        IF(LARC_LENGTH)THEN
          norm=SQRT(SUM(cc_e0%x*cc_e0%x))
          cc_e0%x= cc_e0%x/norm
          norm=SQRT(SUM(cc_c1%x*cc_c1%x))
          cc_c1%x= cc_c1%x/norm
          norm=SQRT(SUM(cc_c2%x*cc_c2%x))
          cc_c2%x= cc_c2%x/norm
          norm_c1_c2 = arc_length(cc_c1, cc_c2)
          !norm_c1_c2 = p_patch%edges%dual_edge_length(je,jb)/re 
                       !p_patch%edges%edge_cell_length(je,jb,1)/re&
                      !&+p_patch%edges%edge_cell_length(je,jb,2)/re
        ELSE
          norm_c1_c2 = SQRT(SUM(cv_c1_e0%x*cv_c1_e0%x))+SQRT(SUM(cv_c2_e0%x*cv_c2_e0%x)) !SQRT(SUM(cv_c1_c2%x*cv_c1_c2%x))!
        ENDIF

        !Determine which edge of both of the two adjacent cells corresponds to the
        !actual edge "je". This information is used below for the edge-orientation.
        DO ie=1,no_cell_edges
          IF (p_patch%cells%edge_idx(il_c1,ib_c1,ie) == je.AND.&
            & p_patch%cells%edge_blk(il_c1,ib_c1,ie) == jb) THEN
            ie_1 = ie
          END IF
          IF (p_patch%cells%edge_idx(il_c2,ib_c2,ie) == je.AND.&
            & p_patch%cells%edge_blk(il_c2,ib_c2,ie) == jb) THEN
            ie_2 = ie
          END IF
        END DO

        p_patch%patch_oce%edge2cell_coeff_cc_t(je,jb,1)%x&
        & = cv_c1_e0%x * p_patch%cells%edge_orientation(il_c1,ib_c1,ie_1)/norm_c1_c2

        p_patch%patch_oce%edge2cell_coeff_cc_t(je,jb,2)%x&
        & = cv_c2_e0%x * p_patch%cells%edge_orientation(il_c2,ib_c2,ie_2)/norm_c1_c2

      END DO EDGE_IDX_LOOP_0
    END DO EDGE_BLK_LOOP_0

    !------------------------------------------------------------------------------
    !STEP 2: edge2vert und vert2edge coefficients for dual grid
    !------------------------------------------------------------------------------
    rl_start = 1
    rl_end   = min_rlvert

    i_startblk = p_patch%verts%start_blk(rl_start,1)
    i_endblk   = p_patch%verts%end_blk(rl_end,1)


    VERT_BLK_LOOP: DO jb = i_startblk, i_endblk
      CALL get_indices_v(p_patch, jb, i_startblk, i_endblk,&
                       & i_startidx, i_endidx, rl_start, rl_end)
      VERT_IDX_LOOP: DO jv =  i_startidx, i_endidx

        ! current number of edges around vertex (5 or 6)
        it_vertedges = p_patch%verts%num_edges(jv,jb)
        cc_v0        = gc2cc(p_patch%verts%vertex(jv,jb))
 
        DO ie=1, no_vert_edges

          il_e = p_patch%verts%edge_idx(jv,jb,ie)
          ib_e = p_patch%verts%edge_blk(jv,jb,ie)

          cc_dual_edge(ie) = gc2cc(p_patch%edges%center(il_e,ib_e))
          !Parts of this code parrallels the implementation in the grid-generator
          !module "mo_geometry".
          !
          !1) determine normal vector from adjacent cell to adjacent cell
          !   in cartesian coordinate for moved dual cell
          !Get indices of two adjacent triangles
          il_c1 = p_patch%edges%cell_idx(il_e,ib_e,1)
          ib_c1 = p_patch%edges%cell_blk(il_e,ib_e,1)
          il_c2 = p_patch%edges%cell_idx(il_e,ib_e,2)
          ib_c2 = p_patch%edges%cell_blk(il_e,ib_e,2)

          xx1 = gc2cc(p_patch%cells%center(il_c1,ib_c1))
          norm=SQRT(SUM(xx1%x*xx1%x))
          xx1%x= xx1%x/norm

          xx2 = gc2cc(p_patch%cells%center(il_c2,ib_c2))
          norm=SQRT(SUM(xx2%x*xx2%x))
          xx2%x= xx2%x/norm

           cell2cell_cc%x       = xx2%x - xx1%x
           IF(LARC_LENGTH)THEN
             norm_c1_c2 = arc_length(xx1,xx2)
           ELSE
             norm_c1_c2 = SQRT(SUM(cell2cell_cc%x*cell2cell_cc%x)) 
           ENDIF 
           dual_edge_length(ie) = norm_c1_c2
!           cell2cell_cc%x       = cell2cell_cc%x/norm_c1_c2 

          IF(MID_POINT_DUAL_EDGE)THEN
            cc_mid_dual_edge(ie)%x = 0.5_wp*(xx2%x+xx1%x)
            gc_mid_dual_edge(ie)   = cc2gc(cc_mid_dual_edge(ie)) 
          ELSE
            cc_mid_dual_edge(ie)%x = cc_dual_edge(ie)%x
            gc_mid_dual_edge(ie)   = cc2gc(cc_mid_dual_edge(ie)) 
          ENDIF

          !2) determine vector from adjacent vertex to adjacent vertex
          !   in cartesian coordinate for moved dual cell
          !Get indices of two adjacent vertices
          il_v1 = p_patch%edges%vertex_idx(il_e,ib_e,1)
          ib_v1 = p_patch%edges%vertex_blk(il_e,ib_e,1)
          il_v2 = p_patch%edges%vertex_idx(il_e,ib_e,2)
          ib_v2 = p_patch%edges%vertex_blk(il_e,ib_e,2)

          xx1 = gc2cc(p_patch%verts%vertex(il_v1,ib_v1))
          norm=SQRT(SUM(xx1%x*xx1%x))
          xx1%x= xx1%x/norm

          xx2 = gc2cc(p_patch%verts%vertex(il_v2,ib_v2))
          norm=SQRT(SUM(xx2%x*xx2%x))
          xx2%x= xx2%x/norm

          vert1_midedge_cc(jv, jb, ie)%x = cc_mid_dual_edge(ie)%x - xx1%x
          vert2_midedge_cc(jv, jb, ie)%x = cc_mid_dual_edge(ie)%x - xx2%x
          !vert2vert_cc(jv, jb, ie)%x = cc_mid_dual_edge(ie)%x - xx1%x !xx2%x - xx1%x
!           norm                       = SQRT(SUM(vert2vert_cc(jv,jb,ie)%x*vert2vert_cc(jv,jb,ie)%x))
!           vert2vert_cc(jv,jb,ie)%x   = vert2vert_cc(jv, jb, ie)%x/norm
          norm = SQRT(SUM(vert1_midedge_cc(jv,jb,ie)%x*vert1_midedge_cc(jv,jb,ie)%x))
          vert1_midedge_cc(jv, jb, ie)%x = vert1_midedge_cc(jv, jb, ie)%x/norm

          norm = SQRT(SUM(vert2_midedge_cc(jv,jb,ie)%x*vert2_midedge_cc(jv,jb,ie)%x))
          vert2_midedge_cc(jv, jb, ie)%x = vert2_midedge_cc(jv, jb, ie)%x/norm


          !calculate vertex edge distance 
          IF(LARC_LENGTH)THEN
            vert_edge_dist(ie,1) = arc_length (cc_dual_edge(ie), xx1) 
            vert_edge_dist(ie,2) = arc_length (cc_dual_edge(ie), xx2) 
            vert_dual_mid_dist(ie,1)= arc_length (cc_mid_dual_edge(ie), xx1) 
            vert_dual_mid_dist(ie,2)= arc_length (cc_mid_dual_edge(ie), xx2)
          ELSE
            vert_edge_dist(ie,1)&
            & = SQRT(SUM((cc_dual_edge(ie)%x - xx1%x)*(cc_dual_edge(ie)%x - xx1%x)))
            vert_edge_dist(ie,2)&
            & = SQRT(SUM((cc_dual_edge(ie)%x - xx2%x)*(cc_dual_edge(ie)%x - xx2%x)))
            vert_dual_mid_dist(ie,1)&
            & = SQRT(SUM((cc_mid_dual_edge(ie)%x - xx1%x)*(cc_mid_dual_edge(ie)%x - xx1%x)))
            vert_dual_mid_dist(ie,2)&
            & = SQRT(SUM((cc_mid_dual_edge(ie)%x - xx2%x)*(cc_mid_dual_edge(ie)%x - xx2%x)))
          ENDIF

          !calculate normal vector that is perpendicular to vertex-vertex- and edge position vector
          !If one uses the edge position vector this results in the moved primal normal. Later
          !edge position vector has to be replaced by the midpoint of the dual edge.
          recon_vec_cc_v1(ie) = vector_product(vert1_midedge_cc(jv, jb, ie), cc_mid_dual_edge(ie))
          norm                = SQRT(SUM(recon_vec_cc_v1(ie)%x*recon_vec_cc_v1(ie)%x))
          recon_vec_cc_v1(ie)%x = recon_vec_cc_v1(ie)%x/norm

          recon_vec_cc_v2(ie)   = vector_product(vert2_midedge_cc(jv,jb,ie), cc_mid_dual_edge(ie))
          norm                  = SQRT(SUM(recon_vec_cc_v2(ie)%x*recon_vec_cc_v2(ie)%x))
          recon_vec_cc_v2(ie)%x = recon_vec_cc_v2(ie)%x/norm

          !Fix orientation
          z_tmp = DOT_PRODUCT(recon_vec_cc_v1(ie)%x, p_patch%edges%primal_cart_normal(il_e,ib_e)%x)
          IF (z_tmp <0._wp) recon_vec_cc_v1(ie)%x = -1._wp * recon_vec_cc_v1(ie)%x

          z_tmp = DOT_PRODUCT(recon_vec_cc_v2(ie)%x, p_patch%edges%primal_cart_normal(il_e,ib_e)%x)
          IF (z_tmp <0._wp) recon_vec_cc_v2(ie)%x = -1._wp * recon_vec_cc_v2(ie)%x


          !write(*,*)'recon vec:primal 1:', il_e,ib_e,ie,recon_vec_cc%x, p_patch%edges%primal_cart_normal(il_e,ib_e)%x
          IF      ( (p_patch%edges%vertex_idx(il_e,ib_e,1) == jv) .and. &
                    (p_patch%edges%vertex_blk(il_e,ib_e,1) == jb) ) THEN

            vert_edge_distance     = vert_edge_dist(ie,1)
            vert_dual_mid_distance = vert_dual_mid_dist(ie,1)
            recon_vec_cc           = recon_vec_cc_v1(ie)

            p_patch%patch_oce%edge2vert_vector_cc(jv,jb,ie)=&
            &vector_product(vert1_midedge_cc(jv, jb, ie), cc_mid_dual_edge(ie))
            z_tmp = DOT_PRODUCT(p_patch%patch_oce%edge2vert_vector_cc(jv,jb,ie)%x,&
            &p_patch%edges%primal_cart_normal(il_e,ib_e)%x)
            IF (z_tmp <0._wp) p_patch%patch_oce%edge2vert_vector_cc(jv,jb,ie)%x&
            & = -1._wp * p_patch%patch_oce%edge2vert_vector_cc(jv,jb,ie)%x


          ELSE IF ( (p_patch%edges%vertex_idx(il_e,ib_e,2) == jv) .and. &
                    (p_patch%edges%vertex_blk(il_e,ib_e,2) == jb) ) THEN

            vert_edge_distance     = vert_edge_dist(ie,2)
            vert_dual_mid_distance = vert_dual_mid_dist(ie,2)
            recon_vec_cc           = recon_vec_cc_v2(ie)

            p_patch%patch_oce%edge2vert_vector_cc(jv,jb,ie)=&
            &vector_product(vert2_midedge_cc(jv, jb, ie), cc_mid_dual_edge(ie))
            z_tmp = DOT_PRODUCT(p_patch%patch_oce%edge2vert_vector_cc(jv,jb,ie)%x,&
            & p_patch%edges%primal_cart_normal(il_e,ib_e)%x)
            IF (z_tmp <0._wp) p_patch%patch_oce%edge2vert_vector_cc(jv,jb,ie)%x =&
            & -1._wp * p_patch%patch_oce%edge2vert_vector_cc(jv,jb,ie)%x
          ELSE
            CALL message (TRIM(routine), 'WARNING - vert_edge_distance not found')
            write(*,*) 'p_patch%edges%vertex_idx(il_e,ib_e,1)=', &
                        p_patch%edges%vertex_idx(il_e,ib_e,1)
          END IF

           p_patch%patch_oce%variable_dual_vol_norm(jv,jb,ie) = &
                   &0.5_wp*dual_edge_length(ie)*vert_dual_mid_distance!vert_edge_distance*dual_edge_length(ie)!

          p_patch%patch_oce%edge2vert_coeff_cc(jv,jb,ie)%x=&
            &recon_vec_cc%x*dual_edge_length(ie)*vert_dual_mid_distance


          !p_patch%patch_oce%edge2vert_vector_cc(jv,jb,ie)%x=recon_vec_cc%x

        norm_v1_v2 = SQRT(SUM(vert1_midedge_cc(jv, jb, ie)%x*vert1_midedge_cc(jv, jb, ie)%x))&
                  &+ SQRT(SUM(vert2_midedge_cc(jv, jb, ie)%x*vert2_midedge_cc(jv, jb, ie)%x))

        p_patch%patch_oce%edge2vert_coeff_cc_t(il_e,ib_e,1)%x = vert1_midedge_cc(jv, jb, ie)%x * &
          &    ( p_patch%edges%system_orientation(il_e,ib_e)/norm_v1_v2 )

        p_patch%patch_oce%edge2vert_coeff_cc_t(il_e,ib_e,2)%x = vert2_midedge_cc(jv, jb, ie)%x * &
          &    ( p_patch%edges%system_orientation(il_e,ib_e)/norm_v1_v2 )

        END DO

      ENDDO VERT_IDX_LOOP
    END DO VERT_BLK_LOOP

    CALL message (TRIM(routine), 'end')
  END SUBROUTINE init_scalar_product
!-------------------------------------------------------------------------
  !
  !
  !>
  !! Precomputes the geometrical factors used in the divergence, rotation.
  !!
  !! Precomputes the geometrical factors used in the divergence, rotation
  !! and ??? operators stored in the patch_ocean instead of int_state
  !!
  !! @par Revision History
  !!  developed by Guenther Zaengl, 2009-03-17
  !!  Modification by Almut Gassmann, 2009-12-19
  !!  - Vorticity is computed on quads in case of the hexagonal grid
  !!  Modification by Almut Gassmann, 2010-02-05
  !!  - Added feature for poor men's 3rd order advection, where a directional
  !!    laplace is needed at the edges.
  !!  Modification by Stephan Lorenz, 2010-06-02
  !!  - Storage moved from int_state into patch_oce since it is static
  !!    geometric information used in the ocean model
  !!-Calculation of cell area changed to achieve compatibility with
  !!sw-model (cell area and consequently divergence different), PK, Nov 2010
  !!
  SUBROUTINE calc_geo_factors( ptr_patch )
    !
    IMPLICIT NONE
    !
    !  patch on which computation is performed
    !
    TYPE(t_patch), TARGET, INTENT(inout) :: ptr_patch
    !

    INTEGER :: jc, jb, je, jv, je1
    INTEGER :: rl_start, rl_end
    INTEGER :: i_startblk, i_endblk, i_startidx, i_endidx, i_nchdom

    INTEGER :: ile, ibe, ilc1, ibc1, ilc2, ibc2, ifac, ic, ilnc, ibnc
INTEGER :: ile1, ibe1,ile2,ibe2,ile3,ibe3
    !TYPE(cartesian_coordinates)::z_pn_k,z_pn_j
    !REAL(wp) :: z_lon, z_lat, z_nu, z_nv, z_proj
    REAL(wp) :: cell_area
    CHARACTER(len=MAX_CHAR_LENGTH), PARAMETER :: &
    & routine = ('mo_ocean_topo:calc_geo_factors')

    !-----------------------------------------------------------------------

    CALL message (TRIM(routine), 'start')

    i_nchdom   = MAX(1,ptr_patch%n_childdom)


!$OMP PARALLEL PRIVATE(rl_start,rl_end,i_startblk,i_endblk,ifac)
    ! a) Geometrical factor for divergence
    rl_start = 1
    rl_end = min_rlcell

    ! values for the blocking
    i_startblk = ptr_patch%cells%start_blk(rl_start,1)
    i_endblk   = ptr_patch%cells%end_blk(rl_end,i_nchdom)
    !
    ! loop through all patch cells (and blocks)
    !
!$OMP DO PRIVATE(jb,je,jc,i_startidx,i_endidx,ile,ibe)
    DO jb = i_startblk, i_endblk

      CALL get_indices_c(ptr_patch, jb, i_startblk, i_endblk,      &
        &                i_startidx, i_endidx, rl_start, rl_end)

      DO jc = i_startidx, i_endidx

         ile1 = ptr_patch%cells%edge_idx(jc,jb,1)
          ibe1 = ptr_patch%cells%edge_blk(jc,jb,1)
          ile2 = ptr_patch%cells%edge_idx(jc,jb,2)
          ibe2 = ptr_patch%cells%edge_blk(jc,jb,2)
          ile3 = ptr_patch%cells%edge_idx(jc,jb,3)
          ibe3 = ptr_patch%cells%edge_blk(jc,jb,3)

          cell_area =  0.25_wp&
  & *( ptr_patch%edges%primal_edge_length(ile1,ibe1)*ptr_patch%edges%dual_edge_length(ile1,ibe1)&
  &   +ptr_patch%edges%primal_edge_length(ile2,ibe2)*ptr_patch%edges%dual_edge_length(ile2,ibe2)&
  &   +ptr_patch%edges%primal_edge_length(ile3,ibe3)*ptr_patch%edges%dual_edge_length(ile3,ibe3))


       DO je = 1, ptr_patch%cell_type

          IF (je > ptr_patch%cells%num_edges(jc,jb)) CYCLE ! relevant for hexagons

           ile = ptr_patch%cells%edge_idx(jc,jb,je)
           ibe = ptr_patch%cells%edge_blk(jc,jb,je)

           ptr_patch%patch_oce%geofac_div(jc,je,jb) =      &
         &   ptr_patch%edges%primal_edge_length(ile,ibe) * &
         &   ptr_patch%cells%edge_orientation(jc,jb,je)  / &
         &   ptr_patch%cells%area(jc,jb)

           ptr_patch%patch_oce%geofac_div(jc,je,jb) =      &
         &   ptr_patch%edges%primal_edge_length(ile,ibe) * &
         &   ptr_patch%cells%edge_orientation(jc,jb,je)  / &
         &   ptr_patch%cells%area(jc,jb)!cell_area

        ENDDO !edge loop

      ENDDO !idx loop

    END DO !block loop
!$OMP END DO

    ! b) Geometrical factor for rotation
    rl_start = 1  ! #slo# changed to 1 - 2010-12-07
    rl_end = min_rlvert

    ! Vorticity should have the right sign
      ifac = 0
      SELECT CASE (ptr_patch%cell_type)
      CASE (3)
        ifac = 1
      CASE (6)
        ifac = -1
      END SELECT
      ! values for the blocking
      i_startblk = ptr_patch%verts%start_blk(rl_start,1)
      i_endblk   = ptr_patch%verts%end_blk(rl_end,i_nchdom)
      !
      ! loop through all patch cells (and blocks)
      !
!$OMP DO PRIVATE(jb,je,jv,i_startidx,i_endidx,ile,ibe)
      DO jb = i_startblk, i_endblk

        CALL get_indices_v(ptr_patch, jb, i_startblk, i_endblk, &
          &                i_startidx, i_endidx, rl_start, rl_end)

        DO je = 1, 9-ptr_patch%cell_type
          DO jv = i_startidx, i_endidx

            IF (je > ptr_patch%verts%num_edges(jv,jb)) CYCLE   ! relevant for hexagons

            ile = ptr_patch%verts%edge_idx(jv,jb,je)
            ibe = ptr_patch%verts%edge_blk(jv,jb,je)

            ptr_patch%patch_oce%geofac_rot(jv,je,jb) =    &
         &    ptr_patch%edges%dual_edge_length(ile,ibe) * &
         &    ptr_patch%verts%edge_orientation(jv,jb,je)/ &
         &    ptr_patch%verts%dual_area(jv,jb) * REAL(ifac,wp)

          ENDDO !vertex loop
        ENDDO

      END DO !block loop
!$OMP END DO

      ! c) Geometrical factor for nabla2_scalar
      rl_start = 1  ! #slo# changed to 1 - 2010-12-07
      rl_end = min_rlcell

      ! values for the blocking
      i_startblk = ptr_patch%cells%start_blk(rl_start,1)
      i_endblk   = ptr_patch%cells%end_blk(rl_end,i_nchdom)
      !
      ! loop through all patch cells (and blocks)
      !
!$OMP DO PRIVATE(jb,je,jc,ic,i_startidx,i_endidx,ile,ibe,ilc1,ibc1,&
!$OMP    ilc2,ibc2,ilnc,ibnc)
      DO jb = i_startblk, i_endblk

        CALL get_indices_c(ptr_patch, jb, i_startblk, i_endblk, &
                           i_startidx, i_endidx, rl_start, rl_end)

        DO je = 1, ptr_patch%cell_type
          DO jc = i_startidx, i_endidx

            ile = ptr_patch%cells%edge_idx(jc,jb,je)
            ibe = ptr_patch%cells%edge_blk(jc,jb,je)

            ilc1 = ptr_patch%edges%cell_idx(ile,ibe,1)
            ibc1 = ptr_patch%edges%cell_blk(ile,ibe,1)
            ilc2 = ptr_patch%edges%cell_idx(ile,ibe,2)
            ibc2 = ptr_patch%edges%cell_blk(ile,ibe,2)

            IF (jc == ilc1 .AND. jb == ibc1) THEN
              IF (ptr_patch%cell_type == 3) THEN
                ptr_patch%patch_oce%geofac_n2s(jc,1,jb)       =  &
                &  ptr_patch%patch_oce%geofac_n2s(jc,1,jb)  -  &
                &  ptr_patch%patch_oce%geofac_div(jc,je,jb) /  &
                &  ptr_patch%edges%dual_edge_length(ile,ibe)
            ELSE IF (ptr_patch%cell_type == 6) THEN
              ptr_patch%patch_oce%geofac_n2s(jc,1,jb)       =  &
                &  ptr_patch%patch_oce%geofac_n2s(jc,1,jb)  -  &
                &  ptr_patch%patch_oce%geofac_div(jc,je,jb) /  &
                &  ptr_patch%edges%dual_edge_length(ile,ibe)*  &
                &  ptr_patch%edges%system_orientation(ile,ibe)
            ENDIF
          ELSE IF (jc == ilc2 .AND. jb == ibc2) THEN
            IF (ptr_patch%cell_type == 3) THEN
              ptr_patch%patch_oce%geofac_n2s(jc,1,jb)       =  &
                &  ptr_patch%patch_oce%geofac_n2s(jc,1,jb)  +  &
                &  ptr_patch%patch_oce%geofac_div(jc,je,jb) /  &
                &  ptr_patch%edges%dual_edge_length(ile,ibe)
            ELSE IF (ptr_patch%cell_type == 6) THEN
              ptr_patch%patch_oce%geofac_n2s(jc,1,jb)       =  &
                &  ptr_patch%patch_oce%geofac_n2s(jc,1,jb)  +  &
                &  ptr_patch%patch_oce%geofac_div(jc,je,jb) /  &
                &  ptr_patch%edges%dual_edge_length(ile,ibe)*  &
                &  ptr_patch%edges%system_orientation(ile,ibe)
            ENDIF
          ENDIF
          DO ic = 1, ptr_patch%cell_type
            ilnc = ptr_patch%cells%neighbor_idx(jc,jb,ic)
            ibnc = ptr_patch%cells%neighbor_blk(jc,jb,ic)
            IF (ilnc == ilc1 .AND. ibnc == ibc1) THEN
              IF (ptr_patch%cell_type == 3) THEN
                ptr_patch%patch_oce%geofac_n2s(jc,ic+1,jb)     = &
                  &  ptr_patch%patch_oce%geofac_n2s(jc,ic+1,jb)- &
                  &  ptr_patch%patch_oce%geofac_div(jc,je,jb)  / &
                  &  ptr_patch%edges%dual_edge_length(ile,ibe)
              ELSE IF (ptr_patch%cell_type == 6) THEN
                ptr_patch%patch_oce%geofac_n2s(jc,ic+1,jb)     = &
                  &  ptr_patch%patch_oce%geofac_n2s(jc,ic+1,jb)- &
                  &  ptr_patch%patch_oce%geofac_div(jc,je,jb)  / &
                  &  ptr_patch%edges%dual_edge_length(ile,ibe) * &
                  &  ptr_patch%edges%system_orientation(ile,ibe)
              ENDIF
            ELSE IF (ilnc == ilc2 .AND. ibnc == ibc2) THEN
              IF (ptr_patch%cell_type == 3) THEN
                ptr_patch%patch_oce%geofac_n2s(jc,ic+1,jb)     = &
                  &  ptr_patch%patch_oce%geofac_n2s(jc,ic+1,jb)+ &
                  &  ptr_patch%patch_oce%geofac_div(jc,je,jb)  / &
                  &  ptr_patch%edges%dual_edge_length(ile,ibe)
              ELSE IF (ptr_patch%cell_type == 6) THEN
                ptr_patch%patch_oce%geofac_n2s(jc,ic+1,jb)     = &
                  &  ptr_patch%patch_oce%geofac_n2s(jc,ic+1,jb)+ &
                  &  ptr_patch%patch_oce%geofac_div(jc,je,jb)  / &
                  &  ptr_patch%edges%dual_edge_length(ile,ibe) * &
                  &  ptr_patch%edges%system_orientation(ile,ibe)
              ENDIF
            ENDIF
          ENDDO

          ! To ensure that dummy edges have a factor of 0:
          IF (je > ptr_patch%cells%num_edges(jc,jb)) THEN
            ptr_patch%patch_oce%geofac_n2s(jc,je+1,jb) = 0._wp
          ENDIF

        ENDDO !cell loop
      ENDDO

    END DO !block loop
!$OMP END DO

    ! d) Geometrical factor for quad-cell divergence (triangles only)
    IF (ptr_patch%cell_type == 3) THEN

      rl_start = 1  ! #slo# changed to 1 - 2010-12-07
      rl_end = min_rledge

      ! values for the blocking
      i_startblk = ptr_patch%edges%start_blk(rl_start,1)
      i_endblk   = ptr_patch%edges%end_blk(rl_end,i_nchdom)

!$OMP DO PRIVATE(jb,je,je1,i_startidx,i_endidx,ile,ibe)
      DO jb = i_startblk, i_endblk

        CALL get_indices_e(ptr_patch, jb, i_startblk, i_endblk, &
                           i_startidx, i_endidx, rl_start, rl_end)

        DO je1 = 1, 4
          DO je = i_startidx, i_endidx

          ile = ptr_patch%edges%quad_idx(je,jb,je1)
          ibe = ptr_patch%edges%quad_blk(je,jb,je1)

          ptr_patch%patch_oce%geofac_qdiv(je,je1,jb) = &
            ptr_patch%edges%primal_edge_length(ile,ibe) * &
            ptr_patch%edges%quad_orientation(je,jb,je1)  / &
            ptr_patch%edges%quad_area(je,jb)

          ENDDO !edge loop
        ENDDO

      END DO !block loop
!$OMP END DO

    ENDIF

    ! f) compute inverse dual edge length (used in math_operators for the ocean)

    rl_start = 1  ! #slo# changed to 1 - 2010-12-07
    rl_end = min_rledge

    ! Second step: computed projected orientation vectors and related information
    i_startblk = ptr_patch%edges%start_blk(rl_start,1)
    i_endblk   = ptr_patch%edges%end_blk(rl_end,i_nchdom)
    !
    ! loop through all patch edges
    !
!$OMP DO PRIVATE(jb,i_startidx,i_endidx,je)
    DO jb = i_startblk, i_endblk

      CALL get_indices_e(ptr_patch, jb, i_startblk, i_endblk, &
                         i_startidx, i_endidx, rl_start, rl_end)

      DO je =  i_startidx, i_endidx

        ! compute inverse dual edge length (undefined for refin_ctrl=1)

        ptr_patch%edges%inv_dual_edge_length(je,jb) = &
          1._wp/ptr_patch%edges%dual_edge_length(je,jb)

      ENDDO

    END DO !block loop
!$OMP END DO

!$OMP END PARALLEL

    CALL message (TRIM(routine), 'end')

  END SUBROUTINE calc_geo_factors


  !----------------------------------------------------------------------------
  SUBROUTINE nf(status)

    INTEGER, INTENT(in) :: status

    IF (status /= nf_noerr) THEN
      CALL finish('mo_ocean_topo netCDF error', nf_strerror(status))
    ENDIF

  END SUBROUTINE nf
!-------------------------------------------------------------------------  
!-------------------------------------------------------------------------  

END MODULE mo_ocean_topo
