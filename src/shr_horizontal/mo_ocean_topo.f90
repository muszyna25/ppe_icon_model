!>
!!               The module <i>mo_ocean_topo</i>.
!!
!!               The module <i>mo_ocean_topo</i>
!! provides functionality to import information about the models computational
!! domain. This information is read from several files that were generated by
!! the patch generator programm. The data types describing the model domain are
!! contained in <i>mo_model_domain</i>.
!!
!! @par Revision History
!! Initial version  by: Peter Korn,  MPI-M, Hamburg, June 2005
!! Modification by Thomas Heinze (2006-02-21):
!! - renamed m_modules to mo_modules
!! Modification by Thomas Heinze (2006-09-20):
!! - added routine grid_and_patch_diagnosis
!! Modification by Pilar Ripodas, DWD, (2007-01-31)
!! - addapted to the new TYPE grid_edges (system_orientation added)
!! Modification by Peter Korn,  MPI-M, (2006-12)
!! - implementation of topography and boundary treatment, i.e.
!!   initialization of the grid & patch components that carry
!!   information about topography and the lateral boundaries of
!!   the domain; this is not related to patch boundaries.
!!   topography can either be computed by analytical l,eans or
!!   by reading from database files.
!! Modification by Hui Wan, MPI-M, (2007-02-23)
!! - Subroutine <i>init_import</i> was changed to <i>setup_grid</i>.
!!   Namelist hierarchy_ini was renamed to <i>grid_ctl</i>, moved
!!   from <i>mo_io_utilities</i> to this module and now read from
!!   an external file in subroutine <i>setup_grid</i>.
!! - Some changes in <i>init_ocean_patch_component</i> after
!!   discussion with Peter.
!! - Calculation of the min. primal edge length was added to
!!   <i>import_patches</i>. However, shouldn't it be an array with
!!   one element for each patch, rather than a scalar?
!! Modification by P. Ripodas, DWD, (2007-03-14):
!! - Now the output of "import_patches" is the min_dual_edge_lenght
!!   instead of the min_primal_edge_lenght. It will be used to set
!!   the horizontal diffusion parameter. Now it is done as it was
!!   in the prototype.
!! Modification by Almut Gassmann, MPI-M (2007-04)
!! - removed loptimize to make compatible with new grid generator
!! - removed itoa for good programming style
!! - reorganized patch input to be compatible with the new patch generator
!! - cleaning up "destruct_patches"
!! Modification by Almut Gassmann, MPI-M (2007-04-13)
!! - remove grid type and perform related adaptations
!!   (grid information comes now inside a patch)
!! - changed subroutine name form setup_grid to setup_files
!! Modified by Hui Wan, MPI-M, (2008-04-04)
!!  - control variable loce renamed locean
!!  - topography_file_dir renamed topo_file_dir
!!  - for the hydro_atmos, control variable testtype renamed ctest_name.
!! Modified by Almut Gassmann, MPI-M, (2008-04-23)
!!  - itopo distinguishes now shallow water (itopo=1) orography function
!!    from hydro_atmos orography function (itopo=2)
!! Modification by Jochen Foerstner, DWD, (2008-07-16)
!!  - new fields in the derived type for the edges:
!!    grid_edges%primal_cart_normal (Cartesian normal to edge),
!!    grid_edges%quad_idx, grid_edges%quad_area and grid_edges%quad_orientation
!!    (indices of edges and area of the quadrilateral formed by two adjacent cells)
!!    up to now these new fields are initialized in the new routines
!!    calculate_primal_cart_normal and init_quad_twoadjcells
!!    rather than read from a grid/patch file.
!! Modification by Almut Gassmann, MPI-M, (2008-09-21)
!!  - remove reference to mask and height files, they are never used
!!  - use i_cell_type to distinguish cells as triangles or hexagons
!! Modification by Almut Gassmann, MPI-M (2008-10-30)
!!  - add subroutine init_coriolis to initialize Coriolis parameter
!! Modification by Stephan Lorenz, MPI-M (2010-02-06)
!!  - add subroutines to init and read patch_oce for ocean component
!! Modification by Peter Korn, MPI-M, (2010-05-31)
!!  - fill new data types for patch_ocean for reconstruction process
!!  - routine <i>init_ocean_patch_component</i> deleted, use <i>init_ocean_patch</i>
!! Modification by Stephan Lorenz, MPI-M (2010-06-09)
!!  - add calculation of inv_dual_edge_length from intp_coeff for operator use
!! Modification by Stephan Lorenz, MPI-M (2010-10-26)
!!  - add calculations for data structures in patch_ocean for new "PtP" reconstructions
!! Modification by Stephan Lorenz, MPI-M (2010-11-02)
!!  - sbrts using "PtP" structures are moved to new module mo_scalar_product
!!
!! @par Copyright
!! 2002-2007 by DWD and MPI-M
!! This software is provided for non-commercial use only.
!! See the LICENSE and the WARRANTY conditions.
!!
!! @par License
!! The use of ICON is hereby granted free of charge for an unlimited time,
!! provided the following rules are accepted and applied:
!! <ol>
!! <li> You may use or modify this code for your own non commercial and non
!!    violent purposes.
!! <li> The code may not be re-distributed without the consent of the authors.
!! <li> The copyright notice and statement of authorship must appear in all
!!    copies.
!! <li> You accept the warranty conditions (see WARRANTY).
!! <li> In case you intend to use the code commercially, we oblige you to sign
!!    an according license agreement with DWD and MPI-M.
!! </ol>
!!
!! @par Warranty
!! This code has been tested up to a certain level. Defects and weaknesses,
!! which may be included in the code, do not establish any warranties by the
!! authors.
!! The authors do not make any warranty, express or implied, or assume any
!! liability or responsibility for the use, acquisition or application of this
!! software.
!!
!!
MODULE mo_ocean_topo
!-------------------------------------------------------------------------
!
!    ProTeX FORTRAN source: Style 2
!    modified for ICON project, DWD/MPI-M 2006
!
!-------------------------------------------------------------------------
!
!
!

USE mo_kind,               ONLY: wp
USE mo_io_units,           ONLY: filename_max!, nerr
USE mo_impl_constants,     ONLY: land, land_boundary, boundary, sea_boundary, sea,  &
  &                              success, max_char_length,                          &
  &                              min_rlcell, min_rledge, min_rlvert
USE mo_exception,          ONLY: message_text, message, finish
USE mo_model_domain,       ONLY: t_patch
USE mo_ocean_nml,          ONLY: n_zlev, dzlev_m
USE mo_run_nml,            ONLY: nproma, i_cell_type
USE mo_math_utilities,     ONLY: gc2cc,cc2gc,       &
  &                              t_geographical_coordinates, t_cartesian_coordinates,   &
  &                              vector_product, arc_length
!USE mo_math_constants,     ONLY: pi
!USE mo_physical_constants,     ONLY: re!, rre, omega, rgrav
USE mo_loopindices,        ONLY: get_indices_c, get_indices_e, get_indices_v
USE mo_model_domimp_setup, ONLY: reshape_int, reshape_real
USE mo_grid_nml,           ONLY: nroot

IMPLICIT NONE

PRIVATE

! required for testing/reading topography
INCLUDE 'netcdf.inc'

CHARACTER(len=*), PARAMETER :: version = '$Id$'

PUBLIC :: init_ocean_patch
PUBLIC :: init_scalar_product
PUBLIC :: calc_geo_factors

TYPE(t_patch), POINTER :: ptr_patch ! patch on specific level
!-------------------------------------------------------------------------

CONTAINS



  !-------------------------------------------------------------------------
  !
  !
  !>
  !! Initializes parts of the general patch used for the ocean component.
  !! (Initializes extensions of patch used for the ocean component.)
  !!
  !! @par Revision History
  !! Initial release by Stephan Lorenz, MPI-M (2010-02)
  !! - developed from init_ocean_patch_component that is no longer used
  !!
  SUBROUTINE init_ocean_patch( p_patch )

    TYPE(t_patch), POINTER :: p_patch

    CHARACTER(len=MAX_CHAR_LENGTH), PARAMETER :: &
    &        routine = 'mo_ocean_topo:init_ocean_patch'

    INTEGER :: nblks_c, nblks_e, nblks_v, n_zlvp, n_zlvm, ie

    INTEGER :: ist  ! status variable

    !-----------------------------------------------------------------------
    ptr_patch => p_patch

    CALL message (TRIM(routine), 'start')

    !
    ! Allocation of topographically related elements - bathymetry and land-sea-mask
    !

    ! values for the blocking
    nblks_c = ptr_patch%nblks_c
    nblks_e = ptr_patch%nblks_e
    nblks_v = ptr_patch%nblks_v

    ! number of vertical levels from the namelist in mo_global_variables
    n_zlvp = n_zlev + 1
    n_zlvm = n_zlev - 1
    ptr_patch%patch_oce%n_zlev = n_zlev
    ptr_patch%patch_oce%n_zlvp = n_zlvp
    ptr_patch%patch_oce%n_zlvm = n_zlvm

    ! allocate and set vertical level thickness from the namelist
    ALLOCATE(ptr_patch%patch_oce%del_zlev_m(n_zlev),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating del_zlev_m failed')
    ENDIF
    ptr_patch%patch_oce%del_zlev_m(:) = dzlev_m(1:n_zlev)

    ! Output now in fill_vertical_ocean_domain only
    !WRITE(message_text,'(a)') 'Vertical level thicknesses of elemental prisms read from namelist:'
    !CALL message( TRIM(routine),TRIM(message_text))
    !132 chars only
    !WRITE(message_text,'(10f8.1)') dzlev_m(1:n_zlev)
    !CALL message('', TRIM(message_text))
    !WRITE(nerr,'(10f8.1)') dzlev_m(1:n_zlev)

    ! allocate vertical domain
    ALLOCATE(ptr_patch%patch_oce%zlev_m(n_zlev),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating zlev_m failed')
    ENDIF
    ALLOCATE(ptr_patch%patch_oce%zlev_i(n_zlvp),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating zlev_i failed')
    ENDIF
    ALLOCATE(ptr_patch%patch_oce%del_zlev_i(n_zlev),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating del_zlev_i failed')
    ENDIF

    !
    !! bathymetric depth at cells, edges and vertices
    !
    ! cells
    ALLOCATE(ptr_patch%patch_oce%bathymetry_c(nproma,nblks_c),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating bathymetry_c failed')
    ENDIF
    ! edges
    ALLOCATE(ptr_patch%patch_oce%bathymetry_e(nproma,nblks_e),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating bathymetry_e failed')
    ENDIF
    ! vertices - not needed for ocean
!   ALLOCATE(ptr_patch%patch_oce%bathymetry_v(nproma,nblks_v),STAT=ist)
!   IF (ist /= SUCCESS) THEN
!     CALL finish (routine,'allocating bathymetry_v failed')
!   ENDIF

    !
    !! 3-dim land-sea-mask at cells, edges and vertices
    !
    ! cells
    ALLOCATE(ptr_patch%patch_oce%lsm_oce_c(nproma,n_zlev,nblks_c),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating lsm_oce_c failed')
    ENDIF
    ! edges
    ALLOCATE(ptr_patch%patch_oce%lsm_oce_e(nproma,n_zlev,nblks_e),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating lsm_oce_e failed')
    ENDIF
    ! deepest ocean layer in column
    ALLOCATE(ptr_patch%patch_oce%dolic_c(nproma,nblks_c),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating dolic_c failed')
    ENDIF
    ALLOCATE(ptr_patch%patch_oce%dolic_e(nproma,nblks_e),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating dolic_e failed')
    ENDIF
    ! 3-dim real land-sea-mask
    ! cells
    ALLOCATE(ptr_patch%patch_oce%wet_c(nproma,n_zlev,nblks_c),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating wet_c failed')
    ENDIF
    ! edges
    ALLOCATE(ptr_patch%patch_oce%wet_e(nproma,n_zlev,nblks_e),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating wet_e failed')
    ENDIF
    ! intermediate vertical velocity layers
    !ALLOCATE(ptr_patch%patch_oce%wet_i(nproma,n_zlvp,nblks_c),STAT=ist)
    !IF (ist /= SUCCESS) THEN
    !  CALL finish (routine,'allocating wet_i failed')
    !ENDIF

    ! arrays that are required for #slo OLD# reconstruction
!     ALLOCATE(ptr_patch%patch_oce%cell2edge_vec(nproma,nblks_c,1:3),STAT=ist)
!      IF (ist /= SUCCESS) THEN
!        CALL finish (routine,'allocating cell2edge_vec failed')
!      ENDIF
!      ALLOCATE(ptr_patch%patch_oce%cell2edge_weight(nproma,nblks_c,1:3),STAT=ist)
!      IF (ist /= SUCCESS) THEN
!        CALL finish (routine,'allocating cell2edge_weight failed')
!      ENDIF
!      ALLOCATE(ptr_patch%patch_oce%vertex2dualedge_mid_vec(nproma,nblks_v,1:6),STAT=ist)
!      IF (ist /= SUCCESS) THEN
!        CALL finish (routine,'allocating vertex2dualedge_mid_vec failed')
!      ENDIF
!      ALLOCATE(ptr_patch%patch_oce%vertex2dualedge_mid_weight(nproma,nblks_v,1:6),STAT=ist)
!      IF (ist /= SUCCESS) THEN
!        CALL finish (routine,'allocating vertex2dualedge_mid_weight failed')
!      ENDIF
!      ALLOCATE(ptr_patch%patch_oce%mid_dual_edge(nproma,nblks_e),STAT=ist)
!      IF (ist /= SUCCESS) THEN
!        CALL finish (routine,'allocating mid_dual_edge failed')
!      ENDIF
     ALLOCATE(ptr_patch%patch_oce%dist_cell2edge(nproma,nblks_e,2),STAT=ist)
     IF (ist /= SUCCESS) THEN
       CALL finish (routine,'allocating dist_cell2edge failed')
     ENDIF

    ! arrays that are required for setting up the scalar product
    !
    !coefficients for edge to cell mapping, one half of the scalar product.
    !Dimension: nproma,nblks_c encode number of cells, 1:3 corresponds to number
    !of edges per cell, 1:2 is for u and v component of cell vector
!     ALLOCATE(ptr_patch%patch_oce%edge2cell_coeff(nproma,nblks_c,1:3, 1:2),STAT=ist)
!     IF (ist /= SUCCESS) THEN
!       CALL finish (routine,'allocating edge2cell_coeff failed')
!     ENDIF
    ALLOCATE(ptr_patch%patch_oce%edge2cell_coeff_cc(nproma,nblks_c,1:3),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating edge2cell_coeff_cc failed')
    ENDIF

    !coefficients for transposed of edge to cell mapping, second half of the scalar product.
    !Dimension: nproma,nblks_e encode number of edges, 1:2 is for cell neighbors of an edge
    ALLOCATE(ptr_patch%patch_oce%edge2cell_coeff_cc_t(nproma,nblks_e,1:2),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating transposed edge2cell_coeff failed')
    ENDIF
    !coefficients for edge to vertex mapping.
    !Dimension: nproma,nblks_v encode number of vertices, 1:6 is number of edges of a vertex,
    !1:2 is for u and v component of vertex vector
!     ALLOCATE(ptr_patch%patch_oce%edge2vert_coeff(nproma,nblks_v,1:6,1:2),STAT=ist)
!     IF (ist /= SUCCESS) THEN
!       CALL finish (routine,'allocating edge2vert_coeff failed')
!     ENDIF

    ALLOCATE(ptr_patch%patch_oce%edge2vert_coeff_cc(nproma,nblks_v,1:6),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating edge2vert_coeff failed')
    ENDIF

    ALLOCATE(ptr_patch%patch_oce%edge2vert_coeff_cc_t(nproma,nblks_e,1:2),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating edge2vert_coeff failed')
    ENDIF
    !coefficients for transposed edge to vertex mapping.
    !Dimension: nproma,nblks_e encode number of edges,
    !1:2 is number of vertex neighbors per edge
!     ALLOCATE(ptr_patch%patch_oce%edge2vert_coeff_t(nproma,nblks_e,1:2),STAT=ist)
!     IF (ist /= SUCCESS) THEN
!       CALL finish (routine,'allocating transposed edge2vert_coeff failed')
!     ENDIF
!    ALLOCATE(ptr_patch%patch_oce%edge2vert_coeff_gc_t(nproma,nblks_e,1:2),STAT=ist)
!     IF (ist /= SUCCESS) THEN
!       CALL finish (routine,'allocating transposed edge2vert_coeff failed')
!     ENDIF

    !normalizing factors for edge to cell mapping.
    !Either by fixed volume or by variable one taking the surface elevation
    !into account. The later one depends on time and space.
    ALLOCATE(ptr_patch%patch_oce%fixed_vol_norm(nproma,nblks_c),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating fixed_vol_norm failed')
    ENDIF
    ALLOCATE(ptr_patch%patch_oce%variable_vol_norm(nproma,nblks_c,1:3),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating variable_vol_norm failed')
    ENDIF

    ALLOCATE(ptr_patch%patch_oce%variable_dual_vol_norm(nproma,nblks_v,1:6),STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocating variable_dual_vol_norm failed')
    ENDIF


    ! Init geometrical factors
    ! This part is copied from the interpolation modules.
    ! Interpolation module is no longer used in ocean model
    ! but some of the grid related information is stored in interpolation type.

    ALLOCATE (ptr_patch%patch_oce%geofac_div(nproma, i_cell_type, nblks_c), STAT=ist )
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocation for geofac_div failed')
    ENDIF

    ALLOCATE (ptr_patch%patch_oce%geofac_qdiv(nproma, 4, nblks_e), STAT=ist )
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocation for geofac_qdiv failed')
    ENDIF

    SELECT CASE (i_cell_type)
    CASE(3)
      ALLOCATE (ptr_patch%patch_oce%geofac_rot(nproma, 6, nblks_v), STAT=ist )
      IF (ist /= SUCCESS) THEN
        CALL finish (routine,'allocation for geofac_rot failed')
      ENDIF
    CASE(6)
      ALLOCATE (ptr_patch%patch_oce%geofac_rot(nproma, 4, nblks_e), STAT=ist )
      IF (ist /= SUCCESS) THEN
        CALL finish (routine,'allocation for geofac_rot failed')
      ENDIF
    END SELECT
    ALLOCATE (ptr_patch%patch_oce%geofac_n2s(nproma, i_cell_type+1, nblks_c), STAT=ist )
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocation for geofac_n2s failed')
    ENDIF

!   ALLOCATE (ptr_patch%patch_oce%geofac_grg(nproma, i_cell_type+1, nblks_c, 2), STAT=ist )
!   IF (ist /= SUCCESS) THEN
!     CALL finish (routine,'allocation for geofac_grg failed')
!   ENDIF


    ! Initialize variables to avoid false alarms when checking parallel runs

    ptr_patch%patch_oce%bathymetry_c = 0.0_wp
    ptr_patch%patch_oce%bathymetry_e = 0.0_wp
    !ptr_patch%patch_oce%bathymetry_v = 0.0_wp

    ptr_patch%patch_oce%lsm_oce_c = 0
    ptr_patch%patch_oce%lsm_oce_e = 0
    ptr_patch%patch_oce%dolic_c = 0
    ptr_patch%patch_oce%dolic_e = 0

    ptr_patch%patch_oce%wet_c = 0.0_wp
    ptr_patch%patch_oce%wet_e = 0.0_wp
    !ptr_patch%patch_oce%wet_i = 0.0_wp

    ! #slo# - Deallocation missing
!     ptr_patch%patch_oce%edge2cell_coeff     = 0.0_wp
!     ptr_patch%patch_oce%edge2vert_coeff     = 0.0_wp
    DO ie = 1,3
      ptr_patch%patch_oce%edge2cell_coeff_cc(:,:,:)%x(ie)    = 0.0_wp
      ptr_patch%patch_oce%edge2cell_coeff_cc_t(:,:,:)%x(ie)  = 0.0_wp
      !ptr_patch%patch_oce%edge2vert_coeff_t(:,:,:)%x(ie)    = 0.0_wp
      ptr_patch%patch_oce%edge2vert_coeff_cc(:,:,:)%x(ie)    = 0.0_wp
      ptr_patch%patch_oce%edge2vert_coeff_cc_t(:,:,:)%x(ie)  = 0.0_wp
    END DO
    ptr_patch%patch_oce%fixed_vol_norm      = 0.0_wp
    ptr_patch%patch_oce%variable_vol_norm   = 0.0_wp
    ptr_patch%patch_oce%variable_dual_vol_norm = 0.0_wp

!      ptr_patch%patch_oce%cell2edge_vec%v1              = 0.0_wp
!      ptr_patch%patch_oce%cell2edge_vec%v2              = 0.0_wp
!      ptr_patch%patch_oce%cell2edge_weight%v1           = 0.0_wp
!      ptr_patch%patch_oce%cell2edge_weight%v2           = 0.0_wp
!      ptr_patch%patch_oce%vertex2dualedge_mid_vec%v1    = 0.0_wp
!      ptr_patch%patch_oce%vertex2dualedge_mid_vec%v2    = 0.0_wp
!      ptr_patch%patch_oce%vertex2dualedge_mid_weight%v1 = 0.0_wp
!      ptr_patch%patch_oce%vertex2dualedge_mid_weight%v2 = 0.0_wp
!      ptr_patch%patch_oce%mid_dual_edge%lat             = 0.0_wp
!      ptr_patch%patch_oce%mid_dual_edge%lat             = 0.0_wp
     ptr_patch%patch_oce%dist_cell2edge              = 0.0_wp

    ptr_patch%patch_oce%geofac_div                    = 0.0_wp
    ptr_patch%patch_oce%geofac_qdiv                   = 0.0_wp
    ptr_patch%patch_oce%geofac_rot                    = 0.0_wp
    ptr_patch%patch_oce%geofac_n2s                    = 0.0_wp
    !ptr_patch%patch_oce%geofac_grg                    = 0.0_wp

    !
    ! Filling ocean patch with data provided by the grid generator
    !
    CALL read_netcdf_ocean_domain( )

    !
    ! Filling the vertical domain of the ocean w.r.t. bathymetry
    !
    CALL fill_vertical_ocean_domain( )

    !
    ! Calculate reconstruction weights needed in patch_ocean
    !
    CALL init_scalar_product( ptr_patch )

! write(*,*)'now call orig scalar'
     !CALL init_scalar_product_orig( ptr_patch )
    !
    ! Calculate geometrical factors used in divergence and rotation
    !
    CALL calc_geo_factors( ptr_patch )

    CALL message (TRIM(routine), 'end')

  END SUBROUTINE init_ocean_patch

  !-----------------------------------------------------------------------------
  !>
  !! Reads in ocean bathymetry and surface land-sea-mask from netcdf file
  !!
  !! Reads in bathymetric depths and surface land-sea-mask of the ocean surface
  !! on cells and edges. The data sets are provided by the grid-generator.
  !! For the case of coupling with the atmosphere, the surface land-sea-mask
  !! must be used by the atmosphere to ensure the usage of the same distribution
  !! of continents in both components.
  !!
  !! @par Revision History
  !! Initial release by Stephan Lorenz, MPI-M (2010-02-19)
  !!
  SUBROUTINE read_netcdf_ocean_domain ()


    CHARACTER(filename_max) :: ogrid_file !< file name for reading
    CHARACTER(len=MAX_CHAR_LENGTH), PARAMETER :: &
               & routine = ('mo_ocean_topo:read_netcdf_ocean_domain')
    LOGICAL :: l_exist
    INTEGER :: i_lev, no_cells, no_edges, minlsm, maxlsm
    INTEGER :: ncid, dimid, varid, nfloc_stat
    INTEGER :: array_c_int (ptr_patch%n_patch_cells), &  ! slo: todo: set zero!
            &  array_e_int (ptr_patch%n_patch_edges)
    REAL(wp):: array_c_real(ptr_patch%n_patch_cells), &
            &  array_e_real(ptr_patch%n_patch_edges)

   INTEGER :: jk !,je, jb
   !INTEGER :: rl_start, rl_end
   !INTEGER :: i_startblk, i_endblk, i_startidx, i_endidx
   !INTEGER,  DIMENSION(:,:,:),   POINTER :: iidx, iblk
    !--------------------------------------------------------------------------

    CALL message (TRIM(routine), 'start')

    i_lev = ptr_patch%level

    ! generate file name
    WRITE (ogrid_file,'(a,i0,a,i2.2,a)') 'iconR',nroot,'B',i_lev, '-grid.nc'

    INQUIRE (FILE=ogrid_file, EXIST=l_exist)
    IF (.NOT.l_exist) THEN
      CALL finish(TRIM(routine),'ocean_grid file is not found.')
    END IF

    ! open file
    CALL nf(nf_open(TRIM(ogrid_file), NF_NOWRITE, ncid))
    WRITE(message_text,'(a,a)') 'Read from ocean_grid file ', TRIM(ogrid_file)
    CALL message( TRIM(routine),TRIM(message_text))

    ! get and check number of cells and edges
    CALL nf(nf_inq_dimid(ncid, 'cell', dimid))
    CALL nf(nf_inq_dimlen(ncid, dimid, no_cells))
    CALL nf(nf_inq_dimid(ncid, 'edge', dimid))
    CALL nf(nf_inq_dimlen(ncid, dimid, no_edges))

    WRITE(message_text,'(3(a,i6))') 'No of cells =', no_cells,'  no of edges =',no_edges, &
      &                           '  no of verts =', ptr_patch%n_patch_verts
    CALL message( TRIM(routine),TRIM(message_text))

    IF(ptr_patch%n_patch_cells /= no_cells) THEN
      CALL finish(TRIM(ROUTINE),&
      & 'Number of patch cells and cells in ocean_grid file do not match.')
    ENDIF
    IF(ptr_patch%n_patch_edges /= no_edges) THEN
      CALL finish(TRIM(ROUTINE),&
      & 'Number of patch edges and edges in ocean_grid file do not match.')
    ENDIF
    ! These arrays are not included in standard icon-grid, but they are
    ! created by "create_ocean_grid"

    ! get land-sea-mask on cells, integer marks are:
    ! inner sea (-2), boundary sea (-1, cells and vertices), boundary (0, edges),
    ! boundary land (1, cells and vertices), inner land (2)
    nfloc_stat = nf_inq_varid(ncid, 'cell_sea_land_mask', varid)
    IF (nfloc_stat == nf_noerr ) THEN
      CALL nf(nf_get_var_int(ncid, varid, array_c_int(:)))
      CALL reshape_int ( array_c_int (:), ptr_patch%nblks_c, ptr_patch%npromz_c, &
        &                ptr_patch%patch_oce%lsm_oce_c(:,1,:) )
    ELSE
      CALL message( TRIM(routine),'WARNING: no land-sea-mask for ocean cells read')
      ! set land-sea-mask to sea
      ptr_patch%patch_oce%lsm_oce_c(:,1,:) = -2
    END IF

    ! get land-sea-mask on edges
    nfloc_stat = nf_inq_varid(ncid, 'edge_sea_land_mask', varid)
    IF (nfloc_stat == nf_noerr ) THEN
      CALL nf(nf_get_var_int(ncid, varid, array_e_int(:)))
      CALL reshape_int ( array_e_int (:), ptr_patch%nblks_e, ptr_patch%npromz_e, &
        &                ptr_patch%patch_oce%lsm_oce_e(:,1,:) )
    ELSE
      CALL message( TRIM(routine),'WARNING: no land-sea-mask for ocean edges read')
      ! set land-sea-mask to sea
      ptr_patch%patch_oce%lsm_oce_e(:,1,:) = -2
    END IF

    ! get bathymetry (elevation) at cells - negative for ocean bathymetry
    nfloc_stat = nf_inq_varid(ncid, 'cell_elevation', varid)
    IF (nfloc_stat == nf_noerr ) THEN
      CALL nf(nf_get_var_double(ncid, varid, array_c_real(:)))
      CALL reshape_real( array_c_real(:), ptr_patch%nblks_c, ptr_patch%npromz_c, &
        &                ptr_patch%patch_oce%bathymetry_c )
    ELSE
      CALL message( TRIM(routine),'WARNING: no bathymetry for ocean cells read')
      ! set bathymetry to constant value
      ptr_patch%patch_oce%bathymetry_c(:,:) = -3000.0_wp
    END IF

    ! get bathymetry (elevation) at edges - negative for ocean bathymetry
    nfloc_stat = nf_inq_varid(ncid, 'edge_elevation', varid)
    IF (nfloc_stat == nf_noerr ) THEN
      CALL nf(nf_get_var_double(ncid, varid, array_e_real(:)))
      CALL reshape_real( array_e_real(:), ptr_patch%nblks_e, ptr_patch%npromz_e, &
        &                ptr_patch%patch_oce%bathymetry_e )
    ELSE
      CALL message( TRIM(routine),'WARNING: no bathymetry for ocean edges read')
      ! set bathymetry to constant value
      ptr_patch%patch_oce%bathymetry_e(:,:) = -3000.0_wp
    END IF

    !  #slo# 2010-12-07 - ERROR lsm_c=0, lsm_e=-2 in create_ocean_grid for
    !                     grid_geometry_conditions=1, use cell_elevation instead
  ! maxlsm = MAXVAL(ptr_patch%patch_oce%lsm_oce_e(:,1,:))
  ! minlsm = MINVAL(ptr_patch%patch_oce%lsm_oce_e(:,1,:))

  ! IF (maxlsm == -2 .and. minlsm == -2) THEN

  !   CALL message( TRIM(routine),'WARNING: INCORRECT land-sea-mask, use bathy for correction')

  !   ! warning - no boundaries set - must be done by grid generator
  !   ptr_patch%patch_oce%lsm_oce_c(:,1,:) = 2
  !   WHERE ( ptr_patch%patch_oce%bathymetry_c(:,:) < -6.0_wp )  ! MPIOM surface cell = 6m
  !     ptr_patch%patch_oce%lsm_oce_c(:,1,:) = -2
  !   END WHERE
  !   ptr_patch%patch_oce%lsm_oce_e(:,1,:) = 2
  !   WHERE ( ptr_patch%patch_oce%bathymetry_e(:,:) < -6.0_wp )  ! MPIOM surface cell = 6m
  !     ptr_patch%patch_oce%lsm_oce_e(:,1,:) = -2
  !   END WHERE

  ! END IF

    !  #slo# 2010-12-16 - lsm_e=1 and -1 for boundary edges in create_ocean_grid
    !                     correct these values to zero (=boundary)
  ! CALL message( TRIM(routine),'WARNING: land-sea-mask on edges - set to 0 for boundaries')
  ! !CALL message( TRIM(routine),'WARNING: bathymetry    on edges - set to 0 for boundaries')
  ! WHERE ( ptr_patch%patch_oce%lsm_oce_e(:,1,:) == 1 .OR. &
  !         ptr_patch%patch_oce%lsm_oce_e(:,1,:) == -1 ) 
  !   ptr_patch%patch_oce%lsm_oce_e(:,1,:) = 0
  !   ptr_patch%patch_oce%bathymetry_e(:,:) = 0.0_wp
  ! END WHERE
  ! !  #slo# 2010-12-16 - lsm_c=-1 at too many grid-points
  ! !                     correct these values to -2 (=sea)
  ! CALL message( TRIM(routine),'WARNING: land-sea-mask on cells - set to -2 for sea-boundaries')
  ! WHERE ( ptr_patch%patch_oce%lsm_oce_c(:,1,:) == -1 ) 
  !   ptr_patch%patch_oce%lsm_oce_c(:,1,:) = -2
  ! END WHERE

  ! !  #slo# 2011-03-22: workaroung for issue 961
  ! !   - lsm_e=0 (boundary) but bathy_e is deep (Stommel basin) -> set bathy_e=0.
  ! CALL message( TRIM(routine),'WARNING: bathymetry    on edges - set to 0 for boundaries')
  ! WHERE ( ptr_patch%patch_oce%lsm_oce_e(:,1,:) == 0 )
  !   ptr_patch%patch_oce%bathymetry_e(:,:) = 0.0_wp
  ! END WHERE

    !write(*,*) 'read_netcdf_ocean_domain: lsm_oce_c:'
    !write(*,'(45i2)') ptr_patch%patch_oce%lsm_oce_c(:,1,:)
! #slo# 2011-02-28: levels below surface do not exist before fill_vertical_domain is called
!    DO jk = 1, n_zlev
!      WHERE ( ptr_patch%patch_oce%lsm_oce_e(:,jk,:) == 1 .OR. &
!             ptr_patch%patch_oce%lsm_oce_e(:,jk,:) == -1 ) 
!       ptr_patch%patch_oce%lsm_oce_e(:,jk,:) = 0
!       ptr_patch%patch_oce%bathymetry_e(:,:) = 0.0_wp
!     END WHERE
!     !  #slo# 2010-12-16 - lsm_c=-1 at too many grid-points
!     !                     correct these values to -2 (=sea)
!     CALL message( TRIM(routine),'WARNING: land-sea-mask on cells - set to -2 for sea-boundaries')
!     WHERE ( ptr_patch%patch_oce%lsm_oce_c(:,jk,:) == -1 ) 
!       ptr_patch%patch_oce%lsm_oce_c(:,jk,:) = -2
!     END WHERE
!   END DO

!     !consistency check
!     rl_start = 1
!     rl_end = min_rledge
!     i_startblk = ptr_patch%edges%start_blk(rl_start,1)
!     i_endblk   = ptr_patch%edges%end_blk(rl_end,1)
! 
!     iidx => ptr_patch%edges%cell_idx
!     iblk => ptr_patch%edges%cell_blk
! 
!     !Case: neighbor cells 1 and 2 are of the same type, but common edge is different
!     DO jb = i_startblk, i_endblk
!       CALL get_indices_e(ptr_patch, jb, i_startblk, i_endblk, &
!                         i_startidx, i_endidx, rl_start, rl_end)
!       DO jk = 1, n_zlev
! 
!         DO je = i_startidx, i_endidx
! 
!           IF ( (ptr_patch%patch_oce%lsm_oce_c(iidx(je,jb,2),jk,iblk(je,jb,2))&
!           & == ptr_patch%patch_oce%lsm_oce_c(iidx(je,jb,1),jk,iblk(je,jb,1)))&
!           &.AND.ptr_patch%patch_oce%lsm_oce_c(iidx(je,jb,1),jk,iblk(je,jb,1))<0) THEN
! 
!             IF(   ptr_patch%patch_oce%lsm_oce_c(iidx(je,jb,1),jk,iblk(je,jb,1))&
!                & /= ptr_patch%patch_oce%lsm_oce_e(je,jk,jb))THEN
!               write(*,*)'WARNING: INCONSISTENT LSM', jk, je,jb,iidx(je,jb,2),iblk(je,jb,2),&
!                                                            & iidx(je,jb,1),iblk(je,jb,1)
!               write(*,*)'lsm values:cell1, cell2, edge:',&
!               &ptr_patch%patch_oce%lsm_oce_c(iidx(je,jb,1),jk,iblk(je,jb,1)),&
!               &ptr_patch%patch_oce%lsm_oce_c(iidx(je,jb,2),jk,iblk(je,jb,2)),&
!               &ptr_patch%patch_oce%lsm_oce_e(je,jk,jb)
!               write(*,*)'apply correction'
!               ptr_patch%patch_oce%lsm_oce_e(je,jk,jb)&
!               & = ptr_patch%patch_oce%lsm_oce_c(iidx(je,jb,2),jk,iblk(je,jb,2))
!             ENDIF
!           ENDIF
!         ENDDO
!       END DO
!     END DO
! 
!  !Case: neighbor cells 1 and 2 are of different type, but common edge is not boundary
!   DO jb = i_startblk, i_endblk
!     CALL get_indices_e(ptr_patch, jb, i_startblk, i_endblk, &
!                         i_startidx, i_endidx, rl_start, rl_end)
!     DO jk = 1, n_zlev
!       DO je = i_startidx, i_endidx
! 
! 
!         IF ( ptr_patch%patch_oce%lsm_oce_c(iidx(je,jb,2),jk,iblk(je,jb,2))&
!         & /= ptr_patch%patch_oce%lsm_oce_c(iidx(je,jb,1),jk,iblk(je,jb,1))&
!         &.AND.(    ptr_patch%patch_oce%lsm_oce_c(iidx(je,jb,1),jk,iblk(je,jb,1))<0&
!               &.OR.ptr_patch%patch_oce%lsm_oce_c(iidx(je,jb,2),jk,iblk(je,jb,2))<0)) THEN
! 
!           IF( ptr_patch%patch_oce%lsm_oce_e(je,jk,jb)/=boundary)THEN
!             write(*,*)'WARNING: NON-BOUNDARY-EDGE BETWEEN BOUNDARY CELLS', jk, je,jb,iidx(je,jb,2),iblk(je,jb,2),&
!                                                                                    & iidx(je,jb,1),iblk(je,jb,1)
!           write(*,*)'lsm values:cell1, cell2, edge:',&
!            &ptr_patch%patch_oce%lsm_oce_c(iidx(je,jb,1),jk,iblk(je,jb,1)),&
!            &ptr_patch%patch_oce%lsm_oce_c(iidx(je,jb,2),jk,iblk(je,jb,2)),&
!            &ptr_patch%patch_oce%lsm_oce_e(je,jk,jb)
!           write(*,*)'apply correction'
!               ptr_patch%patch_oce%lsm_oce_e(je,jk,jb) = boundary
!         ENDIF
! 
!       ENDIF
!     ENDDO
!   END DO
! END DO


  END SUBROUTINE read_netcdf_ocean_domain

  !-----------------------------------------------------------------------------
  !>
  !! Fill 3-dimensional land-sea-mask vertically using ocean bathymetry
  !!
  !! Calculates the vertical grid levels in z (meter) using the thickness of the elemental
  !! prisms (del_zlev_i) that are read from the ocean namelist.
  !!
  !! The 3-dim land-sea-mask is filled with values for interieur ocean, boundary
  !! ocean, and land, where parameter values from mo_impl_constants are used. The three
  !! dimensions are two for the nproma-blocking  and the middle one for the vertical levels.
  !!
  !! @par Revision History
  !! Initial release by Stephan Lorenz, MPI-M (2010-02-19)
  !! Modified by Stephan Lorenz,        MPI-M (2010-08)
  !!  - fill dolic and sea_boundary as well
  !!
  SUBROUTINE fill_vertical_ocean_domain ()


    CHARACTER(len=MAX_CHAR_LENGTH), PARAMETER :: &
    & routine = ('mo_ocean_topo:fill_vertical_ocean_domain')

    INTEGER :: jb, jc, je, jk, ji, nblks_c, nblks_e, npromz_c, npromz_e
    INTEGER :: rl_start, rl_end, i_startblk, i_endblk, i_startidx, i_endidx
    INTEGER :: n_zlvp, noct1_c, noct1_e, inolsm
    INTEGER :: nolnd_c(n_zlev), nosea_c(n_zlev), nogllnd_c, noglsea_c
    INTEGER :: nolnd_e(n_zlev), nosea_e(n_zlev), nogllnd_e, noglsea_e
    INTEGER :: nobnd_e(n_zlev), nosbd_c(n_zlev), nolbd_c(n_zlev)
    INTEGER :: noglbnd_e, noglsbd_c, nogllbd_c
    INTEGER :: iic1, ibc1, iic2, ibc2, idxe, ible

    REAL(wp):: perc_lnd_c(n_zlev), perc_gllnd_c
    REAL(wp):: perc_lnd_e(n_zlev), perc_gllnd_e
    INTEGER,  DIMENSION(:,:,:),   POINTER :: iidx, iblk

    INTEGER :: i_startblk_c, i_endblk_c, i_startidx_c, i_endidx_c
    INTEGER :: i_startblk_e, i_endblk_e, i_startidx_e, i_endidx_e
    INTEGER :: rl_start_e, rl_end_e, rl_start_c, rl_end_c
    !-----------------------------------------------------------------------------

    CALL message (TRIM(routine), 'start')

    !-----------------------------
    !
    ! Basic z-level configuration:
    !
    ! n_zlev    : number of z-coordinate surfaces - module global_variables, read in from namelist
    ! del_zlev_m: thickness of elemental prism - read in from namelist
    ! zlev_m    : position of coordinate surfaces in meters below zero surface
    ! zlev_i    : surface at the top of the respective z-coordinate surface (intermediate level)
    ! del_zlev_i: distance between two z-coordinate surfaces
    !
    !-----------------------------

!   WRITE(message_text,'(a,i4)') ' n_zlev =', n_zlev
!   CALL message( TRIM(routine),TRIM(message_text))

    ptr_patch%patch_oce%zlev_m(1) = 0.5_wp * ptr_patch%patch_oce%del_zlev_m(1)
    ptr_patch%patch_oce%zlev_i(1) = 0.0_wp

    ! zlev_i    : surface in the middle of two z-coordinate surfaces: n_zlev+1 levels
    DO jk = 2, n_zlev+1
      ptr_patch%patch_oce%zlev_i(jk) = ptr_patch%patch_oce%zlev_i(jk-1) + &
        &                            ptr_patch%patch_oce%del_zlev_m(jk-1)
    END DO

    ! zlev_m    : position of coordinate surfaces in meters below zero surface.
    DO jk = 2, n_zlev
      ptr_patch%patch_oce%zlev_m(jk) = 0.5_wp * ( ptr_patch%patch_oce%zlev_i(jk+1) + &
        &                                      ptr_patch%patch_oce%zlev_i(jk)  )
    END DO

    ! del_zlev_i: distance between two z-coordinate surfaces.
    !             The first is the distance from the ocean surface = zlev_m(1)
    ptr_patch%patch_oce%del_zlev_i(1) = ptr_patch%patch_oce%zlev_m(1)
    DO jk = 2, n_zlev
      ptr_patch%patch_oce%del_zlev_i(jk) = ptr_patch%patch_oce%zlev_m(jk) - &
        &                                ptr_patch%patch_oce%zlev_m(jk-1)
    END DO


    !-----------------------------
    !
    ! Fill the 3-dim land-sea-mask and number of deepest ocean layer in column 'dolic'
    !
    !  - 2011-04-01: missing condition that at least one layer below the surface layer exists
    !    which would be an analogon to the smoothing condition in grid.create_ocean_grid
    !    (at least 2 neighbours of a sea-cell must be a sea-cell as well, only 1 can be land)
    !                
    !
    !-----------------------------

    ! values for the blocking
    nblks_c = ptr_patch%nblks_c
    npromz_c = ptr_patch%npromz_c
    nblks_e = ptr_patch%nblks_e
    npromz_e = ptr_patch%npromz_e
    nogllnd_c = 0
    noglsea_c = 0
    nogllnd_e = 0
    noglsea_e = 0
    noglbnd_e = 0
    noglsbd_c = 0
    nogllbd_c = 0
    noct1_c = 0
    noct1_e = 0

   !jk=0
   !do jc=1,nproma
   !do jb=1,nblks_c
   !IF ( ptr_patch%patch_oce%lsm_oce_c(jc,1,jb) == sea_boundary ) then
   !  jk=jk+1
   !  write(*,*) jk,'lsm_c, blk,idx : ',ptr_patch%patch_oce%lsm_oce_c(jc,1,jb),jb,jc
   !END IF
   !enddo
   !enddo

   !jk=0
   !do je=1,nproma
   !do jb=1,nblks_e
   !IF ( ptr_patch%patch_oce%lsm_oce_e(je,1,jb) == boundary ) then
   !  jk=jk+1
   !  write(*,*) jk,'lsm_e, blk,idx : ',ptr_patch%patch_oce%lsm_oce_e(je,1,jb),jb,je
   !END IF
   !enddo
   !enddo

    ! coordinate surfaces - n_zlev z-levels:
    ZLEVEL_LOOP: DO jk = 1, n_zlev

      !-----------------------------
      ! cells
      !  - values for BOUNDARY set below

      nolnd_c(jk)=0
      nosea_c(jk)=0

      !i_startblk = ptr_patch%cells%start_blk(1,1)
      !DO jb = i_startblk, nblks_c

      DO jb = 1, nblks_c

        !CALL get_indices_c(ptr_patch, jb, i_startblk, nblks_c, &
        !  &                i_startidx, i_endidx, 1)

        i_endidx=nproma
        IF (jb==nblks_c) i_endidx=npromz_c

        !-----------------------------
        ! set dolic and wet grid points:
        !  - if bathymetry is deeper than or equal to the coordinate surface (zlev_m)
        !    then grid point is wet; dolic is in that level

        DO je = 1, i_endidx

          !  surface level of lsm and dolic defined by gridgenerator, not the current bathymetry
          IF (jk == 1) THEN

            ! counts sea cells from lsm
            IF (ptr_patch%patch_oce%lsm_oce_c(je,jk,jb) <= -1) THEN
              nosea_c(jk) = nosea_c(jk)+1
              ptr_patch%patch_oce%dolic_c(je,jb) = jk
            ELSE IF (ptr_patch%patch_oce%lsm_oce_c(je,jk,jb) >=  1) THEN
              nolnd_c(jk) = nolnd_c(jk)+1
            ELSE ! 0 not defined
              STOP ' lsm_oce_c = 0'
            END IF

            ! counts sea points from bathymetry
            IF (ptr_patch%patch_oce%bathymetry_c(je,jb) <= -ptr_patch%patch_oce%zlev_m(jk)) &
              &   noct1_c = noct1_c+1

          ELSE

            IF (ptr_patch%patch_oce%bathymetry_c(je,jb) <= -ptr_patch%patch_oce%zlev_m(jk)) THEN
              nosea_c(jk)=nosea_c(jk)+1
              ptr_patch%patch_oce%lsm_oce_c(je,jk,jb) = SEA
              ptr_patch%patch_oce%dolic_c(je,jb) = jk
            ELSE IF (ptr_patch%patch_oce%bathymetry_c(je,jb)>-ptr_patch%patch_oce%zlev_m(jk)) THEN
              nolnd_c(jk)=nolnd_c(jk)+1
              ptr_patch%patch_oce%lsm_oce_c(je,jk,jb) = LAND
            END IF

          END IF

        END DO

      END DO

      !  percentage of land area per level and global value
      inolsm = nolnd_c(jk) + nosea_c(jk)
      IF (inolsm == 0 ) THEN
        IF (jk == 1 ) CALL message (TRIM(routine), 'WARNING - number of cell points is zero?')
        !CALL finish('mo_ocean_topo - no cell points')
        perc_lnd_c(jk) = 0.0_wp
      ELSE
        perc_lnd_c(jk) = REAL(nolnd_c(jk),wp)/REAL(nosea_c(jk)+nolnd_c(jk),wp)*100.0_wp
        nogllnd_c = nogllnd_c + nolnd_c(jk)
        noglsea_c = noglsea_c + nosea_c(jk)
      END IF


      !-----------------------------
      ! edges
      !  - values for BOUNDARY set below, LAND, SEA only

      nolnd_e(jk)=0
      nosea_e(jk)=0

      DO jb = 1, nblks_e

        i_endidx=nproma
        IF (jb==nblks_e) i_endidx=npromz_e

        DO je = 1, i_endidx

          !  surface level of lsm and dolic defined by gridgenerator, not the current bathymetry
          IF (jk == 1) THEN

            ! count and define sea edges from lsm - boundary edges are counted as land
            IF (ptr_patch%patch_oce%lsm_oce_e(je,jk,jb) == -2 ) THEN
              nosea_e(jk)=nosea_e(jk)+1
              ptr_patch%patch_oce%dolic_e(je,jb) = jk
            ELSE
              nolnd_e(jk)=nolnd_e(jk)+1
            END IF

            ! counts sea points from bathymetry
            IF (ptr_patch%patch_oce%bathymetry_e(je,jb) <= -ptr_patch%patch_oce%zlev_m(jk)) THEN
              noct1_e = noct1_e+1
            ENDIF

          ELSE  ! jk>1

            IF (ptr_patch%patch_oce%bathymetry_e(je,jb) <= -ptr_patch%patch_oce%zlev_m(jk)) THEN
              nosea_e(jk)=nosea_e(jk)+1
              ptr_patch%patch_oce%lsm_oce_e(je,jk,jb) = SEA
              ptr_patch%patch_oce%dolic_e(je,jb) =jk
            ELSE IF (ptr_patch%patch_oce%bathymetry_e(je,jb)>-ptr_patch%patch_oce%zlev_m(jk)) THEN
              nolnd_e(jk)=nolnd_e(jk)+1
              ptr_patch%patch_oce%lsm_oce_e(je,jk,jb) = LAND
            END IF

          END IF

        END DO

      END DO

      !  percentage of land area per level and global value
      inolsm = nolnd_e(jk) + nosea_e(jk)
      IF (inolsm == 0 ) THEN
        IF (jk == 1 ) CALL message (TRIM(routine), 'WARNING - number of edge points is zero?')
!       CALL finish('mo_ocean_topo - no edge points')
        perc_lnd_e(jk) = 0.0_wp
      ELSE
        perc_lnd_e(jk) = REAL(nolnd_e(jk),wp)/REAL(nosea_e(jk)+nolnd_e(jk),wp)*100.0_wp
        nogllnd_e = nogllnd_e + nolnd_e(jk)
        noglsea_e = noglsea_e + nosea_e(jk)
      END IF

      !-----------------------------
      ! set values for BOUNDARY at edges (get values of neighbouring cells)
      !  - if the two corresponding cells are differing then edge is BOUNDARY
      !    (they are not both LAND or SEA)
      !  - no output of number of BOUNDARY yet

      nobnd_e(jk)=0

      rl_start = 1           !  #slo# - cannot run with holes on land in grid
      rl_end = min_rledge

      ! values for the blocking
      i_startblk = ptr_patch%edges%start_blk(rl_start,1)
      i_endblk   = ptr_patch%edges%end_blk(rl_end,1)
      !
      ! loop through all patch edges
      BLK_LOOP_E: DO jb = i_startblk, i_endblk

        CALL get_indices_e  &
          &  (ptr_patch, jb, i_startblk, i_endblk, i_startidx, i_endidx, rl_start, rl_end)

        IDX_LOOP_E: DO je =  i_startidx, i_endidx

          ! Get indices/blks of cells 1 and 2 adjacent to edge (je,jb)
          ! #slo# 2010/12: check with grid-generator
          !IF (jk >= 2) THEN
            iic1 = ptr_patch%edges%cell_idx(je,jb,1)
            ibc1 = ptr_patch%edges%cell_blk(je,jb,1)
            iic2 = ptr_patch%edges%cell_idx(je,jb,2)
            ibc2 = ptr_patch%edges%cell_blk(je,jb,2)
            !
            ! cells may have -2, -1, 1, 2 for sea, sea_boundary, land_boundary, land:
            IF ( (ptr_patch%patch_oce%lsm_oce_c(iic1,jk,ibc1) < 0)  .and.   &
              &  (ptr_patch%patch_oce%lsm_oce_c(iic2,jk,ibc2) > 0) )        &
              &   ptr_patch%patch_oce%lsm_oce_e(je,jk,jb) = BOUNDARY
            IF ( (ptr_patch%patch_oce%lsm_oce_c(iic1,jk,ibc1) > 0)  .and.   &
              &  (ptr_patch%patch_oce%lsm_oce_c(iic2,jk,ibc2) < 0) )        &
              &   ptr_patch%patch_oce%lsm_oce_e(je,jk,jb) = BOUNDARY
            IF ( ptr_patch%patch_oce%lsm_oce_e(je,jk,jb) == BOUNDARY )      &
              &  nobnd_e(jk)=nobnd_e(jk)+1

          !END IF  !  jk >=2

        END DO IDX_LOOP_E

      END DO BLK_LOOP_E

      !-----------------------------
      ! set values for LAND_BOUNDARY and SEA_BOUNDARY at cells
      !  - get values of neighbouring edges
      !  - if one of 3 edges of a sea-cell is BOUNDARY then cell is SEA_BOUNDARY
      !  - if one of 3 edges of a land-cell is BOUNDARY then cell is LAND_BOUNDARY

      nosbd_c(jk)=0
      nolbd_c(jk)=0

      rl_start = 1           !  #slo# - cannot run with holes on land in grid
      rl_end = min_rlcell

      ! values for the blocking
      i_startblk = ptr_patch%cells%start_blk(rl_start,1)
      i_endblk   = ptr_patch%cells%end_blk(rl_end,1)
      !
      ! loop through all patch cells
      BLK_LOOP_C: DO jb = i_startblk, i_endblk

        CALL get_indices_c  &
          &  (ptr_patch, jb, i_startblk, i_endblk, i_startidx, i_endidx, rl_start, rl_end)

        IDX_LOOP_C: DO jc =  i_startidx, i_endidx

          !IF (jk >= 2) THEN  ! #slo# 2010-12-07 - including surface while gridgen not complete

            ! sea points
            IF (ptr_patch%patch_oce%lsm_oce_c(jc,jk,jb) < 0) THEN
            ! #slo# 2010-12-16 - corrected in read-bathy for wrong slm,
            ! could also be done here with:
            ! ptr_patch%patch_oce%lsm_oce_c(jc,jk,jb) = SEA
              DO ji = 1, 3
                ! Get indices/blks of edges 1 to 3 adjacent to cell (jc,jb)
                idxe = ptr_patch%cells%edge_idx(jc,jb,ji)
                ible = ptr_patch%cells%edge_blk(jc,jb,ji)
                ! if one of lsm_e is boundary then lsm_c is sea_boundary
                IF ( ptr_patch%patch_oce%lsm_oce_e(idxe,jk,ible) == BOUNDARY ) &
                  &  ptr_patch%patch_oce%lsm_oce_c(jc,jk,jb) = SEA_BOUNDARY
         !      IF ( ptr_patch%patch_oce%lsm_oce_e(idxe,jk,ible) == BOUNDARY.and.jk==1 ) &
         !        & WRITE(*,'(a,8i4)') '  lsm_e, lsm_c, idxe, ible, jc, jb, jk: ', &
         !        &             ptr_patch%patch_oce%lsm_oce_e(idxe,jk,ible), &
         !        &             ptr_patch%patch_oce%lsm_oce_c(jc,jk,jb), &
         !        &   idxe, ible, jc, jb, jk
              END DO
              IF ( ptr_patch%patch_oce%lsm_oce_c(jc,jk,jb) == SEA_BOUNDARY )   &
                &  nosbd_c(jk)=nosbd_c(jk)+1
         !    if (jk==1.and.ptr_patch%patch_oce%lsm_oce_c(jc,jk,jb) == SEA_BOUNDARY) then
         !      WRITE(*,'(a,6i4)') ' lsm_c, jc, jb, jk: ', &
         !        &             ptr_patch%patch_oce%lsm_oce_c(jc,jk,jb), &
         !        &   jc, jb, jk
         !    endif
         !    if (jk==2) then
         !      IF ( ptr_patch%patch_oce%lsm_oce_c(jc,1,jb) /= &
         !      &    ptr_patch%patch_oce%lsm_oce_c(jc,2,jb))  &
         !      & WRITE(*,*) ' lsm_c(1),lsm_c(2), jc, jb, jk: ', &
         !          &             ptr_patch%patch_oce%lsm_oce_c(jc,1,jb), &
         !          &             ptr_patch%patch_oce%lsm_oce_c(jc,2,jb), &
         !          &   jc, jb, jk
         !   endif
            END IF  !  lsm_c < 0

            ! land points
            IF (ptr_patch%patch_oce%lsm_oce_c(jc,jk,jb) > 0) THEN
              DO ji = 1, 3
              ! Get indices/blks of edges 1 to 3 adjacent to cell (jc,jb)
                idxe = ptr_patch%cells%edge_idx(jc,jb,ji)
                ible = ptr_patch%cells%edge_blk(jc,jb,ji)
                IF ( ptr_patch%patch_oce%lsm_oce_e(idxe,jk,ible) == BOUNDARY ) &
                  &  ptr_patch%patch_oce%lsm_oce_c(jc,jk,jb) = LAND_BOUNDARY
              END DO
              IF ( ptr_patch%patch_oce%lsm_oce_c(jc,jk,jb) == LAND_BOUNDARY )   &
                &  nolbd_c(jk)=nolbd_c(jk)+1
            END IF  !  lsm_c > 0

          !END IF  !  jk >=2

        END DO  IDX_LOOP_C

      END DO  BLK_LOOP_C
      noglbnd_e = noglbnd_e + nobnd_e(jk)
      noglsbd_c = noglsbd_c + nosbd_c(jk)
      nogllbd_c = nogllbd_c + nolbd_c(jk)

    END DO ZLEVEL_LOOP

    ! Output the levels
    WRITE(message_text,'(a,a)') &
    &     'LEVEL   zlev_m  Thickness   zlev_i  Distance ', &
    &     '    SEA_c    LAND_c  PERC_LND     SEA_e    LAND_e BOUND_e   SEA_B. LAND_B.'
    CALL message('', TRIM(message_text))
    DO jk = 1, n_zlev
      WRITE(message_text,'(a,i3,4f10.2,2i10,f10.2,2i10,3i8)') '.',  &
        &   jk, ptr_patch%patch_oce%zlev_m(jk), ptr_patch%patch_oce%del_zlev_m(jk), &
        &       ptr_patch%patch_oce%zlev_i(jk), ptr_patch%patch_oce%del_zlev_i(jk), &
        &   nosea_c(jk), nolnd_c(jk), perc_lnd_c(jk), nosea_e(jk), nolnd_e(jk),     &
        &   nobnd_e(jk), nosbd_c(jk), nolbd_c(jk)
      CALL message('', message_text)
    END DO

    ! Output last level
    inolsm = nogllnd_c + noglsea_c
    IF ( inolsm == 0 ) THEN
      CALL message (TRIM(routine), 'WARNING - number of global cell points is zero?')
      perc_gllnd_c = 0.0_wp
    ELSE
      perc_gllnd_c = REAL(nogllnd_c,wp)/REAL(noglsea_c+nogllnd_c,wp)*100.0_wp
    END IF
    inolsm = nogllnd_e + noglsea_e
    IF ( inolsm == 0 ) THEN
      CALL message (TRIM(routine), 'WARNING - number of global edge points is zero?')
      perc_gllnd_e = 0.0_wp
    ELSE
      perc_gllnd_e = REAL(nogllnd_e,wp)/REAL(noglsea_e+nogllnd_e,wp)*100.0_wp
    END IF
    n_zlvp = n_zlev + 1
    WRITE(message_text,'(a,f20.2,a,i9,i10,f10.2,2i10,3i8)') &
    &     'Bottom Level: ', ptr_patch%patch_oce%zlev_i(n_zlvp), &
    &     '    GLOBAL:',     noglsea_c, nogllnd_c, perc_gllnd_c, &
    &                        noglsea_e, nogllnd_e, noglbnd_e, noglsbd_c, nogllbd_c
    CALL message('', TRIM(message_text))

    ! Warnings occur if create_ocean_grid parameter mindepth is not half the
    ! depth of the surface level dzlev_m(1) in ocean_ctl (must not be an error)
    IF ( nosea_c(1) /= noct1_c ) THEN
      WRITE(message_text,'(a,i8,a,i8)') &
        &   'WARNING - surface sea-cells read = ',nosea_c(1), &
        &   ' - calculated from bathymetry = ',noct1_c
      CALL message(routine, TRIM(message_text))
    END IF
    IF ( nosea_e(1) /= noct1_e ) THEN
      WRITE(message_text,'(a,i8,a,i8)') &
        &   'WARNING - surface sea-edges read = ',nosea_e(1), &
        &   ' - calculated from bathymetry = ',noct1_e
      CALL message(routine, TRIM(message_text))
    END IF

    !-----------------------------
    ! set values of bathymetry to new non-individual dolic values

    DO jb = 1, nblks_c
      i_endidx=nproma
      IF (jb==nblks_c) i_endidx=npromz_c
        DO jc = 1, i_endidx
          ptr_patch%patch_oce%bathymetry_c(jc,jb) = &
            &  -ptr_patch%patch_oce%zlev_i(ptr_patch%patch_oce%dolic_c(jc,jb)+1)
      ENDDO
    ENDDO

    DO jb = 1, nblks_e
      i_endidx=nproma
      IF (jb==nblks_e) i_endidx=npromz_e
        DO je = 1, i_endidx
          ptr_patch%patch_oce%bathymetry_e(je,jb) = &
            &  -ptr_patch%patch_oce%zlev_i(ptr_patch%patch_oce%dolic_e(je,jb)+1)
      ENDDO
    ENDDO

    !-----------------------------
    ! set wet_c and wet_e to 1 at sea points including boundaries

    ! cells
    WHERE ( ptr_patch%patch_oce%lsm_oce_c(:,:,:) <= SEA_BOUNDARY )
      ptr_patch%patch_oce%wet_c(:,:,:) = 1.0_wp
    END WHERE

    ! edges
    WHERE ( ptr_patch%patch_oce%lsm_oce_e(:,:,:) <= SEA_BOUNDARY )
      ptr_patch%patch_oce%wet_e(:,:,:) = 1.0_wp
    END WHERE

    ! intermediate levels: same as wet_c
    !WHERE ( ptr_patch%patch_oce%lsm_oce_c(:,:,:) <= SEA_BOUNDARY )
    !  ptr_patch%patch_oce%wet_i(:,:,:) = 1.0_wp
    !END WHERE

    CALL message (TRIM(routine), 'end')

! iidx => ptr_patch%edges%cell_idx
! iblk => ptr_patch%edges%cell_blk
! 
!     !Case: neighbor cells 1 and 2 are of the same type, but common edge is different
!     DO jb = i_startblk, i_endblk
!       CALL get_indices_e(ptr_patch, jb, i_startblk, i_endblk, &
!                         i_startidx, i_endidx, rl_start, rl_end)
!       DO jk = 1, n_zlev
! 
!         DO je = i_startidx, i_endidx
! 
!           IF ( (ptr_patch%patch_oce%lsm_oce_c(iidx(je,jb,2),jk,iblk(je,jb,2))&
!           & == ptr_patch%patch_oce%lsm_oce_c(iidx(je,jb,1),jk,iblk(je,jb,1)))&
!           &.AND.ptr_patch%patch_oce%lsm_oce_c(iidx(je,jb,1),jk,iblk(je,jb,1))<0) THEN
! 
!             IF(   ptr_patch%patch_oce%lsm_oce_c(iidx(je,jb,1),jk,iblk(je,jb,1))&
!                & /= ptr_patch%patch_oce%lsm_oce_e(je,jk,jb))THEN
!               write(*,*)'fill_vertical WARNING: INCONSISTENT LSM', jk, &!je,jb,iidx(je,jb,2),iblk(je,jb,2),&
!                                                           ! & iidx(je,jb,1),iblk(je,jb,1)
!               !write(*,*)'lsm values:cell1, cell2, edge:',&
!               &ptr_patch%patch_oce%lsm_oce_c(iidx(je,jb,1),jk,iblk(je,jb,1)),&
!               &ptr_patch%patch_oce%lsm_oce_c(iidx(je,jb,2),jk,iblk(je,jb,2)),&
!               &ptr_patch%patch_oce%lsm_oce_e(je,jk,jb)
!               write(*,*)'apply correction'
!               ptr_patch%patch_oce%lsm_oce_e(je,jk,jb)&
!               & = ptr_patch%patch_oce%lsm_oce_c(iidx(je,jb,2),jk,iblk(je,jb,2))
!             ENDIF
!           ENDIF
!         ENDDO
!       END DO
!     END DO
! 
!  !Case: neighbor cells 1 and 2 are of different type, but common edge is not boundary
!   DO jb = i_startblk, i_endblk
!     CALL get_indices_e(ptr_patch, jb, i_startblk, i_endblk, &
!                         i_startidx, i_endidx, rl_start, rl_end)
!     DO jk = 1, n_zlev
!       DO je = i_startidx, i_endidx
! 
! 
!         IF ( ptr_patch%patch_oce%lsm_oce_c(iidx(je,jb,2),jk,iblk(je,jb,2))&
!         & /= ptr_patch%patch_oce%lsm_oce_c(iidx(je,jb,1),jk,iblk(je,jb,1))&
!         &.AND.(    ptr_patch%patch_oce%lsm_oce_c(iidx(je,jb,1),jk,iblk(je,jb,1))<0&
!               &.OR.ptr_patch%patch_oce%lsm_oce_c(iidx(je,jb,2),jk,iblk(je,jb,2))<0)) THEN
! 
!           IF( ptr_patch%patch_oce%lsm_oce_e(je,jk,jb)/=boundary)THEN
!             write(*,*)'fill_vertical WARNING: NON-BOUNDARY-EDGE BETWEEN BOUNDARY CELLS', jk,&! je,jb,iidx(je,jb,2),iblk(je,jb,2),&
!                                                                    !                & iidx(je,jb,1),iblk(je,jb,1)
!           !write(*,*)'lsm values:cell1, cell2, edge:',&
!            &ptr_patch%patch_oce%lsm_oce_c(iidx(je,jb,1),jk,iblk(je,jb,1)),&
!            &ptr_patch%patch_oce%lsm_oce_c(iidx(je,jb,2),jk,iblk(je,jb,2)),&
!            &ptr_patch%patch_oce%lsm_oce_e(je,jk,jb)
!           write(*,*)'apply correction'
!               ptr_patch%patch_oce%lsm_oce_e(je,jk,jb) = boundary
!         ENDIF
! 
!       ENDIF
!     ENDDO
!   END DO
! END DO
  END SUBROUTINE fill_vertical_ocean_domain
  !-------------------------------------------------------------------------
  !
  !>
  !! Computes the coefficients that determine the scalar product on the primal grid. This
  !! scalar product depends on the grid geometry only and  is used to formulate the primitive
  !! equations in weak form. The coefficients are applied in module "mo_scalar_product".
  !! The following components of the data type "ocean_patch" are filled:
  !!   edge2cell_coeff  : coefficients for edge to cell mapping
  !!   edge2cell_coeff_t: coefficients for transposed of edge to cell mappings
  !!   edge2vert_coeff  : coefficients for edge to vertex mapping
  !!   edge2vert_coeff_t: coefficients for transposed of edge to vertex mappings
  !!   fixed_vol_norm   : summed volume weight of moved cell
  !!   variable_vol_norm: volume weight at the edges of moved cell
  !!
  !! @par Revision History
  !!  developed by Peter Korn, MPI-M  2010-09
  !!  Modification by Stephan Lorenz, 2010-11
  !!
  SUBROUTINE init_scalar_product( p_patch)

    !  patch on which computation is performed
    !
    TYPE(t_patch), TARGET, INTENT(inout) :: p_patch

    CHARACTER(len=MAX_CHAR_LENGTH), PARAMETER :: &
    & routine = ('mo_ocean_topo:init_scalar_product')

    INTEGER, PARAMETER :: no_cell_edges = 3
    INTEGER, PARAMETER :: no_vert_edges = 6
    INTEGER :: jb, je, jv, ie, ie_1, ie_2
    INTEGER :: il_e,ib_e,it_vertedges,k  
    INTEGER :: il_c1, ib_c1, il_c2, ib_c2
    INTEGER :: il_v1, il_v2, ib_v1, ib_v2
    !INTEGER :: jc, ile,ibe
    !INTEGER :: jl_v1, jl_v2!, jb_v1, jb_v2

    INTEGER :: iil_c1(no_cell_edges), iil_c2(no_cell_edges)
    INTEGER :: iib_c1(no_cell_edges), iib_c2(no_cell_edges)

    !INTEGER :: il_c1_e1, ib_c1_e1, il_c1_e2, ib_c1_e2!, il_c1_e3, ib_c1_e3
    !INTEGER :: il_c2_e1, il_c2_e2, il_c2_e3!, ib_c2_e3!ib_c2_e1, ib_c2_e2,

    INTEGER :: jil_c1, jib_c1,jil_c2, jib_c2
    INTEGER :: rl_start_e, rl_end_e
    INTEGER :: i_startblk_e, i_endblk_e, i_startidx_e, i_endidx_e
    INTEGER :: rl_start, rl_end
    INTEGER :: i_startblk, i_endblk, i_startidx, i_endidx

    !REAL(wp) :: z_lon, z_lat, z_rlong, z_rlat, z_long_c, z_lat_c
    REAL(wp) :: z_tmp!z_twopi, z_longmax, z_longmin
    !REAL(wp) :: cell_edge_dist(no_cell_edges,2)
    !REAL(wp) :: cell_edge_distance
    REAL(wp) :: norm_c1_c2, norm_v1_v2, norm!, norm_v1_e0, norm_v2_e0
    !REAL(wp) :: dual_edge_length_v1(no_vert_edges)
    !REAL(wp) :: dual_edge_length_v2(no_vert_edges)
    REAL(wp) :: dual_edge_length(no_vert_edges)
!    REAL(wp) :: edge_length(no_cell_edges)
!     REAL(wp) :: vert_edge_dist_v1(no_vert_edges,2)
!     REAL(wp) :: vert_edge_dist_v2(no_vert_edges,2)
    REAL(wp) :: vert_edge_dist(no_vert_edges,2)!, new_lon,new_lat
!     REAL(wp) :: vert_dual_mid_dist_v1(no_vert_edges,2)
!     REAL(wp) :: vert_dual_mid_dist_v2(no_vert_edges,2)
    REAL(wp) :: vert_dual_mid_dist(no_vert_edges,2)
    !REAL(wp) :: vert2vert_dist
    REAL(wp) :: vert_edge_distance, vert_dual_mid_distance
    TYPE(t_geographical_coordinates) :: gc_mid_dual_edge(no_vert_edges)!gc_edge(no_cell_edges) 
    !TYPE(t_geographical_coordinates) :: gc_v0,gc_e0,gc_c0, gc_dual_edge(no_vert_edges)!gc_v1, gc_v2,
    !TYPE(t_geographical_coordinates) :: ll1, ll2!, ll3
    TYPE(t_cartesian_coordinates)    :: cc_dual_edge(no_vert_edges), cc_edge(no_cell_edges)
    TYPE(t_cartesian_coordinates)    :: xx1,xx2!,xx3
    !TYPE(t_cartesian_coordinates)    :: vert2vert_cc(nproma,p_patch%nblks_v,no_vert_edges)
    TYPE(t_cartesian_coordinates)    :: vert1_midedge_cc(nproma,p_patch%nblks_v,no_vert_edges)
    TYPE(t_cartesian_coordinates)    :: vert2_midedge_cc(nproma,p_patch%nblks_v,no_vert_edges)
    !TYPE(t_cartesian_coordinates)    :: normal_cc(no_cell_edges)!, norm_c0_e
    TYPE(t_cartesian_coordinates)    :: cell2cell_cc
    TYPE(t_cartesian_coordinates)    :: cc_e0, cc_c1,cc_c2,cc_v0!, cc_c0, cc_v1, cc_v2
    TYPE(t_cartesian_coordinates)    :: cv_c1_e0, cv_c2_e0, cv_c1_c2
    !TYPE(t_cartesian_coordinates)    :: cv_v1_e0, cv_v2_e0!, cv_v1_v2
    TYPE(t_cartesian_coordinates)    :: cc_mid_dual_edge(no_vert_edges)
    TYPE(t_cartesian_coordinates)    :: recon_vec_cc
    !TYPE(t_geographical_coordinates) :: recon_vec_gc(no_vert_edges), gc_tmp
    !TYPE(t_geographical_coordinates) :: normal_gc(no_cell_edges)
    !TYPE(t_cartesian_coordinates)    :: recon_vec_cc1(no_vert_edges), recon_vec_cc2(no_vert_edges)

    !TYPE(t_cartesian_coordinates)    :: cc_c1_e1, cc_c1_e2, cc_c1_e3
    !TYPE(t_cartesian_coordinates)    :: cc_c2_e1, cc_c2_e2, cc_c2_e3
    !TYPE(t_cartesian_coordinates)    :: cv_c1_e1, cv_c1_e2, cv_c1_e3
    !TYPE(t_cartesian_coordinates)    :: cv_c2_e1, cv_c2_e2, cv_c2_e3
    TYPE(t_cartesian_coordinates)    :: z_vec_c1(no_cell_edges),z_vec_c2(no_cell_edges)
    TYPE(t_cartesian_coordinates)    :: recon_vec_cc_v1(no_vert_edges) 
    TYPE(t_cartesian_coordinates)    :: recon_vec_cc_v2(no_vert_edges)
    !TYPE(t_cartesian_coordinates)    :: vec_mid_dual_edge_2v1(no_vert_edges)
    !TYPE(t_cartesian_coordinates)    :: vec_mid_dual_edge_2v2(no_vert_edges)
    !REAL(wp) :: length
    REAL(wp) :: z_edge_length(no_cell_edges)!, z_e_length!, z_ce_dist
    REAL(wp) :: z_cell_edge_dist_c1(no_cell_edges,2),z_cell_edge_dist_c2(no_cell_edges,2)
    !REAL(wp) :: z_cell_edge_dist(no_cell_edges,2)

    !REAL(wp) :: p_c(3), r1(3,3), r2(3,3), rot_p_c(3), barlon, barlat
    !REAL(wp) :: edge_length_c1_e1, edge_length_c1_e2,edge_length_c1_e3
    !REAL(wp) :: edge_length_c2_e1, edge_length_c2_e2,edge_length_c2_e3
    LOGICAL, PARAMETER :: MID_POINT_DUAL_EDGE = .TRUE. !Please do not change this unless
                                                       !you are sure, you know what you do.
    LOGICAL, PARAMETER :: LARC_LENGTH = .FALSE. 
    !-----------------------------------------------------------------------
    CALL message (TRIM(routine), 'start')

    rl_start = 1 
    rl_end = min_rlcell

    i_startblk = p_patch%cells%start_blk(rl_start,1)
    i_endblk   = p_patch%cells%end_blk(rl_end,1)

!     !Step 1: calculation of coefficients for primal grid
!     CELL_BLK_LOOP: DO jb = i_startblk, i_endblk
! 
!       CALL get_indices_c(p_patch, jb, i_startblk, i_endblk, i_startidx, i_endidx, rl_start, rl_end)
! 
!       CELL_IDX_LOOP: DO jc =  i_startidx, i_endidx
! 
!         !transform coordinates of edge midpoint ie to new coordinate system
!         DO ie=1, no_cell_edges
! 
!           ile = p_patch%cells%edge_idx(jc,jb,ie)
!           ibe = p_patch%cells%edge_blk(jc,jb,ie)
! 
!           cc_edge(ie) = gc2cc(p_patch%edges%center(ile,ibe))
! 
!           !Adjacent cells
!           il_c1 = p_patch%edges%cell_idx(ile,ibe,1)
!           ib_c1 = p_patch%edges%cell_blk(ile,ibe,1)
!           il_c2 = p_patch%edges%cell_idx(ile,ibe,2)
!           ib_c2 = p_patch%edges%cell_blk(ile,ibe,2)
! 
!           xx1 = gc2cc(p_patch%cells%center(il_c1,ib_c1))
!           xx2 = gc2cc(p_patch%cells%center(il_c2,ib_c2))
! 
! 
!            !calculate cell edge distances
!            IF(LARC_LENGTH)THEN
!              norm=SQRT(SUM(xx1%x*xx1%x))
!              xx1%x= xx1%x/norm
! 
!              norm=SQRT(SUM(xx2%x*xx2%x))
!              xx2%x= xx2%x/norm
! 
!              norm=SQRT(SUM(cc_edge(ie)%x*cc_edge(ie)%x))
!              cc_edge(ie)%x =  cc_edge(ie)%x/norm
! 
!              z_cell_edge_dist(ie,1) = arc_length(cc_edge(ie),xx1)
!              z_cell_edge_dist(ie,2) = arc_length(cc_edge(ie),xx2)
!              !z_cell_edge_dist(ie,1) = p_patch%edges%edge_cell_length(ile,ibe,1)/re 
!              !z_cell_edge_dist(ie,2) = p_patch%edges%edge_cell_length(ile,ibe,2)/re 
!            ELSE
!              z_cell_edge_dist(ie,1) = SQRT(SUM((cc_edge(ie)%x - xx1%x)*(cc_edge(ie)%x - xx1%x)))
!              z_cell_edge_dist(ie,2) = SQRT(SUM((cc_edge(ie)%x - xx2%x)*(cc_edge(ie)%x - xx2%x)))
!             !write(*,*)'length 1:', z_cell_edge_dist(ie,1),z_cell_edge_dist(ie,2),&
!             !&arc_length(cc_edge(ie),xx1),arc_length(cc_edge(ie),xx2) 
!            ENDIF 
!            !calculate edge length of moved triangle
!            !adjacent vertices of moved edge
!            il_v1 = p_patch%edges%vertex_idx(ile,ibe,1)
!            ib_v1 = p_patch%edges%vertex_blk(ile,ibe,1)
!            il_v2 = p_patch%edges%vertex_idx(ile,ibe,2)
!            ib_v2 = p_patch%edges%vertex_blk(ile,ibe,2)
!            xx1 = gc2cc(p_patch%verts%vertex(il_v1,ib_v1))
!            xx2 = gc2cc(p_patch%verts%vertex(il_v2,ib_v2))
!            IF(LARC_LENGTH)THEN
!              norm=SQRT(SUM(xx1%x*xx1%x))
!              xx1%x= xx1%x/norm
!              norm=SQRT(SUM(xx2%x*xx2%x))
!              xx2%x= xx2%x/norm
!              z_edge_length(ie) = arc_length(xx1,xx2) 
!              !z_edge_length(ie) = p_patch%edges%primal_edge_length(ile,ibe)/re
!              !write(*,*)'arc length',arc_length(xx2,xx1),z_edge_length(ie),SQRT(SUM((xx2%x-xx1%x)*(xx2%x-xx1%x)))
!            ELSE
!              z_edge_length(ie) = SQRT(SUM( (xx2%x - xx1%x)*(xx2%x - xx1%x)))
!              !write(*,*)'length 2:', z_edge_length(ie),arc_length(xx1,xx2)
!            ENDIF
!            IF(p_patch%edges%cell_idx(ile,ibe,1)==jc.AND.&
!            & p_patch%edges%cell_blk(ile,ibe,1)==jb)THEN
!              cell_edge_distance = z_cell_edge_dist(ie,1)
!            ELSEIF(p_patch%edges%cell_idx(ile,ibe,2)==jc.AND.&
!            & p_patch%edges%cell_blk(ile,ibe,2)==jb)THEN
!              cell_edge_distance = z_cell_edge_dist(ie,2)
!            ENDIF
!            !aggregate volume of cell
!            p_patch%patch_oce%fixed_vol_norm(jc,jb) = p_patch%patch_oce%fixed_vol_norm(jc,jb) &
!                                                   & + 0.5_wp*cell_edge_distance*z_edge_length(ie)
!            p_patch%patch_oce%variable_vol_norm(jc,jb,ie) = 0.5_wp*cell_edge_distance*z_edge_length(ie)
!          END DO
!        END DO CELL_IDX_LOOP
!      END DO CELL_BLK_LOOP

     rl_start_e = 1
     rl_end_e = min_rledge

     i_startblk_e = p_patch%edges%start_blk(rl_start_e,1)
     i_endblk_e   = p_patch%edges%end_blk(rl_end_e,1)

     !STEP 1: edge2cell and cell2edge coefficients
     EDGE_BLK_LOOP_PRIMAL: DO jb = i_startblk_e, i_endblk_e

       CALL get_indices_e(p_patch, jb,&
                        & i_startblk_e, i_endblk_e,&
                        & i_startidx_e, i_endidx_e,&
                        & rl_start_e, rl_end_e)

       EDGE_IDX_LOOP_PRIMAL: DO je =  i_startidx_e, i_endidx_e

         !Get indices of two adjacent triangles
         il_c1 = p_patch%edges%cell_idx(je,jb,1)
         ib_c1 = p_patch%edges%cell_blk(je,jb,1)
         il_c2 = p_patch%edges%cell_idx(je,jb,2)
         ib_c2 = p_patch%edges%cell_blk(je,jb,2)

         cc_c1 = gc2cc(p_patch%cells%center(il_c1, ib_c1))
         cc_c2 = gc2cc(p_patch%cells%center(il_c2, ib_c2))

         z_cell_edge_dist_c1 = 0.0_wp
         z_cell_edge_dist_c2 = 0.0_wp

         !normals in cell 1
         DO ie=1,no_cell_edges

           !actual edges of cell c1
           iil_c1(ie) = p_patch%cells%edge_idx(il_c1,ib_c1,ie)
           iib_c1(ie) = p_patch%cells%edge_blk(il_c1,ib_c1,ie)

           cc_edge(ie)   = gc2cc(p_patch%edges%center(iil_c1(ie),iib_c1(ie)))

           !calculate edge length
           !get vertex indices adjacent to actual edge
           il_v1 = p_patch%edges%vertex_idx(iil_c1(ie),iib_c1(ie),1)
           ib_v1 = p_patch%edges%vertex_blk(iil_c1(ie),iib_c1(ie),1)
           il_v2 = p_patch%edges%vertex_idx(iil_c1(ie),iib_c1(ie),2)
           ib_v2 = p_patch%edges%vertex_blk(iil_c1(ie),iib_c1(ie),2)

           !get vertex positions
           xx1 = gc2cc(p_patch%verts%vertex(il_v1,ib_v1))
           xx2 = gc2cc(p_patch%verts%vertex(il_v2,ib_v2))
 
           IF(LARC_LENGTH)THEN
             norm=SQRT(SUM(xx1%x*xx1%x))
             xx1%x= xx1%x/norm
             norm=SQRT(SUM(xx2%x*xx2%x))
             xx2%x= xx2%x/norm
             z_edge_length(ie) = arc_length(xx2,xx1)
             !z_edge_length(ie) = p_patch%edges%primal_edge_length(iil_c1(ie),iib_c1(ie))/re
           ELSE
             z_edge_length(ie) = SQRT(SUM((xx2%x-xx1%x)*(xx2%x-xx1%x)))
            !write(*,*)'length 3:', z_edge_length(ie),arc_length(xx1,xx2) 
           ENDIF

           !calculate cell-edge distance as half of cell-cell distance
           !get cell indices adjacent to actual edge
           jil_c1 = p_patch%edges%cell_idx(iil_c1(ie),iib_c1(ie),1)
           jib_c1 = p_patch%edges%cell_blk(iil_c1(ie),iib_c1(ie),1)
           jil_c2 = p_patch%edges%cell_idx(iil_c1(ie),iib_c1(ie),2)
           jib_c2 = p_patch%edges%cell_blk(iil_c1(ie),iib_c1(ie),2)

           !get cell positions
           xx1 = gc2cc(p_patch%cells%center(jil_c1,jib_c1))
           xx2 = gc2cc(p_patch%cells%center(jil_c2,jib_c2))

           IF(jil_c1==il_c1.AND.jib_c1==ib_c1)THEN
            k=1
           ELSEIF(jil_c2==il_c1.AND.jib_c2==ib_c1)THEN
            k=2
           ENDIF

           IF(LARC_LENGTH)THEN
             norm=SQRT(SUM(xx1%x*xx1%x))
             xx1%x= xx1%x/norm
             norm=SQRT(SUM(xx2%x*xx2%x))
             xx2%x= xx2%x/norm
             norm          = SQRT(SUM(cc_edge(ie)%x*cc_edge(ie)%x))
             cc_edge(ie)%x = cc_edge(ie)%x/norm
             z_cell_edge_dist_c1(ie,1) = arc_length(cc_edge(ie),xx1)
             z_cell_edge_dist_c1(ie,2) = arc_length(cc_edge(ie),xx2)
             !z_cell_edge_dist_c1(ie,1) = p_patch%edges%edge_cell_length(iil_c1(ie),iib_c1(ie),k)/re 
             !z_cell_edge_dist_c1(ie,2) = p_patch%edges%edge_cell_length(iil_c1(ie),iib_c1(ie),k)/re 
           ELSE
             z_cell_edge_dist_c1(ie,1) = SQRT(SUM((cc_edge(ie)%x-xx1%x)*(cc_edge(ie)%x-xx1%x)))
             z_cell_edge_dist_c1(ie,2) = SQRT(SUM((cc_edge(ie)%x-xx2%x)*(cc_edge(ie)%x-xx2%x)))  
             !write(*,*)'length 4',z_cell_edge_dist_c1(ie,1), z_cell_edge_dist_c1(ie,1),&
             !&p_patch%edges%edge_cell_length(iil_c1(ie),iib_c1(ie),1)/re 
           ENDIF
           p_patch%patch_oce%dist_cell2edge(iil_c1(ie),iib_c1(ie),1) = z_cell_edge_dist_c1(ie,1)
           p_patch%patch_oce%dist_cell2edge(iil_c1(ie),iib_c1(ie),2) = z_cell_edge_dist_c1(ie,2)

           z_vec_c1(ie)%x =  cc_edge(ie)%x - cc_c1%x     !p_patch%edges%primal_cart_normal(iil_c1(ie),iib_c1(ie))

           p_patch%patch_oce%edge2cell_coeff_cc(il_c1,ib_c1,ie)%x =                          &
             &               z_vec_c1(ie)%x*p_patch%cells%edge_orientation(il_c1,ib_c1,ie) * &
             &              z_edge_length(ie)

           !aggregate volume of cell
           norm = SQRT(SUM( z_vec_c1(ie)%x* z_vec_c1(ie)%x))
                 p_patch%patch_oce%fixed_vol_norm(il_c1,ib_c1) = &
             &   p_patch%patch_oce%fixed_vol_norm(il_c1,ib_c1) + 0.5_wp*norm*z_edge_length(ie)
           p_patch%patch_oce%variable_vol_norm(il_c1,ib_c1,ie) = 0.5_wp*norm*z_edge_length(ie)

           !write(*,*)'edge length   :',z_edge_length(ie),p_patch%edges%primal_edge_length(iil_c1(ie),iib_c1(ie))/re
           !write(*,*)'cell-edge dist:', z_cell_edge_dist_c1(ie,k),p_patch%edges%edge_cell_length(iil_c1(ie),iib_c1(ie),k)/re
         END DO

         !normals in cell 2
         DO ie=1,no_cell_edges

           !actual edges of cell c2
           iil_c2(ie) = p_patch%cells%edge_idx(il_c2,ib_c2,ie)
           iib_c2(ie) = p_patch%cells%edge_blk(il_c2,ib_c2,ie)

           cc_edge(ie) = gc2cc(p_patch%edges%center(iil_c2(ie),iib_c2(ie)))

           !calculate edge length
           !get vertex indices adjacent to actual edge
           il_v1 = p_patch%edges%vertex_idx(iil_c2(ie),iib_c2(ie),1)
           ib_v1 = p_patch%edges%vertex_blk(iil_c2(ie),iib_c2(ie),1)
           il_v2 = p_patch%edges%vertex_idx(iil_c2(ie),iib_c2(ie),2)
           ib_v2 = p_patch%edges%vertex_blk(iil_c2(ie),iib_c2(ie),2)

           !get vertex positions
           xx1 = gc2cc(p_patch%verts%vertex(il_v1,ib_v1))
           xx2 = gc2cc(p_patch%verts%vertex(il_v2,ib_v2))

           IF(LARC_LENGTH)THEN
             norm=SQRT(SUM(xx1%x*xx1%x))
             xx1%x= xx1%x/norm

             norm=SQRT(SUM(xx2%x*xx2%x))
             xx2%x= xx2%x/norm

             z_edge_length(ie) = arc_length(xx2,xx1)
             !z_edge_length(ie) = p_patch%edges%primal_edge_length(iil_c2(ie),iib_c2(ie))/re
              !write(*,*)'arc length',arc_length(xx2,xx1),z_edge_length(ie),SQRT(SUM((xx2%x-xx1%x)*(xx2%x-xx1%x)))
           ELSE
             z_edge_length(ie) = SQRT(SUM((xx2%x-xx1%x)*(xx2%x-xx1%x)))
           ENDIF
           !calculate cell-edge distance as half of cell-cell distance
           !get cell indices adjacent to actual edge
           jil_c1 = p_patch%edges%cell_idx(iil_c2(ie),iib_c2(ie),1)
           jib_c1 = p_patch%edges%cell_blk(iil_c2(ie),iib_c2(ie),1)
           jil_c2 = p_patch%edges%cell_idx(iil_c2(ie),iib_c2(ie),2)
           jib_c2 = p_patch%edges%cell_blk(iil_c2(ie),iib_c2(ie),2)

           !get cell positions
           xx1 = gc2cc(p_patch%cells%center(jil_c1,jib_c1))  
           xx2 = gc2cc(p_patch%cells%center(jil_c2,jib_c2))

           IF(jil_c1==il_c2.AND.jib_c1==ib_c2)THEN
             k=1
           ELSEIF(jil_c2==il_c2.AND.jib_c2==ib_c2)THEN
             k=2
           ENDIF  

           IF(LARC_LENGTH)THEN
             norm=SQRT(SUM(xx1%x*xx1%x))
             xx1%x= xx1%x/norm
             norm=SQRT(SUM(xx2%x*xx2%x))
             xx2%x= xx2%x/norm
             norm=SQRT(SUM(cc_edge(ie)%x*cc_edge(ie)%x))
             cc_edge(ie)%x =  cc_edge(ie)%x/norm
             z_cell_edge_dist_c2(ie,1) = arc_length(cc_edge(ie),xx1)
             z_cell_edge_dist_c2(ie,2) = arc_length(cc_edge(ie),xx2)
             !z_cell_edge_dist_c2(ie,1) = p_patch%edges%edge_cell_length(iil_c2(ie),iib_c2(ie),1)/re
             !z_cell_edge_dist_c2(ie,2) = p_patch%edges%edge_cell_length(iil_c2(ie),iib_c2(ie),2)/re
             !write(*,*)'arc length',0.5_wp*arc_length(xx2,xx1),z_cell_edge_dist_c2(ie,k),0.5_wp*SQRT(SUM((xx2%x-xx1%x)*(xx2%x-xx1%x)))
           ELSE 
             z_cell_edge_dist_c2(ie,1) = SQRT(SUM((cc_edge(ie)%x-xx1%x)*(cc_edge(ie)%x-xx1%x)))
             z_cell_edge_dist_c2(ie,2) = SQRT(SUM((cc_edge(ie)%x-xx2%x)*(cc_edge(ie)%x-xx2%x)))
           ENDIF
           p_patch%patch_oce%dist_cell2edge(iil_c2(ie),iib_c2(ie),1) = z_cell_edge_dist_c1(ie,1)
           p_patch%patch_oce%dist_cell2edge(iil_c2(ie),iib_c2(ie),2) = z_cell_edge_dist_c1(ie,2)

           z_vec_c2(ie)%x =  cc_edge(ie)%x - cc_c2%x

           p_patch%patch_oce%edge2cell_coeff_cc(il_c2,ib_c2,ie)%x&
             & = z_vec_c2(ie)%x*p_patch%cells%edge_orientation(il_c2,ib_c2,ie)*z_edge_length(ie)

           norm = SQRT(SUM( z_vec_c2(ie)%x* z_vec_c2(ie)%x))
           p_patch%patch_oce%fixed_vol_norm(il_c2,ib_c2) &
             & = p_patch%patch_oce%fixed_vol_norm(il_c2,ib_c2) + 0.5_wp*norm*z_edge_length(ie)

           p_patch%patch_oce%variable_vol_norm(il_c2,ib_c2,ie) = 0.5_wp*norm*z_edge_length(ie)


         END DO
       END DO EDGE_IDX_LOOP_PRIMAL
     END DO EDGE_BLK_LOOP_PRIMAL

    rl_start = 1 
    rl_end = min_rledge

    i_startblk = p_patch%edges%start_blk(rl_start,1)
    i_endblk   = p_patch%edges%end_blk(rl_end,1)

    EDGE_BLK_LOOP_0: DO jb = i_startblk, i_endblk
      CALL get_indices_e(p_patch, jb, i_startblk, i_endblk,&
                       & i_startidx, i_endidx, rl_start, rl_end)
      EDGE_IDX_LOOP_0: DO je =  i_startidx, i_endidx

        !Get indices of two adjacent triangles
        il_c1 = p_patch%edges%cell_idx(je,jb,1)
        ib_c1 = p_patch%edges%cell_blk(je,jb,1)
        il_c2 = p_patch%edges%cell_idx(je,jb,2)
        ib_c2 = p_patch%edges%cell_blk(je,jb,2)

        !cartesian coordinates of edge and neighbor cells on 1-sphere
        cc_e0 = gc2cc(p_patch%edges%center(je,jb))
        cc_c1 = gc2cc(p_patch%cells%center(il_c1,ib_c1))
        cc_c2 = gc2cc(p_patch%cells%center(il_c2,ib_c2))

        !cartesian vectors from:
        !cell 2 to cell 1, cell 1 to edge je and cell 2 to edge je
        cv_c1_c2%x = cc_c1%x - cc_c2%x
        cv_c1_e0%x = cc_e0%x - cc_c1%x
        cv_c2_e0%x = cc_e0%x - cc_c2%x

        IF(LARC_LENGTH)THEN
          norm=SQRT(SUM(cc_e0%x*cc_e0%x))
          cc_e0%x= cc_e0%x/norm
          norm=SQRT(SUM(cc_c1%x*cc_c1%x))
          cc_c1%x= cc_c1%x/norm
          norm=SQRT(SUM(cc_c2%x*cc_c2%x))
          cc_c2%x= cc_c2%x/norm
          norm_c1_c2 = arc_length(cc_c1, cc_c2)
          !norm_c1_c2 = p_patch%edges%dual_edge_length(je,jb)/re 
                       !p_patch%edges%edge_cell_length(je,jb,1)/re&
                      !&+p_patch%edges%edge_cell_length(je,jb,2)/re
        ELSE
          norm_c1_c2 = SQRT(SUM(cv_c1_e0%x*cv_c1_e0%x))+SQRT(SUM(cv_c2_e0%x*cv_c2_e0%x)) !SQRT(SUM(cv_c1_c2%x*cv_c1_c2%x))!
        ENDIF

        !Determine which edge of both of the two adjacent cells corresponds to the
        !actual edge "je". This information is used below for the edge-orientation.
        DO ie=1,no_cell_edges
          IF (p_patch%cells%edge_idx(il_c1,ib_c1,ie) == je.AND.&
            & p_patch%cells%edge_blk(il_c1,ib_c1,ie) == jb) THEN
            ie_1 = ie
          END IF
          IF (p_patch%cells%edge_idx(il_c2,ib_c2,ie) == je.AND.&
            & p_patch%cells%edge_blk(il_c2,ib_c2,ie) == jb) THEN
            ie_2 = ie
          END IF
        END DO

        p_patch%patch_oce%edge2cell_coeff_cc_t(je,jb,1)%x&
        & = cv_c1_e0%x * p_patch%cells%edge_orientation(il_c1,ib_c1,ie_1)/norm_c1_c2

        p_patch%patch_oce%edge2cell_coeff_cc_t(je,jb,2)%x&
        & = cv_c2_e0%x * p_patch%cells%edge_orientation(il_c2,ib_c2,ie_2)/norm_c1_c2

      END DO EDGE_IDX_LOOP_0
    END DO EDGE_BLK_LOOP_0

    !------------------------------------------------------------------------------
    !STEP 2: edge2vert und vert2edge coefficients for dual grid
    !------------------------------------------------------------------------------
    rl_start = 1
    rl_end   = min_rlvert

    i_startblk = p_patch%verts%start_blk(rl_start,1)
    i_endblk   = p_patch%verts%end_blk(rl_end,1)


    VERT_BLK_LOOP: DO jb = i_startblk, i_endblk
      CALL get_indices_v(p_patch, jb, i_startblk, i_endblk,&
                       & i_startidx, i_endidx, rl_start, rl_end)
      VERT_IDX_LOOP: DO jv =  i_startidx, i_endidx

        ! current number of edges around vertex (5 or 6)
        it_vertedges = p_patch%verts%num_edges(jv,jb)
        cc_v0        = gc2cc(p_patch%verts%vertex(jv,jb))
 
        DO ie=1, no_vert_edges

          il_e = p_patch%verts%edge_idx(jv,jb,ie)
          ib_e = p_patch%verts%edge_blk(jv,jb,ie)

          cc_dual_edge(ie) = gc2cc(p_patch%edges%center(il_e,ib_e))
          !Parts of this code parrallels the implementation in the grid-generator
          !module "mo_geometry".
          !
          !1) determine normal vector from adjacent cell to adjacent cell
          !   in cartesian coordinate for moved dual cell
          !Get indices of two adjacent triangles
          il_c1 = p_patch%edges%cell_idx(il_e,ib_e,1)
          ib_c1 = p_patch%edges%cell_blk(il_e,ib_e,1)
          il_c2 = p_patch%edges%cell_idx(il_e,ib_e,2)
          ib_c2 = p_patch%edges%cell_blk(il_e,ib_e,2)

          xx1 = gc2cc(p_patch%cells%center(il_c1,ib_c1))
          norm=SQRT(SUM(xx1%x*xx1%x))
          xx1%x= xx1%x/norm

          xx2 = gc2cc(p_patch%cells%center(il_c2,ib_c2))
          norm=SQRT(SUM(xx2%x*xx2%x))
          xx2%x= xx2%x/norm

           cell2cell_cc%x       = xx2%x - xx1%x
           norm_c1_c2           = SQRT(SUM(cell2cell_cc%x*cell2cell_cc%x)) !arc_length(xx1,xx2)!
           dual_edge_length(ie) = norm_c1_c2          !!dual_edge_length(ie) = p_patch%edges%dual_edge_length(il_e,ib_e)/re !
!           cell2cell_cc%x       = cell2cell_cc%x/norm_c1_c2 

          IF(MID_POINT_DUAL_EDGE)THEN
            cc_mid_dual_edge(ie)%x = 0.5_wp*(xx2%x+xx1%x)
            gc_mid_dual_edge(ie)   = cc2gc(cc_mid_dual_edge(ie)) 
          ELSE
            cc_mid_dual_edge(ie)%x = cc_dual_edge(ie)%x
            gc_mid_dual_edge(ie)   = cc2gc(cc_mid_dual_edge(ie)) 
          ENDIF

          !2) determine vector from adjacent vertex to adjacent vertex
          !   in cartesian coordinate for moved dual cell
          !Get indices of two adjacent vertices
          il_v1 = p_patch%edges%vertex_idx(il_e,ib_e,1)
          ib_v1 = p_patch%edges%vertex_blk(il_e,ib_e,1)
          il_v2 = p_patch%edges%vertex_idx(il_e,ib_e,2)
          ib_v2 = p_patch%edges%vertex_blk(il_e,ib_e,2)

          xx1 = gc2cc(p_patch%verts%vertex(il_v1,ib_v1))
          norm=SQRT(SUM(xx1%x*xx1%x))
          xx1%x= xx1%x/norm

          xx2 = gc2cc(p_patch%verts%vertex(il_v2,ib_v2))
          norm=SQRT(SUM(xx2%x*xx2%x))
          xx2%x= xx2%x/norm

          vert1_midedge_cc(jv, jb, ie)%x = cc_mid_dual_edge(ie)%x - xx1%x
          vert2_midedge_cc(jv, jb, ie)%x = cc_mid_dual_edge(ie)%x - xx2%x
          !vert2vert_cc(jv, jb, ie)%x = cc_mid_dual_edge(ie)%x - xx1%x !xx2%x - xx1%x
!           norm                       = SQRT(SUM(vert2vert_cc(jv,jb,ie)%x*vert2vert_cc(jv,jb,ie)%x))
!           vert2vert_cc(jv,jb,ie)%x   = vert2vert_cc(jv, jb, ie)%x/norm
          norm = SQRT(SUM(vert1_midedge_cc(jv,jb,ie)%x*vert1_midedge_cc(jv,jb,ie)%x))
          vert1_midedge_cc(jv, jb, ie)%x = vert1_midedge_cc(jv, jb, ie)%x/norm
          norm = SQRT(SUM(vert2_midedge_cc(jv,jb,ie)%x*vert2_midedge_cc(jv,jb,ie)%x))
          vert2_midedge_cc(jv, jb, ie)%x = vert2_midedge_cc(jv, jb, ie)%x/norm


          !calculate vertex edge distance
          vert_edge_dist(ie,1)&
          & = SQRT(SUM((cc_dual_edge(ie)%x - xx1%x)*(cc_dual_edge(ie)%x - xx1%x)))
          vert_edge_dist(ie,2)&
          & = SQRT(SUM((cc_dual_edge(ie)%x - xx2%x)*(cc_dual_edge(ie)%x - xx2%x)))
          vert_dual_mid_dist(ie,1)&
          & = SQRT(SUM((cc_mid_dual_edge(ie)%x - xx1%x)*(cc_mid_dual_edge(ie)%x - xx1%x)))
          vert_dual_mid_dist(ie,2)&
          & = SQRT(SUM((cc_mid_dual_edge(ie)%x - xx2%x)*(cc_mid_dual_edge(ie)%x - xx2%x)))

!             vert_edge_dist(ie,1) = arc_length (cc_dual_edge(ie), xx1) 
!             vert_edge_dist(ie,2) = arc_length (cc_dual_edge(ie), xx2) 
!             vert_dual_mid_dist(ie,1)= arc_length (cc_mid_dual_edge(ie), xx1) 
!             vert_dual_mid_dist(ie,2)= arc_length (cc_mid_dual_edge(ie), xx2)

          !calculate normal vector that is perpendicular to vertex-vertex- and edge position vector
          !If one uses the edge position vector this results in the moved primal normal. Later
          !edge position vector has to be replaced by the midpoint of the dual edge.
!           recon_vec_cc   = vector_product(vert2vert_cc(jv, jb, ie), cc_mid_dual_edge(ie))
!           norm           = SQRT(SUM(recon_vec_cc%x*recon_vec_cc%x))
!           recon_vec_cc%x = recon_vec_cc%x/norm
          recon_vec_cc_v1(ie) = vector_product(vert1_midedge_cc(jv, jb, ie), cc_mid_dual_edge(ie))
          norm                = SQRT(SUM(recon_vec_cc_v1(ie)%x*recon_vec_cc_v1(ie)%x))
          recon_vec_cc_v1(ie)%x = recon_vec_cc_v1(ie)%x/norm
          recon_vec_cc_v2(ie)   = vector_product(vert2_midedge_cc(jv, jb, ie), &
            &                                    cc_mid_dual_edge(ie))
          norm           = SQRT(SUM(recon_vec_cc_v2(ie)%x*recon_vec_cc_v2(ie)%x))
          recon_vec_cc_v2(ie)%x = recon_vec_cc_v2(ie)%x/norm

          !Fix orientation
!           z_tmp =  DOT_PRODUCT(recon_vec_cc%x, cell2cell_cc%x)
!           IF (z_tmp <0._wp) recon_vec_cc%x = -1._wp * recon_vec_cc%x
!           z_tmp =  DOT_PRODUCT(recon_vec_cc_v1(ie)%x, cell2cell_cc%x)
          z_tmp = DOT_PRODUCT(recon_vec_cc_v1(ie)%x, p_patch%edges%primal_cart_normal(il_e,ib_e)%x)
          IF (z_tmp <0._wp) recon_vec_cc_v1(ie)%x = -1._wp * recon_vec_cc_v1(ie)%x

          z_tmp = DOT_PRODUCT(recon_vec_cc_v2(ie)%x, p_patch%edges%primal_cart_normal(il_e,ib_e)%x)
          IF (z_tmp <0._wp) recon_vec_cc_v2(ie)%x = -1._wp * recon_vec_cc_v2(ie)%x


          !write(*,*)'recon vec:primal 1:', il_e,ib_e,ie,recon_vec_cc%x, p_patch%edges%primal_cart_normal(il_e,ib_e)%x
          !Transform to geographical coordinates 
!            gc_dual_edge(ie)=cc2gc(cc_mid_dual_edge(ie))!cc2gc(cc_dual_edge(ie))!
!            CALL cvec2gvec ( recon_vec_cc%x(1), recon_vec_cc%x(2), recon_vec_cc%x(3), &
!              &              gc_dual_edge(ie)%lon, gc_dual_edge(ie)%lat,              &
!              &              recon_vec_gc(ie)%lon, recon_vec_gc(ie)%lat )

          IF      ( (p_patch%edges%vertex_idx(il_e,ib_e,1) == jv) .and. &
                    (p_patch%edges%vertex_blk(il_e,ib_e,1) == jb) ) THEN

            vert_edge_distance     = vert_edge_dist(ie,1)
            vert_dual_mid_distance = vert_dual_mid_dist(ie,1)
            recon_vec_cc           = recon_vec_cc_v1(ie)

          ELSE IF ( (p_patch%edges%vertex_idx(il_e,ib_e,2) == jv) .and. &
                    (p_patch%edges%vertex_blk(il_e,ib_e,2) == jb) ) THEN

            vert_edge_distance     = vert_edge_dist(ie,2)
            vert_dual_mid_distance = vert_dual_mid_dist(ie,2)
            recon_vec_cc           = recon_vec_cc_v2(ie)

          ELSE
            CALL message (TRIM(routine), 'WARNING - vert_edge_distance not found')
            write(*,*) 'p_patch%edges%vertex_idx(il_e,ib_e,1)=', &
                        p_patch%edges%vertex_idx(il_e,ib_e,1)
          END IF
!           p_patch%patch_oce%edge2vert_coeff(jv,jb,ie,1) = &
!             & recon_vec_gc(ie)%lon*(dual_edge_length(ie)*vert_dual_mid_distance)
!           p_patch%patch_oce%edge2vert_coeff(jv,jb,ie,2) = &
!             & recon_vec_gc(ie)%lat*(dual_edge_length(ie)*vert_dual_mid_distance)


           p_patch%patch_oce%variable_dual_vol_norm(jv,jb,ie) = &
                   &0.5_wp*dual_edge_length(ie)*vert_dual_mid_distance!vert_edge_distance*dual_edge_length(ie)!

          p_patch%patch_oce%edge2vert_coeff_cc(jv,jb,ie)%x=&
            &recon_vec_cc%x*dual_edge_length(ie)*vert_dual_mid_distance

        norm_v1_v2 = SQRT(SUM(vert1_midedge_cc(jv, jb, ie)%x*vert1_midedge_cc(jv, jb, ie)%x))&
                  &+ SQRT(SUM(vert2_midedge_cc(jv, jb, ie)%x*vert2_midedge_cc(jv, jb, ie)%x))

        p_patch%patch_oce%edge2vert_coeff_cc_t(il_e,ib_e,1)%x = vert1_midedge_cc(jv, jb, ie)%x * &
          &    ( p_patch%edges%system_orientation(il_e,ib_e)/norm_v1_v2 )

        p_patch%patch_oce%edge2vert_coeff_cc_t(il_e,ib_e,2)%x = vert2_midedge_cc(jv, jb, ie)%x * &
          &    ( p_patch%edges%system_orientation(il_e,ib_e)/norm_v1_v2 )

        END DO

      ENDDO VERT_IDX_LOOP
    END DO VERT_BLK_LOOP

!     !Now we calculate the coefficients for the transposed of the edge to vertex mapping
!     i_startblk = p_patch%edges%start_blk(rl_start,1)
!     i_endblk   = p_patch%edges%end_blk(rl_end,1)
! 
!     EDGE_BLK_LOOP_2 : DO jb = i_startblk, i_endblk
! 
!       CALL get_indices_e(p_patch, jb, i_startblk, i_endblk, i_startidx, i_endidx, rl_start, rl_end)
! 
!       EDGE_IDX_LOOP_2: DO je =  i_startidx, i_endidx
! 
!         !Step 1: get relevant coordinates and vectors
!         !
!         !Get indices of two adjacent vertices and cells
!         il_v1 = p_patch%edges%vertex_idx(je,jb,1)
!         ib_v1 = p_patch%edges%vertex_blk(je,jb,1)
!         il_v2 = p_patch%edges%vertex_idx(je,jb,2)
!         ib_v2 = p_patch%edges%vertex_blk(je,jb,2)
! 
!         il_c1 = p_patch%edges%cell_idx(je,jb,1)
!         ib_c1 = p_patch%edges%cell_blk(je,jb,1)
!         il_c2 = p_patch%edges%cell_idx(je,jb,2)
!         ib_c2 = p_patch%edges%cell_blk(je,jb,2)
! 
!         xx1 = gc2cc(p_patch%cells%center(il_c1,ib_c1))
!         norm=SQRT(SUM(xx1%x*xx1%x))
!         xx1%x= xx1%x/norm
!         xx2 = gc2cc(p_patch%cells%center(il_c2,ib_c2))
!         norm=SQRT(SUM(xx2%x*xx2%x))
!         xx2%x= xx2%x/norm
! 
!         !cartesian coordinates of edge and neighbor cells
!         IF(MID_POINT_DUAL_EDGE)THEN
!         cc_e0%x =0.5_wp*(xx2%x+xx1%x) !cc_edge(ie)%x
!         ELSE
!           cc_e0 = gc2cc(p_patch%edges%center(je,jb))
!         ENDIF
! 
!         cc_v1 = gc2cc(p_patch%verts%vertex(il_v1,ib_v1))
!         cc_v2 = gc2cc(p_patch%verts%vertex(il_v2,ib_v2))
! 
!         !cartesian vectors from: vertex 2 to vertex 1
!         ! vertex 1 to edge je and vertex 2 to edge je
!         cv_v1_v2%x = cc_v2%x - cc_v1%x
!         cv_v1_e0%x = cc_e0%x - cc_v1%x
!         cv_v2_e0%x = cc_e0%x - cc_v2%x
! 
!         norm_v1_e0 = SQRT(SUM(cv_v1_e0%x*cv_v1_e0%x))
!         norm_v2_e0 = SQRT(SUM(cv_v2_e0%x*cv_v2_e0%x))
! 
!         IF(mid_point_dual_edge)THEN
!           !norm_v1_v2 = norm_v1_e0 + norm_v2_e0
!            norm_v1_v2 = arc_length(cc_v2, cc_e0)&
!                       &+arc_length(cc_v1, cc_e0)
!         ELSE 
!           norm_v1_v2 = SQRT(SUM(cv_v1_e0%x*cv_v1_e0%x)) + SQRT(SUM(cv_v2_e0%x*cv_v2_e0%x))!!sqrt(sum(cv_v1_v2%x*cv_v1_v2%x))!
!           !norm_v1_v2 = arc_length(cc_v2, cc_v1)
!         ENDIF
! 
! !         p_patch%patch_oce%edge2vert_coeff_t(je,jb,1)%x = cv_v1_e0%x * &
! !           &    ( p_patch%edges%system_orientation(je,jb)/norm_v1_v2 )
! ! 
! !         p_patch%patch_oce%edge2vert_coeff_t(je,jb,2)%x = cv_v2_e0%x * &
! !           &    ( p_patch%edges%system_orientation(je,jb)/norm_v1_v2 )
! 
!       END DO EDGE_IDX_LOOP_2
!     END DO EDGE_BLK_LOOP_2

    CALL message (TRIM(routine), 'end')

  END SUBROUTINE init_scalar_product
!-------------------------------------------------------------------------
! function calc_edge_length_cc(p_patch, edge_idx, edge_blk) RESULT(edge_length)
! 
! TYPE(t_patch), INTENT(inout) :: p_patch
! INTEGER, INTENT(in)          :: edge_idx
! INTEGER, INTENT(in)          :: edge_blk
! REAL(wp)                     :: edge_length
! 
! !lOCAL VARIABLES
! INTEGER :: il_v1, il_v2  
! INTEGER :: ib_v1, ib_v2
! !INTEGER :: ie  
! TYPE(t_cartesian_coordinates)    :: cc_v1, cc_v2!, cv_v1_v2
! !-----------------------------------------  
! 
! !get indices of vertices adjacent to edge 
! il_v1 = p_patch%edges%vertex_idx(edge_idx,edge_blk,1)
! ib_v1 = p_patch%edges%vertex_blk(edge_idx,edge_blk,1)
! 
! il_v2 = p_patch%edges%vertex_idx(edge_idx,edge_blk,2)
! ib_v2 = p_patch%edges%vertex_blk(edge_idx,edge_blk,2)
! 
! cc_v1 = gc2cc(p_patch%verts%vertex(il_v1,ib_v1))
! cc_v2 = gc2cc(p_patch%verts%vertex(il_v2,ib_v2))
! 
! edge_length = SQRT(SUM( (cc_v2%x - cc_v1%x)&
!                      &* (cc_v2%x - cc_v1%x) ))
! end function calc_edge_length_cc
!   !-------------------------------------------------------------------------
! function calc_cell_edge_dist_cc(p_patch,&
!                               & edge_idx, edge_blk,&
!                               & cell_idx, cell_blk) RESULT(cell_edge_dist)
! 
! TYPE(t_patch), INTENT(inout) :: p_patch
! INTEGER, INTENT(in)          :: edge_idx
! INTEGER, INTENT(in)          :: edge_blk
! INTEGER, INTENT(in)          :: cell_idx
! INTEGER, INTENT(in)          :: cell_blk
! REAL(wp)                     :: cell_edge_dist
! 
! !lOCAL VARIABLES
! INTEGER :: il_c1, il_c2  
! INTEGER :: ib_c1, ib_c2
! !INTEGER :: ie  
! TYPE(t_cartesian_coordinates) :: cc_c, cc_e, cc_x
! !-----------------------------------------  
! 
! !get indices of cells adjacent to edge 
! il_c1 = p_patch%edges%cell_idx(edge_idx,edge_blk,1)
! ib_c1 = p_patch%edges%cell_blk(edge_idx,edge_blk,1)
! il_c2 = p_patch%edges%cell_idx(edge_idx,edge_blk,2)
! ib_c2 = p_patch%edges%cell_blk(edge_idx,edge_blk,2)
! 
! !cart coord of two adjacent cells
! cc_c = gc2cc(p_patch%cells%center(cell_idx,cell_blk))
! cc_e = gc2cc(p_patch%edges%center(edge_idx,edge_blk))
! 
! !determine point in the middle between c1 and c2
! cc_x%x = (cc_e%x-cc_c%x)
! 
! cell_edge_dist = SQRT(SUM( cc_x%x*cc_x%x))
! end function calc_cell_edge_dist_cc
  !
  !>
  !! Computes the coefficients that determine the scalar product on the primal grid. This
  !! scalar product depends on the grid geometry only and  is used to formulate the primitive
  !! equations in weak form. The coefficients are applied in module "mo_scalar_product".
  !! The following components of the data type "ocean_patch" are filled:
  !!   edge2cell_coeff  : coefficients for edge to cell mapping
  !!   edge2cell_coeff_t: coefficients for transposed of edge to cell mappings
  !!   edge2vert_coeff  : coefficients for edge to vertex mapping
  !!   edge2vert_coeff_t: coefficients for transposed of edge to vertex mappings
  !!   fixed_vol_norm   : summed volume weight of moved cell
  !!   variable_vol_norm: volume weight at the edges of moved cell
  !!
  !! @par Revision History
  !!  developed by Peter Korn, MPI-M  2010-09
  !!  Modification by Stephan Lorenz, 2010-11
  !!
!   SUBROUTINE init_scalar_product_orig( p_patch)
! 
!     !  patch on which computation is performed
!     !
!     TYPE(t_patch), TARGET, INTENT(inout) :: p_patch
! 
!     CHARACTER(len=MAX_CHAR_LENGTH), PARAMETER :: &
!     & routine = ('mo_ocean_topo:init_scalar_product')
! 
!     INTEGER, PARAMETER :: no_cell_edges = 3
!     INTEGER, PARAMETER :: no_vert_edges = 6
!     INTEGER :: jb, je, jc, jv, ie, ile, ibe, ie_1, ie_2
!     INTEGER :: il_e, ib_e, it_vertedges
!     INTEGER :: il_c1, ib_c1, il_c2, ib_c2, il_v1, il_v2, ib_v1, ib_v2
! 
!     !INTEGER :: il_c1_e1, il_c1_e2, il_c1_e3, ib_c1_e3!ib_c1_e1, ib_c1_e2, 
!     !INTEGER :: il_c2_e1, ib_c2_e1, il_c2_e2, ib_c2_e2, il_c2_e3, ib_c2_e3
! 
!     INTEGER :: rl_start, rl_end
!     INTEGER :: i_startblk, i_endblk, i_startidx, i_endidx
! 
!     REAL(wp) :: z_lon, z_lat, z_rlong, z_rlat, z_long_c, z_lat_c
!     REAL(wp) :: z_twopi, z_longmax, z_longmin, z_tmp
!     REAL(wp) :: cell_edge_dist(no_cell_edges,2)
!     REAL(wp) :: cell_edge_distance
!     REAL(wp) :: norm_c1_c2, norm_c0_e, norm_v1_v2, norm, norm_v1_e0, norm_v2_e0
!     REAL(wp) :: dual_edge_length(no_vert_edges)
!     REAL(wp) :: edge_length(no_cell_edges)
!     REAL(wp) :: vert_edge_dist(no_vert_edges,2)    
!     REAL(wp) :: vert_dual_mid_dist(no_vert_edges,2)
!     REAL(wp) :: vert_edge_distance, vert_dual_mid_distance!, dist_edge_cell, dist_vert_vert
! 
!     TYPE(t_geographical_coordinates) :: gc_edge(no_cell_edges), gc_dual_edge(no_vert_edges)
!     TYPE(t_geographical_coordinates) :: gc_c0, gc_v0, gc_e0
!     TYPE(t_geographical_coordinates) :: ll1, ll2!, ll3
!     TYPE(t_cartesian_coordinates)    :: cc_edge(no_cell_edges), cc_dual_edge(no_vert_edges)
!     TYPE(t_cartesian_coordinates)    :: xx1,xx2!,xx3
!     TYPE(t_cartesian_coordinates)    :: normal_cc(no_cell_edges)
!     TYPE(t_cartesian_coordinates)    :: cell2cell_cc
!     TYPE(t_cartesian_coordinates)    :: cc_c1, cc_c2, cc_e0, cc_c0, cc_v0, cc_v1, cc_v2
!     TYPE(t_cartesian_coordinates)    :: cv_c1_e0, cv_c2_e0, cv_c1_c2
!     TYPE(t_cartesian_coordinates)    :: cv_v1_e0, cv_v2_e0, cv_v1_v2
!     TYPE(t_cartesian_coordinates)    :: cc_mid_dual_edge(no_vert_edges)
!     TYPE(t_cartesian_coordinates)    :: vert2vert_cc(nproma,p_patch%nblks_v,no_vert_edges)
!     TYPE(t_cartesian_coordinates)    :: recon_vec_cc
!     TYPE(t_geographical_coordinates) :: recon_vec_gc(no_vert_edges)
!     TYPE(t_geographical_coordinates) :: normal_gc(no_cell_edges)
! 
! 
! !    TYPE(t_cartesian_coordinates)    :: cc_c1_e1, cc_c1_e2, cc_c1_e3
! !    TYPE(t_cartesian_coordinates)    :: cc_c2_e1, cc_c2_e2, cc_c2_e3
! !    TYPE(t_cartesian_coordinates)    :: cv_c1_e1, cv_c1_e2, cv_c1_e3
! !    TYPE(t_cartesian_coordinates)    :: cv_c2_e1, cv_c2_e2, cv_c2_e3
! 
!     !REAL(wp) :: edge_length_c1_e1, edge_length_c1_e2,edge_length_c1_e3
!     !REAL(wp) :: edge_length_c2_e1, edge_length_c2_e2,edge_length_c2_e3
!     !TYPE(t_geographical_coordinates) :: gc_tmp(2)
!     LOGICAL, PARAMETER :: MID_POINT_DUAL_EDGE = .TRUE. !Please do not change this unless
!                                                        !you are sure, you know what you do.
!     !-----------------------------------------------------------------------
! 
!     rl_start = 1  ! #slo# changed to 1 - 2010-11-15
!     rl_end = min_rledge
! 
!     i_startblk = p_patch%edges%start_blk(rl_start,1)
!     i_endblk   = p_patch%edges%end_blk(rl_end,1)
! 
!     CALL message (TRIM(routine), 'start')
! 
! !!$OMP PARALLEL  PRIVATE(rl_start,rl_end,i_startblk,i_endblk)
!     z_twopi  = 2.0_wp * pi
! 
!     ! set fixed_vol_norm to zero before summing up
!     p_patch%patch_oce%fixed_vol_norm = 0.0_wp
! 
!     rl_start = 1  ! #slo# changed to 1 - 2010-11-15
!     rl_end = min_rlcell
! 
!     i_startblk = p_patch%cells%start_blk(rl_start,1)
!     i_endblk   = p_patch%cells%end_blk(rl_end,1)
! 
!     !Step 1: calculation of coefficients for primal grid
!     CELL_BLK_LOOP: DO jb = i_startblk, i_endblk
! 
!       CALL get_indices_c(p_patch, jb, i_startblk, i_endblk, i_startidx, i_endidx, rl_start, rl_end)
! 
!       CELL_IDX_LOOP: DO jc =  i_startidx, i_endidx
! 
!         !triangle center origin of new coordinate system
!         z_rlong = p_patch%cells%center(jc,jb)%lon
!         z_rlat  = p_patch%cells%center(jc,jb)%lat
! 
!         gc_c0%lon = z_rlong
!         gc_c0%lat = z_rlat
!         cc_c0     = gc2cc(gc_c0)
! 
!         !new coordinates
!         z_long_c = 0._wp
!         z_lat_c  = 0._wp
!         IF (z_long_c>pi)  z_long_c = z_long_c - z_twopi
! 
! 
!         !transform coordinates of edge midpoint ie to new coordinate system
!         DO ie=1, no_cell_edges
! 
!           ile = p_patch%cells%edge_idx(jc,jb,ie)
!           ibe = p_patch%cells%edge_blk(jc,jb,ie)
! !check          IF(iie/=p_patch%nedges+1)THEN
!           CALL disp_new( p_patch%edges%center(ile,ibe)%lon,&
!                        & p_patch%edges%center(ile,ibe)%lat,&
!                        & z_rlong,z_rlat,&
!                        & gc_edge(ie)%lon,gc_edge(ie)%lat)
!              cc_edge(ie) = gc2cc(gc_edge(ie))
!         END DO
! 
!         !all longitudes between -pi and pi
!         IF(ie==3)THEN
!         z_longmax = MAX( gc_edge(1)%lon, gc_edge(2)%lon, gc_edge(3)%lon )
!         z_longmin = MIN( gc_edge(1)%lon, gc_edge(2)%lon, gc_edge(3)%lon )
! 
!         IF( z_longmax-z_longmin>pi )THEN
!           IF( z_long_c>pi )  z_long_c  = z_long_c - z_twopi
!           IF( gc_edge(1)%lon>pi ) gc_edge(1)%lon = gc_edge(1)%lon -z_twopi
!           IF( gc_edge(2)%lon>pi ) gc_edge(2)%lon = gc_edge(2)%lon -z_twopi
!           IF( gc_edge(3)%lon>pi ) gc_edge(3)%lon = gc_edge(3)%lon -z_twopi
!         ENDIF
!         ENDIF
!         DO ie=1, no_cell_edges
! 
!           ile = p_patch%cells%edge_idx(jc,jb,ie)
!           ibe = p_patch%cells%edge_blk(jc,jb,ie)
! 
!           !calculate new triangle normal in 3d cartesian and geographical coordinates
!           !Move adjacent cells to new coordinate system
!           il_c1 = p_patch%edges%cell_idx(ile,ibe,1)
!           ib_c1 = p_patch%edges%cell_blk(ile,ibe,1)
!           il_c2 = p_patch%edges%cell_idx(ile,ibe,2)
!           ib_c2 = p_patch%edges%cell_blk(ile,ibe,2)
! 
!           CALL disp_new( p_patch%cells%center(il_c1,ib_c1)%lon, &
!             &            p_patch%cells%center(il_c1,ib_c1)%lat, &
!             &            z_rlong,z_rlat, ll1%lon,ll1%lat)
! 
!           CALL disp_new( p_patch%cells%center(il_c2,ib_c2)%lon, &
!             &            p_patch%cells%center(il_c2,ib_c2)%lat, &
!             &            z_rlong,z_rlat, ll2%lon,ll2%lat)
! 
!             xx1 = gc2cc(ll1)
!             xx2 = gc2cc(ll2)
! 
!             !calculate normal in cartesian coordinates
!             normal_cc(ie)%x = (xx2%x - xx1%x)
!             norm_c0_e       = SQRT(SUM(normal_cc(ie)%x*normal_cc(ie)%x))  !arc_length(xx1,xx2) !
!             normal_cc(ie)%x =  normal_cc(ie)%x/norm_c0_e
! 
!            !normal at moved cell edge in geographical coordinates
!            CALL cvec2gvec ( normal_cc(ie)%x(1), normal_cc(ie)%x(2), normal_cc(ie)%x(3),&
!                           & gc_edge(ie)%lon, gc_edge(ie)%lat,&
!                           & normal_gc(ie)%lon,normal_gc(ie)%lat )
! 
!            !calculate cell edge distances from moved entities
!            cell_edge_dist(ie,1) = SQRT(SUM((cc_edge(ie)%x - xx1%x)*(cc_edge(ie)%x - xx1%x)))
!            cell_edge_dist(ie,2) = SQRT(SUM((cc_edge(ie)%x - xx2%x)*(cc_edge(ie)%x - xx2%x)))
! 
!            !calculate edge length of moved triangle
!            !adjacent vertices of moved edge
!            il_v1 = p_patch%edges%vertex_idx(ile,ibe,1)
!            ib_v1 = p_patch%edges%vertex_blk(ile,ibe,1)
!            il_v2 = p_patch%edges%vertex_idx(ile,ibe,2)
!            ib_v2 = p_patch%edges%vertex_blk(ile,ibe,2)
! 
!            !vertex 1 & 2 coordinates w.r.t. coordinates sytem in triangle center
!            CALL disp_new( p_patch%verts%vertex(il_v1,ib_v1)%lon, &
!                         & p_patch%verts%vertex(il_v1,ib_v1)%lat, &
!                         & z_rlong,z_rlat, ll1%lon,ll1%lat )
!            CALL disp_new( p_patch%verts%vertex(il_v2,ib_v2)%lon, &
!                         & p_patch%verts%vertex(il_v2,ib_v2)%lat, &
!                         & z_rlong,z_rlat, ll2%lon,ll2%lat )
!            xx1 = gc2cc(ll1)
!            xx2 = gc2cc(ll2)
! 
!            edge_length(ie) =  SQRT(SUM( (xx2%x - xx1%x)*(xx2%x - xx1%x))) !arc_length(xx1,xx2) !
!        END DO
! 
!       DO ie=1, no_cell_edges
! 
!        ile = p_patch%cells%edge_idx(jc,jb,ie)
!        ibe = p_patch%cells%edge_blk(jc,jb,ie)
! 
! 
!        IF(p_patch%edges%cell_idx(ile,ibe,1)==jc.AND.&
!         & p_patch%edges%cell_blk(ile,ibe,1)==jb)THEN
!          cell_edge_distance = cell_edge_dist(ie,1)
!        ELSEIF(p_patch%edges%cell_idx(ile,ibe,2)==jc.AND.&
!         & p_patch%edges%cell_blk(ile,ibe,2)==jb)THEN
!          cell_edge_distance = cell_edge_dist(ie,2)
!        ENDIF
! 
!        !aggregate volume of moved cell
!        p_patch%patch_oce%fixed_vol_norm(jc,jb) = p_patch%patch_oce%fixed_vol_norm(jc,jb) &
!                                              & + 0.5_wp*cell_edge_distance*edge_length(ie)
! 
!        p_patch%patch_oce%variable_vol_norm(jc,jb,ie) = 0.5_wp*cell_edge_distance*edge_length(ie)
! 
!         p_patch%patch_oce%edge2cell_coeff(jc,jb,ie,1)&
!         & = normal_gc(ie)%lon*cell_edge_distance*edge_length(ie)
!         p_patch%patch_oce%edge2cell_coeff(jc,jb,ie,2)&
!         & = normal_gc(ie)%lat*cell_edge_distance*edge_length(ie)
! 
!         END DO
!       END DO CELL_IDX_LOOP
!     END DO CELL_BLK_LOOP
! 
!     !Now we calculate the coefficients of the transposed of the edge to cell mapping,
!     !i.e. coefficients for a cell to edge mapping
! 
!     rl_start = 1  ! #slo# changed to 1 - 2010-11-15
!     rl_end = min_rledge
! 
!     i_startblk = p_patch%edges%start_blk(rl_start,1)
!     i_endblk   = p_patch%edges%end_blk(rl_end,1)
! 
! 
!     EDGE_BLK_LOOP: DO jb = i_startblk, i_endblk
! 
!       CALL get_indices_e(p_patch, jb, i_startblk, i_endblk, i_startidx, i_endidx, rl_start, rl_end)
! 
!       EDGE_IDX_LOOP: DO je =  i_startidx, i_endidx
! 
!         !Get indices of two adjacent triangles
!         il_c1 = p_patch%edges%cell_idx(je,jb,1)
!         ib_c1 = p_patch%edges%cell_blk(je,jb,1)
!         il_c2 = p_patch%edges%cell_idx(je,jb,2)
!         ib_c2 = p_patch%edges%cell_blk(je,jb,2)
! 
!         !cartesian coordinates of edge and neighbor cells on 1-sphere
!         cc_e0 = gc2cc(p_patch%edges%center(je,jb))
!         cc_c1 = gc2cc(p_patch%cells%center(il_c1,ib_c1))
!         cc_c2 = gc2cc(p_patch%cells%center(il_c2,ib_c2))
!         !cartesian vectors from:
!         !cell 2 to cell 1, cell 1 to edge je and cell 2 to edge je
!         cv_c1_c2%x = (cc_c1%x - cc_c2%x)
!         cv_c1_e0%x = (cc_e0%x - cc_c1%x)
!         cv_c2_e0%x = (cc_e0%x - cc_c2%x)
! 
!         norm_c1_c2 = SQRT(SUM(cv_c1_c2%x*cv_c1_c2%x))
! 
!         !Determine which edge of both of the two adjacent cells corresponds to the
!         !actual edge "je". This information is used below for the edge-orientation.
!         ! #slo# check if ie_1 ie_2 are set here correctly - gcc compiler warnings
!         DO ie=1,no_cell_edges
!           IF (p_patch%cells%edge_idx(il_c1,ib_c1,ie) == je.AND.&
!             & p_patch%cells%edge_blk(il_c1,ib_c1,ie) == jb) THEN
!             ie_1 = ie
!           END IF
!           IF (p_patch%cells%edge_idx(il_c2,ib_c2,ie) == je.AND.&
!             & p_patch%cells%edge_blk(il_c2,ib_c2,ie) == jb) THEN
!             ie_2 = ie
!           END IF
!         END DO
!          p_patch%patch_oce%edge2cell_coeff_t(je,jb,1)%x&
!          & = cv_c1_e0%x * p_patch%cells%edge_orientation(il_c1,ib_c1,ie_1)/norm_c1_c2
!          p_patch%patch_oce%edge2cell_coeff_t(je,jb,2)%x&
!          & = cv_c2_e0%x * p_patch%cells%edge_orientation(il_c2,ib_c2,ie_2)/norm_c1_c2
! 
!       END DO EDGE_IDX_LOOP
!     END DO EDGE_BLK_LOOP
! !!$OMP END DO
! !!$OMP END PARALLEL
!     !------------------------------------------------------------------------------
!     !Step 2: calculation of coefficients for dual grid
! 
!     rl_start = 1  ! #slo# changed to 1 - 2010-11-15
!     rl_end = min_rlvert
! 
!     i_startblk = p_patch%verts%start_blk(rl_start,1)
!     i_endblk   = p_patch%verts%end_blk(rl_end,1)
! 
! 
!     VERT_BLK_LOOP: DO jb = i_startblk, i_endblk
! 
!       CALL get_indices_v(p_patch, jb, i_startblk, i_endblk, i_startidx, i_endidx, rl_start, rl_end)
! 
!       VERT_IDX_LOOP: DO jv =  i_startidx, i_endidx
! 
!         ! current number of edges around vertex (5 or 6)
!         it_vertedges = p_patch%verts%num_edges(jv,jb)
! 
!         z_lon = p_patch%verts%vertex(jv,jb)%lon
!         z_lat = p_patch%verts%vertex(jv,jb)%lat
! 
!         !vertex center origin of new coordinate system
!         z_rlong = p_patch%verts%vertex(jv,jb)%lon
!         z_rlat  = p_patch%verts%vertex(jv,jb)%lat
! 
!         gc_v0%lon = z_rlong
!         gc_v0%lat = z_rlat
!         cc_v0     = gc2cc(gc_v0)
! 
!         !new coordinates
!         z_long_c = 0._wp
!         z_lat_c  = 0._wp
!         IF (z_long_c>pi)  z_long_c = z_long_c - z_twopi
! 
!         !transform coordinates of edge midpoint ie to new coordinate system
!         DO ie=1, no_vert_edges
! 
!           ! calculate coefficients for existing edges only
!           IF (ie > it_vertedges) CYCLE
! 
!           il_e = p_patch%verts%edge_idx(jv,jb,ie)
!           ib_e = p_patch%verts%edge_blk(jv,jb,ie)
! 
!           CALL disp_new( p_patch%edges%center(il_e,ib_e)%lon,&
!                        & p_patch%edges%center(il_e,ib_e)%lat,&
!                        & z_rlong,z_rlat,&
!                        & gc_dual_edge(ie)%lon,gc_dual_edge(ie)%lat)
!           cc_dual_edge(ie) = gc2cc(gc_dual_edge(ie))
!         END DO
! 
!         !all longitudes between -pi and pi
!         z_longmax = MAX( gc_dual_edge(1)%lon, gc_dual_edge(2)%lon, gc_dual_edge(3)%lon )
!         z_longmin = MIN( gc_dual_edge(1)%lon, gc_dual_edge(2)%lon, gc_dual_edge(3)%lon )
! 
!         IF( z_longmax-z_longmin>pi )THEN
!           IF( z_long_c>pi )  z_long_c  = z_long_c - z_twopi
!           IF( gc_dual_edge(1)%lon>pi ) gc_dual_edge(1)%lon = gc_dual_edge(1)%lon -z_twopi
!           IF( gc_dual_edge(2)%lon>pi ) gc_dual_edge(2)%lon = gc_dual_edge(2)%lon -z_twopi
!           IF( gc_dual_edge(3)%lon>pi ) gc_dual_edge(3)%lon = gc_dual_edge(3)%lon -z_twopi
!         ENDIF
! 
!         DO ie=1, no_vert_edges
! 
!           ! calculate coefficients for existing edges only
!           IF (ie > it_vertedges) CYCLE
! 
!           il_e = p_patch%verts%edge_idx(jv,jb,ie)
!           ib_e = p_patch%verts%edge_blk(jv,jb,ie)
! 
!           !Parts of this code parrallels the implementation in the grid-generator
!           !module "mo_geometry".
!           !
!           !1) determine normal vector from adjacent cell to adjacent cell
!           !   in cartesian coordinate for moved dual cell
!           !Get indices of two adjacent triangles
!           il_c1 = p_patch%edges%cell_idx(il_e,ib_e,1)
!           ib_c1 = p_patch%edges%cell_blk(il_e,ib_e,1)
!           il_c2 = p_patch%edges%cell_idx(il_e,ib_e,2)
!           ib_c2 = p_patch%edges%cell_blk(il_e,ib_e,2)
! 
!           CALL disp_new( p_patch%cells%center(il_c1,ib_c1)%lon,&
!                        & p_patch%cells%center(il_c1,ib_c1)%lat,&
!                        & z_rlong,z_rlat,&
!                        & ll1%lon,ll1%lat)
! 
!           CALL disp_new( p_patch%cells%center(il_c2,ib_c2)%lon,&
!                        & p_patch%cells%center(il_c2,ib_c2)%lat,&
!                        & z_rlong,z_rlat,&
!                        & ll2%lon,ll2%lat )
!           xx1 = gc2cc(ll1)
!           xx2 = gc2cc(ll2)
! 
!           cell2cell_cc%x       = (xx2%x - xx1%x)
!           norm_c1_c2           = SQRT(SUM(cell2cell_cc%x*cell2cell_cc%x))
!           dual_edge_length(ie) = norm_c1_c2
!           cell2cell_cc%x       = cell2cell_cc%x/norm_c1_c2
!           IF(MID_POINT_DUAL_EDGE)THEN
!             cc_mid_dual_edge(ie)%x = 0.5_wp*(xx2%x+xx1%x)
!           ELSE
!             cc_mid_dual_edge(ie)%x = cc_dual_edge(ie)%x
!           ENDIF
!           !2) determine vector from adjacent vertex to adjacent vertex
!           !   in cartesian coordinate for moved dual cell
!           !Get indices of two adjacent vertices
!           il_v1 = p_patch%edges%vertex_idx(il_e,ib_e,1)
!           ib_v1 = p_patch%edges%vertex_blk(il_e,ib_e,1)
!           il_v2 = p_patch%edges%vertex_idx(il_e,ib_e,2)
!           ib_v2 = p_patch%edges%vertex_blk(il_e,ib_e,2)
! 
!           CALL disp_new( p_patch%verts%vertex(il_v1,ib_v1)%lon,&
!                        & p_patch%verts%vertex(il_v1,ib_v1)%lat,&
!                        & z_rlong,z_rlat,&
!                        & ll1%lon,ll1%lat)
!           CALL disp_new( p_patch%verts%vertex(il_v2,ib_v2)%lon,&
!                        & p_patch%verts%vertex(il_v2,ib_v2)%lat,&
!                        & z_rlong,z_rlat,&
!                        & ll2%lon,ll2%lat )
!           xx1 = gc2cc(ll1)
!           xx2 = gc2cc(ll2)
! 
!           vert2vert_cc(jv, jb, ie)%x = xx2%x - xx1%x
! 
!           !calculate vertex edge distance
! !           vert_edge_dist(ie,1)&
! !           & = SQRT(SUM((cc_dual_edge(ie)%x - xx1%x)*(cc_dual_edge(ie)%x - xx1%x)))
! !           vert_edge_dist(ie,2)&
! !           & = SQRT(SUM((cc_dual_edge(ie)%x - xx2%x)*(cc_dual_edge(ie)%x - xx2%x)))
! ! 
! !           vert_dual_mid_dist(ie,1)&
! !           & = SQRT(SUM((cc_mid_dual_edge(ie)%x - xx1%x)*(cc_mid_dual_edge(ie)%x - xx1%x)))
! !           vert_dual_mid_dist(ie,2)&
! !           & = SQRT(SUM((cc_mid_dual_edge(ie)%x - xx2%x)*(cc_mid_dual_edge(ie)%x - xx2%x)))
! 
!           vert_edge_dist(ie,1) = arc_length (cc_dual_edge(ie), xx1) 
!           vert_edge_dist(ie,2) = arc_length (cc_dual_edge(ie), xx2) 
! 
!           vert_dual_mid_dist(ie,1)= arc_length (cc_mid_dual_edge(ie), xx1) 
!           vert_dual_mid_dist(ie,2)= arc_length (cc_mid_dual_edge(ie), xx2)
! 
! 
!           !calculate normal vector that is perpendicular to vertex-vertex- and edge position vector
!           !If one uses the edge position vector this results in the moved primal normal. Later
!           !edge position vector has to be replaced by the midpoint of the dual edge.
!           recon_vec_cc   = vector_product(vert2vert_cc(jv, jb, ie), cc_mid_dual_edge(ie))
! 
!           norm           = SQRT(SUM(recon_vec_cc%x*recon_vec_cc%x))
!           recon_vec_cc%x = recon_vec_cc%x/norm
! 
!           !Fix orientation
!           z_tmp =  DOT_PRODUCT(recon_vec_cc%x, cell2cell_cc%x)
!           IF (z_tmp <0._wp) recon_vec_cc%x = -1._wp * recon_vec_cc%x
! 
!           !Transform to geographical coordinates
! !gc_dual_edge(ie)=cc2gc(cc_mid_dual_edge(ie))
!           CALL cvec2gvec ( recon_vec_cc%x(1), recon_vec_cc%x(2), recon_vec_cc%x(3), &
!             &              gc_dual_edge(ie)%lon, gc_dual_edge(ie)%lat,              &
!             &              recon_vec_gc(ie)%lon, recon_vec_gc(ie)%lat )
! 
!         END DO
! 
!         DO ie=1, no_vert_edges
! 
!           ! calculate coefficients for existing edges only
!           IF (ie > it_vertedges) CYCLE
! 
!           il_e = p_patch%verts%edge_idx(jv,jb,ie)
!           ib_e = p_patch%verts%edge_blk(jv,jb,ie)
! 
!           IF      ( (p_patch%edges%vertex_idx(il_e,ib_e,1) == jv) .and. &
!                     (p_patch%edges%vertex_blk(il_e,ib_e,1) == jb) ) THEN
!             vert_edge_distance     = vert_edge_dist(ie,1)
!             vert_dual_mid_distance = vert_dual_mid_dist(ie,1)
!           ELSE IF ( (p_patch%edges%vertex_idx(il_e,ib_e,2) == jv) .and. &
!                     (p_patch%edges%vertex_blk(il_e,ib_e,2) == jb) ) THEN
!             vert_edge_distance     = vert_edge_dist(ie,2)
!             vert_dual_mid_distance = vert_dual_mid_dist(ie,2)
!           ELSE
!             CALL message (TRIM(routine), 'WARNING - vert_edge_distance not found')
!             write(*,*) 'p_patch%edges%vertex_idx(il_e,ib_e,1)=', &
!                         p_patch%edges%vertex_idx(il_e,ib_e,1)
!           END IF
!           p_patch%patch_oce%edge2vert_coeff(jv,jb,ie,1) = &
!             & recon_vec_gc(ie)%lon*vert_dual_mid_distance*dual_edge_length(ie)
! 
!           p_patch%patch_oce%edge2vert_coeff(jv,jb,ie,2) = &
!             & recon_vec_gc(ie)%lat*vert_dual_mid_distance*dual_edge_length(ie)
! 
!           p_patch%patch_oce%variable_dual_vol_norm(jv,jb,ie) = &
!                   &0.5_wp*vert_edge_distance*dual_edge_length(ie)
! 
! !write(*,*)'edge2vert coeff',(jb-1)*16+jv, jv,jb,ie,p_patch%patch_oce%edge2vert_coeff(jv,jb,ie,1)&
! !&, p_patch%patch_oce%edge2vert_coeff(jv,jb,ie,2)
!         END DO
! 
! !        DO ie=1, no_vert_edges
! ! write(*,*)'edge2vert coeff',(jb-1)*16+jv, jv,jb,ie,p_patch%patch_oce%edge2vert_coeff(jv,jb,ie,1)&
! ! &, p_patch%patch_oce%edge2vert_coeff(jv,jb,ie,2), p_patch%patch_oce%variable_dual_vol_norm(jv,jb,ie) 
! ! end do
!       ENDDO VERT_IDX_LOOP
!     END DO VERT_BLK_LOOP
! 
! 
! 
!     !Now we calculate the coefficients for the transposed of the edge to vertex mapping
!     i_startblk = p_patch%edges%start_blk(rl_start,1)
!     i_endblk   = p_patch%edges%end_blk(rl_end,1)
! 
!     EDGE_BLK_LOOP_2 : DO jb = i_startblk, i_endblk
! 
!       CALL get_indices_e(p_patch, jb, i_startblk, i_endblk, i_startidx, i_endidx, rl_start, rl_end)
! 
!       EDGE_IDX_LOOP_2: DO je =  i_startidx, i_endidx
! 
!         !Step 1: get relevant coordinates and vectors
!         !
!         !Get indices of two adjacent vertices and cells
!         il_v1 = p_patch%edges%vertex_idx(je,jb,1)
!         ib_v1 = p_patch%edges%vertex_blk(je,jb,1)
!         il_v2 = p_patch%edges%vertex_idx(je,jb,2)
!         ib_v2 = p_patch%edges%vertex_blk(je,jb,2)
! 
!         il_c1 = p_patch%edges%cell_idx(je,jb,1)
!         ib_c1 = p_patch%edges%cell_blk(je,jb,1)
!         il_c2 = p_patch%edges%cell_idx(je,jb,2)
!         ib_c2 = p_patch%edges%cell_blk(je,jb,2)
! 
! 
! !         ll1%lon = p_patch%cells%center(il_c1,ib_c1)%lon
! !         ll1%lat = p_patch%cells%center(il_c1,ib_c1)%lat
! !         ll2%lon = p_patch%cells%center(il_c2,ib_c2)%lon
! !         ll2%lat = p_patch%cells%center(il_c2,ib_c2)%lat
! 
!         xx1 = gc2cc(p_patch%cells%center(il_c1,ib_c1))          !gc2cc(ll1)
!         xx2 = gc2cc(p_patch%cells%center(il_c2,ib_c2))         !gc2cc(ll2)
! 
!         !cartesian coordinates of edge and neighbor cells
!         IF(MID_POINT_DUAL_EDGE)THEN
!         cc_e0%x =0.5_wp*(xx2%x+xx1%x) !cc_edge(ie)%x
!         ELSE
!           cc_e0 = gc2cc(p_patch%edges%center(je,jb))
!         ENDIF
! 
!         gc_e0 = cc2gc(cc_e0)
! 
!         cc_v1 = gc2cc(p_patch%verts%vertex(il_v1,ib_v1))
!         cc_v2 = gc2cc(p_patch%verts%vertex(il_v2,ib_v2))
! 
!         !cartesian vectors from: vertex 2 to vertex 1
!         ! vertex 1 to edge je and vertex 2 to edge je
!         cv_v1_v2%x = (cc_v2%x - cc_v1%x)
!         cv_v1_e0%x = (cc_e0%x - cc_v1%x)
!         cv_v2_e0%x = (cc_e0%x - cc_v2%x)
! 
!         norm_v1_e0  = SQRT(SUM(cv_v1_e0%x*cv_v1_e0%x))
!         norm_v2_e0  = SQRT(SUM(cv_v2_e0%x*cv_v2_e0%x))
! 
!         if(mid_point_dual_edge)then
!           norm_v1_v2 = norm_v1_e0 + norm_v2_e0
!         else 
!           norm_v1_v2 = sqrt(sum(cv_v1_v2%x*cv_v1_v2%x))
!        endif
!  
!         p_patch%patch_oce%edge2vert_coeff_t(je,jb,1)%x = cv_v1_e0%x * &
!           &    ( p_patch%edges%system_orientation(je,jb)/norm_v1_v2 )
! 
!         p_patch%patch_oce%edge2vert_coeff_t(je,jb,2)%x = cv_v2_e0%x * &
!           &    ( p_patch%edges%system_orientation(je,jb)/norm_v1_v2 )
! 
!       END DO EDGE_IDX_LOOP_2
!     END DO EDGE_BLK_LOOP_2
! 
!     CALL message (TRIM(routine), 'end')
! 
!   END SUBROUTINE init_scalar_product_orig
! ! !-------------------------------------------------------------------------------------
! !   !
! !   !>
! !   !! Computes the coefficients that determine the scalar product on the primal grid. This
! !   !! scalar product depends on the grid geometry only and  is used to formulate the primitive
! !   !! equations in weak form. The coefficients are applied in module "mo_scalar_product".
! !   !! The following components of the data type "ocean_patch" are filled:
! !   !!   edge2cell_coeff  : coefficients for edge to cell mapping
! !   !!   edge2cell_coeff_t: coefficients for transposed of edge to cell mappings
! !   !!   edge2vert_coeff  : coefficients for edge to vertex mapping
! !   !!   edge2vert_coeff_t: coefficients for transposed of edge to vertex mappings
! !   !!   fixed_vol_norm   : summed volume weight of moved cell
! !   !!   variable_vol_norm: volume weight at the edges of moved cell
! !   !!
! !   !! @par Revision History
! !   !!  developed by Peter Korn, MPI-M  2010-09
! !   !!  Modification by Stephan Lorenz, 2010-11
! !   !!
! !   SUBROUTINE init_scalar_product_OK( p_patch)
! ! 
! !     !  patch on which computation is performed
! !     !
! !     TYPE(t_patch), TARGET, INTENT(inout) :: p_patch
! ! 
! !     CHARACTER(len=MAX_CHAR_LENGTH), PARAMETER :: &
! !     & routine = ('mo_ocean_topo:init_scalar_product')
! ! 
! !     INTEGER, PARAMETER :: no_cell_edges = 3
! !     INTEGER, PARAMETER :: no_vert_edges = 6
! !     INTEGER :: jb, je, jc, jv, ie, ile, ibe, ie_1, ie_2
! !     INTEGER :: il_e, ib_e, it_vertedges,k
! !     INTEGER :: il_c1, ib_c1, il_c2, ib_c2
! !     INTEGER :: il_v1, il_v2, ib_v1, ib_v2
! ! 
! !     INTEGER :: iil_c1(no_cell_edges), iil_c2(no_cell_edges)
! !     INTEGER :: iib_c1(no_cell_edges), iib_c2(no_cell_edges)
! ! 
! !     INTEGER :: il_c1_e1, ib_c1_e1, il_c1_e2, ib_c1_e2, il_c1_e3, ib_c1_e3
! !     INTEGER :: il_c2_e1, ib_c2_e1, il_c2_e2, ib_c2_e2, il_c2_e3, ib_c2_e3
! ! 
! !     INTEGER :: rl_start, rl_end
! !     INTEGER :: i_startblk, i_endblk, i_startidx, i_endidx
! ! 
! !     REAL(wp) :: z_lon, z_lat, z_u,z_v,z_rlong, z_rlat, z_long_c, z_lat_c
! !     REAL(wp) :: z_twopi, z_longmax, z_longmin, z_tmp
! !     REAL(wp) :: cell_edge_dist(no_cell_edges,2)
! !     REAL(wp) :: cell_edge_distance
! !     REAL(wp) :: norm_c1_c2, norm_c0_e, norm_v1_v2, norm, norm_v1_e0, norm_v2_e0
! !     REAL(wp) :: dual_edge_length(no_vert_edges)
! !     REAL(wp) :: edge_length(no_cell_edges)
! !     REAL(wp) :: vert_edge_dist(no_vert_edges,2)    
! !     REAL(wp) :: vert_dual_mid_dist(no_vert_edges,2)
! !     REAL(wp) :: vert_edge_distance, vert_dual_mid_distance!, dist_edge_cell, dist_vert_vert
! ! 
! !     TYPE(t_geographical_coordinates) :: gc_edge(no_cell_edges), gc_dual_edge(no_vert_edges)
! !     TYPE(t_geographical_coordinates) :: gc_c0, gc_v0, gc_e0
! !     TYPE(t_geographical_coordinates) :: ll1, ll2, ll3
! !     TYPE(t_cartesian_coordinates)    :: cc_edge(no_cell_edges), cc_dual_edge(no_vert_edges)
! !     TYPE(t_cartesian_coordinates)    :: xx1,xx2,xx3
! !     TYPE(t_cartesian_coordinates)    :: normal_cc(no_cell_edges)
! !     TYPE(t_cartesian_coordinates)    :: cell2cell_cc
! !     TYPE(t_cartesian_coordinates)    :: cc_c1, cc_c2, cc_e0, cc_c0, cc_v0, cc_v1, cc_v2
! !     TYPE(t_cartesian_coordinates)    :: cv_c1_e0, cv_c2_e0, cv_c1_c2
! !     TYPE(t_cartesian_coordinates)    :: cv_v1_e0, cv_v2_e0, cv_v1_v2
! !     TYPE(t_cartesian_coordinates)    :: cc_mid_dual_edge(no_vert_edges)
! !     TYPE(t_cartesian_coordinates)    :: vert2vert_cc(nproma,p_patch%nblks_v,no_vert_edges)
! !     TYPE(t_cartesian_coordinates)    :: recon_vec_cc
! !     TYPE(t_geographical_coordinates) :: recon_vec_gc(no_vert_edges)
! !     TYPE(t_geographical_coordinates) :: normal_gc(no_cell_edges)
! ! 
! ! 
! !     TYPE(t_cartesian_coordinates)    :: cc_c1_e1, cc_c1_e2, cc_c1_e3
! !     TYPE(t_cartesian_coordinates)    :: cc_c2_e1, cc_c2_e2, cc_c2_e3
! !     TYPE(t_cartesian_coordinates)    :: cv_c1_e1, cv_c1_e2, cv_c1_e3
! !     TYPE(t_cartesian_coordinates)    :: cv_c2_e1, cv_c2_e2, cv_c2_e3
! !     TYPE(t_cartesian_coordinates)    :: z_vec_c1(no_cell_edges),z_vec_c2(no_cell_edges), z_vec
! ! 
! !     REAL(wp) :: length
! !     REAL(wp) :: z_edge_length(no_cell_edges)
! !     REAL(wp) :: z_cell_edge_dist_c1(no_cell_edges),z_cell_edge_dist_c2(no_cell_edges)
! ! 
! !     REAL(wp) :: vn(nproma,1,p_patch%nblks_e)
! !     REAL(wp) :: ptp_vn(nproma,1,p_patch%nblks_e), tmp_1, tmp_2
! ! 
! !     REAL(wp) :: edge_length_c1_e1, edge_length_c1_e2,edge_length_c1_e3
! !     REAL(wp) :: edge_length_c2_e1, edge_length_c2_e2,edge_length_c2_e3
! !     !TYPE(t_geographical_coordinates) :: gc_tmp(2)
! !     LOGICAL, PARAMETER :: MID_POINT_DUAL_EDGE = .TRUE. !Please do not change this unless
! !                                                        !you are sure, you know what you do.
! !     !-----------------------------------------------------------------------
! !     CALL message (TRIM(routine), 'start')
! ! 
! !     rl_start = 1
! !     rl_end = min_rledge
! ! 
! !     i_startblk = p_patch%edges%start_blk(rl_start,1)
! !     i_endblk   = p_patch%edges%end_blk(rl_end,1)
! ! 
! !     EDGE_BLK_LOOP: DO jb = i_startblk, i_endblk
! ! 
! !       CALL get_indices_e(p_patch, jb, i_startblk, i_endblk, i_startidx, i_endidx, rl_start, rl_end)
! ! 
! !       EDGE_IDX_LOOP: DO je =  i_startidx, i_endidx
! ! 
! !         !Get indices of two adjacent triangles
! !         il_c1 = p_patch%edges%cell_idx(je,jb,1)
! !         ib_c1 = p_patch%edges%cell_blk(je,jb,1)
! !         il_c2 = p_patch%edges%cell_idx(je,jb,2)
! !         ib_c2 = p_patch%edges%cell_blk(je,jb,2)
! ! 
! !         p_patch%patch_oce%fixed_vol_norm(il_c1,ib_c1)     = 0.0_wp
! !         p_patch%patch_oce%fixed_vol_norm(il_c2,ib_c2)     = 0.0_wp
! !         p_patch%patch_oce%variable_vol_norm(il_c1,ib_c1,:)= 0.0_wp
! !         p_patch%patch_oce%variable_vol_norm(il_c2,ib_c2,:)= 0.0_wp
! ! 
! !         !normals in cell 1
! !         DO ie=1,no_cell_edges
! ! 
! !           iil_c1(ie) = p_patch%cells%edge_idx(il_c1,ib_c1,ie)
! !           iib_c1(ie) = p_patch%cells%edge_blk(il_c1,ib_c1,ie)
! ! 
! ! !           z_lon = p_patch%edges%center(iil_c1(ie),iib_c1(ie))%lon
! ! !           z_lat = p_patch%edges%center(iil_c1(ie),iib_c1(ie))%lat
! ! !           ! zonal and meridional component of primal normal
! ! !           z_u = p_patch%edges%primal_normal(iil_c1(ie),iib_c1(ie))%v1
! ! !           z_v = p_patch%edges%primal_normal(iil_c1(ie),iib_c1(ie))%v2
! ! !           ! calculate Cartesian components of primal normal
! ! !           CALL gvec2cvec( z_u, z_v,&
! ! !                         & z_lon, z_lat,&
! ! !                         & z_vec_c1(ie)%x(1), z_vec_c1(ie)%x(2), z_vec_c1(ie)%x(3) )
! ! !           length = SQRT( DOT_PRODUCT(z_vec_c1(ie)%x(1:3),z_vec_c1(ie)%x(1:3)) )
! ! !           z_vec_c1(ie)%x = z_vec_c1(ie)%x/length
! ! 
! !          z_vec_c1(ie) = p_patch%edges%primal_cart_normal(iil_c1(ie),iib_c1(ie))
! ! 
! !           !idx/blk of two neighbor cells to iil_c1(ie), iib_c1(ie)
! !          il_c1_e1 = p_patch%edges%cell_idx(iil_c1(ie),iib_c1(ie),1)
! !          ib_c1_e1 = p_patch%edges%cell_blk(iil_c1(ie),iib_c1(ie),1)
! ! 
! !          il_c1_e2 = p_patch%edges%cell_idx(iil_c1(ie),iib_c1(ie),2)
! !          ib_c1_e2 = p_patch%edges%cell_blk(iil_c1(ie),iib_c1(ie),2) 
! ! 
! ! 
! !          IF(il_c1_e1==il_c1.AND.ib_c1_e1==ib_c1)THEN
! !           k=1
! !          ELSEIF(il_c1_e2==il_c1.AND.ib_c1_e2==ib_c1)THEN
! !           k=2
! !          ENDIF
! !          z_cell_edge_dist_c1(ie)=p_patch%edges%edge_cell_length(iil_c1(ie),iib_c1(ie),k)/re 
! !          z_edge_length(ie) = p_patch%edges%primal_edge_length(iil_c1(ie),iib_c1(ie))/re
! ! 
! ! !             z_edge_length(ie)      = calc_edge_length_cc(p_patch, iil_c1(ie),iib_c1(ie))
! ! !             z_cell_edge_dist_c1(ie)= calc_cell_edge_dist_cc(p_patch,&
! ! !                                    & iil_c1(ie),iib_c1(ie),&
! ! !                                    & il_c1,ib_c1 )
! ! 
! !            p_patch%patch_oce%edge2cell_coeff_cc(il_c1,ib_c1,ie)%x(1)&
! !            & = z_vec_c1(ie)%x(1)*z_cell_edge_dist_c1(ie)*z_edge_length(ie)
! ! 
! !            p_patch%patch_oce%edge2cell_coeff_cc(il_c1,ib_c1,ie)%x(2)&
! !            & = z_vec_c1(ie)%x(2)*z_cell_edge_dist_c1(ie)*z_edge_length(ie)
! ! 
! !            p_patch%patch_oce%edge2cell_coeff_cc(il_c1,ib_c1,ie)%x(3)&
! !            & = z_vec_c1(ie)%x(3)*z_cell_edge_dist_c1(ie)*z_edge_length(ie)
! ! 
! ! !          norm_fact = norm_fact + z_cell_edge_dist_c1(ie)*z_edge_length(ie)
! !           p_patch%patch_oce%fixed_vol_norm(il_c1,ib_c1)&
! !           & = p_patch%patch_oce%fixed_vol_norm(il_c1,ib_c1)&
! !           & + 0.5_wp*z_cell_edge_dist_c1(ie)*z_edge_length(ie)
! !           p_patch%patch_oce%variable_vol_norm(il_c1,ib_c1,ie)&
! !           & = 0.5_wp*z_cell_edge_dist_c1(ie)*z_edge_length(ie)
! !         END DO
! ! 
! !         !normals in cell 2
! !         DO ie=1,no_cell_edges
! ! 
! !           iil_c2(ie) = p_patch%cells%edge_idx(il_c2,ib_c2,ie)
! !           iib_c2(ie) = p_patch%cells%edge_blk(il_c2,ib_c2,ie)
! ! 
! ! !           z_lon = p_patch%edges%center(iil_c2(ie),iib_c2(ie))%lon
! ! !           z_lat = p_patch%edges%center(iil_c2(ie),iib_c2(ie))%lat
! ! !           ! zonal and meridional component of primal normal
! ! !           z_u = p_patch%edges%primal_normal(iil_c2(ie),iib_c2(ie))%v1
! ! !           z_v = p_patch%edges%primal_normal(iil_c2(ie),iib_c2(ie))%v2
! ! !           ! calculate Cartesian components of primal normal
! ! !           CALL gvec2cvec( z_u, z_v,&
! ! !                         & z_lon, z_lat,&
! ! !                         & z_vec_c2(ie)%x(1), z_vec_c2(ie)%x(2), z_vec_c2(ie)%x(3) )
! ! !           length = SQRT( DOT_PRODUCT(z_vec_c2(ie)%x(1:3),z_vec_c2(ie)%x(1:3)) )
! ! !           z_vec_c2(ie)%x=z_vec_c2(ie)%x/length
! ! 
! !           z_vec_c2(ie) = p_patch%edges%primal_cart_normal(iil_c2(ie),iib_c2(ie))
! ! 
! !           !idx/blk of two neighbor cells to iil_c2(ie), iib_c2(ie)
! !           il_c1_e1 = p_patch%edges%cell_idx(iil_c2(ie),iib_c2(ie),1)
! !           ib_c1_e1 = p_patch%edges%cell_blk(iil_c2(ie),iib_c2(ie),1)
! ! 
! !           il_c1_e2 = p_patch%edges%cell_idx(iil_c2(ie),iib_c2(ie),2)
! !           ib_c1_e2 = p_patch%edges%cell_blk(iil_c2(ie),iib_c2(ie),2) 
! ! 
! ! 
! !           IF(il_c1_e1==il_c2.AND.ib_c1_e1==ib_c2)THEN
! !             k=1
! !           ELSEIF(il_c1_e2==il_c2.AND.ib_c1_e2==ib_c2)THEN
! !             k=2
! !           ENDIF
! !            z_cell_edge_dist_c2(ie)=p_patch%edges%edge_cell_length(iil_c2(ie),iib_c2(ie),k)/re 
! !            z_edge_length(ie) = p_patch%edges%primal_edge_length(iil_c2(ie),iib_c2(ie))/re
! ! 
! ! !            z_edge_length(ie)      = calc_edge_length_cc(p_patch, iil_c2(ie),iib_c2(ie))
! ! !            z_cell_edge_dist_c2(ie)= calc_cell_edge_dist_cc(p_patch,&
! ! !                                   & iil_c2(ie),iib_c2(ie),&
! ! !                                   & il_c2,ib_c2 )
! ! 
! !           p_patch%patch_oce%edge2cell_coeff_cc(il_c2,ib_c2,ie)%x(1)&
! !           & = z_vec_c2(ie)%x(1)*z_cell_edge_dist_c2(ie)*z_edge_length(ie)
! ! 
! !           p_patch%patch_oce%edge2cell_coeff_cc(il_c2,ib_c2,ie)%x(2)&
! !           & = z_vec_c2(ie)%x(2)*z_cell_edge_dist_c2(ie)*z_edge_length(ie)
! ! 
! !           p_patch%patch_oce%edge2cell_coeff_cc(il_c2,ib_c2,ie)%x(3)&
! !           & = z_vec_c2(ie)%x(3)*z_cell_edge_dist_c2(ie)*z_edge_length(ie)
! ! 
! !           p_patch%patch_oce%fixed_vol_norm(il_c2,ib_c2)&
! !           & = p_patch%patch_oce%fixed_vol_norm(il_c2,ib_c2)&
! !           & + 0.5_wp*z_cell_edge_dist_c2(ie)*z_edge_length(ie)
! !           p_patch%patch_oce%variable_vol_norm(il_c2,ib_c2,ie) &
! !           &= 0.5_wp*z_cell_edge_dist_c2(ie)*z_edge_length(ie)
! !         END DO
! ! 
! ! 
! !         !calculate transposed coeff
! !         DO ie=1,no_cell_edges
! !           IF (p_patch%cells%edge_idx(il_c1,ib_c1,ie) == je.AND.&
! !             & p_patch%cells%edge_blk(il_c1,ib_c1,ie) == jb) THEN
! !             ie_1 = ie
! !           END IF
! !           IF (p_patch%cells%edge_idx(il_c2,ib_c2,ie) == je.AND.&
! !             & p_patch%cells%edge_blk(il_c2,ib_c2,ie) == jb) THEN
! !             ie_2 = ie
! !           END IF
! !        END DO
! !        p_patch%patch_oce%edge2cell_coeff_t(je,jb,1)%x = z_vec_c1(ie_1)%x &
! !        &  * p_patch%cells%edge_orientation(il_c1,ib_c1,ie_1)/z_cell_edge_dist_c1(ie_1)
! !        p_patch%patch_oce%edge2cell_coeff_t(je,jb,2)%x = z_vec_c1(ie_2)%x &
! !        &  * p_patch%cells%edge_orientation(il_c2,ib_c2,ie_2)/z_cell_edge_dist_c2(ie_2)
! ! 
! !       END DO EDGE_IDX_LOOP
! !     END DO EDGE_BLK_LOOP
! ! 
! !     CALL message (TRIM(routine), 'end')
! ! 
! !   END SUBROUTINE init_scalar_product_OK
  !-------------------------------------------------------------------------
  !
  !
  !>
  !! Precomputes the geometrical factors used in the divergence, rotation.
  !!
  !! Precomputes the geometrical factors used in the divergence, rotation
  !! and ??? operators stored in the patch_ocean instead of int_state
  !!
  !! @par Revision History
  !!  developed by Guenther Zaengl, 2009-03-17
  !!  Modification by Almut Gassmann, 2009-12-19
  !!  - Vorticity is computed on quads in case of the hexagonal grid
  !!  Modification by Almut Gassmann, 2010-02-05
  !!  - Added feature for poor men's 3rd order advection, where a directional
  !!    laplace is needed at the edges.
  !!  Modification by Stephan Lorenz, 2010-06-02
  !!  - Storage moved from int_state into patch_oce since it is static
  !!    geometric information used in the ocean model
  !!-Calculation of cell area changed to achieve compatibility with
  !!sw-model (cell area and consequently divergence different), PK, Nov 2010
  !!
  SUBROUTINE calc_geo_factors( ptr_patch )
    !
    IMPLICIT NONE
    !
    !  patch on which computation is performed
    !
    TYPE(t_patch), TARGET, INTENT(inout) :: ptr_patch
    !

    INTEGER :: jc, jb, je, jv, je1
    INTEGER :: rl_start, rl_end
    INTEGER :: i_startblk, i_endblk, i_startidx, i_endidx, i_nchdom

    INTEGER :: ile, ibe, ilc1, ibc1, ilc2, ibc2, ifac, ic, ilnc, ibnc
INTEGER :: ile1, ibe1,ile2,ibe2,ile3,ibe3
    !TYPE(cartesian_coordinates)::z_pn_k,z_pn_j
    !REAL(wp) :: z_lon, z_lat, z_nu, z_nv, z_proj
    REAL(wp) :: cell_area
    CHARACTER(len=MAX_CHAR_LENGTH), PARAMETER :: &
    & routine = ('mo_ocean_topo:calc_geo_factors')

    !-----------------------------------------------------------------------

    CALL message (TRIM(routine), 'start')

    i_nchdom   = MAX(1,ptr_patch%n_childdom)


!$OMP PARALLEL PRIVATE(rl_start,rl_end,i_startblk,i_endblk,ifac)
    ! a) Geometrical factor for divergence
    rl_start = 1
    rl_end = min_rlcell

    ! values for the blocking
    i_startblk = ptr_patch%cells%start_blk(rl_start,1)
    i_endblk   = ptr_patch%cells%end_blk(rl_end,i_nchdom)
    !
    ! loop through all patch cells (and blocks)
    !
!$OMP DO PRIVATE(jb,je,jc,i_startidx,i_endidx,ile,ibe)
    DO jb = i_startblk, i_endblk

      CALL get_indices_c(ptr_patch, jb, i_startblk, i_endblk,      &
        &                i_startidx, i_endidx, rl_start, rl_end)

      DO jc = i_startidx, i_endidx

         ile1 = ptr_patch%cells%edge_idx(jc,jb,1)
          ibe1 = ptr_patch%cells%edge_blk(jc,jb,1)
          ile2 = ptr_patch%cells%edge_idx(jc,jb,2)
          ibe2 = ptr_patch%cells%edge_blk(jc,jb,2)
          ile3 = ptr_patch%cells%edge_idx(jc,jb,3)
          ibe3 = ptr_patch%cells%edge_blk(jc,jb,3)

          cell_area =  0.25_wp&
  & *( ptr_patch%edges%primal_edge_length(ile1,ibe1)*ptr_patch%edges%dual_edge_length(ile1,ibe1)&
  &   +ptr_patch%edges%primal_edge_length(ile2,ibe2)*ptr_patch%edges%dual_edge_length(ile2,ibe2)&
  &   +ptr_patch%edges%primal_edge_length(ile3,ibe3)*ptr_patch%edges%dual_edge_length(ile3,ibe3))


       DO je = 1, i_cell_type

          IF (je > ptr_patch%cells%num_edges(jc,jb)) CYCLE ! relevant for hexagons

           ile = ptr_patch%cells%edge_idx(jc,jb,je)
           ibe = ptr_patch%cells%edge_blk(jc,jb,je)

           ptr_patch%patch_oce%geofac_div(jc,je,jb) =      &
         &   ptr_patch%edges%primal_edge_length(ile,ibe) * &
         &   ptr_patch%cells%edge_orientation(jc,jb,je)  / &
         &   ptr_patch%cells%area(jc,jb)

           ptr_patch%patch_oce%geofac_div(jc,je,jb) =      &
         &   ptr_patch%edges%primal_edge_length(ile,ibe) * &
         &   ptr_patch%cells%edge_orientation(jc,jb,je)  / &
         &   ptr_patch%cells%area(jc,jb)!cell_area

        ENDDO !edge loop

      ENDDO !idx loop

    END DO !block loop
!$OMP END DO

    ! b) Geometrical factor for rotation
    rl_start = 1  ! #slo# changed to 1 - 2010-12-07
    rl_end = min_rlvert

    ! Vorticity should have the right sign
      ifac = 0
      SELECT CASE (i_cell_type)
      CASE (3)
        ifac = 1
      CASE (6)
        ifac = -1
      END SELECT
      ! values for the blocking
      i_startblk = ptr_patch%verts%start_blk(rl_start,1)
      i_endblk   = ptr_patch%verts%end_blk(rl_end,i_nchdom)
      !
      ! loop through all patch cells (and blocks)
      !
!$OMP DO PRIVATE(jb,je,jv,i_startidx,i_endidx,ile,ibe)
      DO jb = i_startblk, i_endblk

        CALL get_indices_v(ptr_patch, jb, i_startblk, i_endblk, &
          &                i_startidx, i_endidx, rl_start, rl_end)

        DO je = 1, 9-i_cell_type
          DO jv = i_startidx, i_endidx

            IF (je > ptr_patch%verts%num_edges(jv,jb)) CYCLE   ! relevant for hexagons

            ile = ptr_patch%verts%edge_idx(jv,jb,je)
            ibe = ptr_patch%verts%edge_blk(jv,jb,je)

            ptr_patch%patch_oce%geofac_rot(jv,je,jb) =    &
         &    ptr_patch%edges%dual_edge_length(ile,ibe) * &
         &    ptr_patch%verts%edge_orientation(jv,jb,je)/ &
         &    ptr_patch%verts%dual_area(jv,jb) * REAL(ifac,wp)

          ENDDO !vertex loop
        ENDDO

      END DO !block loop
!$OMP END DO

      ! c) Geometrical factor for nabla2_scalar
      rl_start = 1  ! #slo# changed to 1 - 2010-12-07
      rl_end = min_rlcell

      ! values for the blocking
      i_startblk = ptr_patch%cells%start_blk(rl_start,1)
      i_endblk   = ptr_patch%cells%end_blk(rl_end,i_nchdom)
      !
      ! loop through all patch cells (and blocks)
      !
!$OMP DO PRIVATE(jb,je,jc,ic,i_startidx,i_endidx,ile,ibe,ilc1,ibc1,&
!$OMP    ilc2,ibc2,ilnc,ibnc)
      DO jb = i_startblk, i_endblk

        CALL get_indices_c(ptr_patch, jb, i_startblk, i_endblk, &
                           i_startidx, i_endidx, rl_start, rl_end)

        DO je = 1, i_cell_type
          DO jc = i_startidx, i_endidx

            ile = ptr_patch%cells%edge_idx(jc,jb,je)
            ibe = ptr_patch%cells%edge_blk(jc,jb,je)

            ilc1 = ptr_patch%edges%cell_idx(ile,ibe,1)
            ibc1 = ptr_patch%edges%cell_blk(ile,ibe,1)
            ilc2 = ptr_patch%edges%cell_idx(ile,ibe,2)
            ibc2 = ptr_patch%edges%cell_blk(ile,ibe,2)

            IF (jc == ilc1 .AND. jb == ibc1) THEN
              IF (i_cell_type == 3) THEN
                ptr_patch%patch_oce%geofac_n2s(jc,1,jb)       =  &
                &  ptr_patch%patch_oce%geofac_n2s(jc,1,jb)  -  &
                &  ptr_patch%patch_oce%geofac_div(jc,je,jb) /  &
                &  ptr_patch%edges%dual_edge_length(ile,ibe)
            ELSE IF (i_cell_type == 6) THEN
              ptr_patch%patch_oce%geofac_n2s(jc,1,jb)       =  &
                &  ptr_patch%patch_oce%geofac_n2s(jc,1,jb)  -  &
                &  ptr_patch%patch_oce%geofac_div(jc,je,jb) /  &
                &  ptr_patch%edges%dual_edge_length(ile,ibe)*  &
                &  ptr_patch%edges%system_orientation(ile,ibe)
            ENDIF
          ELSE IF (jc == ilc2 .AND. jb == ibc2) THEN
            IF (i_cell_type == 3) THEN
              ptr_patch%patch_oce%geofac_n2s(jc,1,jb)       =  &
                &  ptr_patch%patch_oce%geofac_n2s(jc,1,jb)  +  &
                &  ptr_patch%patch_oce%geofac_div(jc,je,jb) /  &
                &  ptr_patch%edges%dual_edge_length(ile,ibe)
            ELSE IF (i_cell_type == 6) THEN
              ptr_patch%patch_oce%geofac_n2s(jc,1,jb)       =  &
                &  ptr_patch%patch_oce%geofac_n2s(jc,1,jb)  +  &
                &  ptr_patch%patch_oce%geofac_div(jc,je,jb) /  &
                &  ptr_patch%edges%dual_edge_length(ile,ibe)*  &
                &  ptr_patch%edges%system_orientation(ile,ibe)
            ENDIF
          ENDIF
          DO ic = 1, i_cell_type
            ilnc = ptr_patch%cells%neighbor_idx(jc,jb,ic)
            ibnc = ptr_patch%cells%neighbor_blk(jc,jb,ic)
            IF (ilnc == ilc1 .AND. ibnc == ibc1) THEN
              IF (i_cell_type == 3) THEN
                ptr_patch%patch_oce%geofac_n2s(jc,ic+1,jb)     = &
                  &  ptr_patch%patch_oce%geofac_n2s(jc,ic+1,jb)- &
                  &  ptr_patch%patch_oce%geofac_div(jc,je,jb)  / &
                  &  ptr_patch%edges%dual_edge_length(ile,ibe)
              ELSE IF (i_cell_type == 6) THEN
                ptr_patch%patch_oce%geofac_n2s(jc,ic+1,jb)     = &
                  &  ptr_patch%patch_oce%geofac_n2s(jc,ic+1,jb)- &
                  &  ptr_patch%patch_oce%geofac_div(jc,je,jb)  / &
                  &  ptr_patch%edges%dual_edge_length(ile,ibe) * &
                  &  ptr_patch%edges%system_orientation(ile,ibe)
              ENDIF
            ELSE IF (ilnc == ilc2 .AND. ibnc == ibc2) THEN
              IF (i_cell_type == 3) THEN
                ptr_patch%patch_oce%geofac_n2s(jc,ic+1,jb)     = &
                  &  ptr_patch%patch_oce%geofac_n2s(jc,ic+1,jb)+ &
                  &  ptr_patch%patch_oce%geofac_div(jc,je,jb)  / &
                  &  ptr_patch%edges%dual_edge_length(ile,ibe)
              ELSE IF (i_cell_type == 6) THEN
                ptr_patch%patch_oce%geofac_n2s(jc,ic+1,jb)     = &
                  &  ptr_patch%patch_oce%geofac_n2s(jc,ic+1,jb)+ &
                  &  ptr_patch%patch_oce%geofac_div(jc,je,jb)  / &
                  &  ptr_patch%edges%dual_edge_length(ile,ibe) * &
                  &  ptr_patch%edges%system_orientation(ile,ibe)
              ENDIF
            ENDIF
          ENDDO

          ! To ensure that dummy edges have a factor of 0:
          IF (je > ptr_patch%cells%num_edges(jc,jb)) THEN
            ptr_patch%patch_oce%geofac_n2s(jc,je+1,jb) = 0._wp
          ENDIF

        ENDDO !cell loop
      ENDDO

    END DO !block loop
!$OMP END DO

    ! d) Geometrical factor for quad-cell divergence (triangles only)
    IF (i_cell_type == 3) THEN

      rl_start = 1  ! #slo# changed to 1 - 2010-12-07
      rl_end = min_rledge

      ! values for the blocking
      i_startblk = ptr_patch%edges%start_blk(rl_start,1)
      i_endblk   = ptr_patch%edges%end_blk(rl_end,i_nchdom)

!$OMP DO PRIVATE(jb,je,je1,i_startidx,i_endidx,ile,ibe)
      DO jb = i_startblk, i_endblk

        CALL get_indices_e(ptr_patch, jb, i_startblk, i_endblk, &
                           i_startidx, i_endidx, rl_start, rl_end)

        DO je1 = 1, 4
          DO je = i_startidx, i_endidx

          ile = ptr_patch%edges%quad_idx(je,jb,je1)
          ibe = ptr_patch%edges%quad_blk(je,jb,je1)

          ptr_patch%patch_oce%geofac_qdiv(je,je1,jb) = &
            ptr_patch%edges%primal_edge_length(ile,ibe) * &
            ptr_patch%edges%quad_orientation(je,jb,je1)  / &
            ptr_patch%edges%quad_area(je,jb)

          ENDDO !edge loop
        ENDDO

      END DO !block loop
!$OMP END DO

    ENDIF

    ! f) compute inverse dual edge length (used in math_operators for the ocean)

    rl_start = 1  ! #slo# changed to 1 - 2010-12-07
    rl_end = min_rledge

    ! Second step: computed projected orientation vectors and related information
    i_startblk = ptr_patch%edges%start_blk(rl_start,1)
    i_endblk   = ptr_patch%edges%end_blk(rl_end,i_nchdom)
    !
    ! loop through all patch edges
    !
!$OMP DO PRIVATE(jb,i_startidx,i_endidx,je)
    DO jb = i_startblk, i_endblk

      CALL get_indices_e(ptr_patch, jb, i_startblk, i_endblk, &
                         i_startidx, i_endidx, rl_start, rl_end)

      DO je =  i_startidx, i_endidx

        ! compute inverse dual edge length (undefined for refin_ctrl=1)

        ptr_patch%edges%inv_dual_edge_length(je,jb) = &
          1._wp/ptr_patch%edges%dual_edge_length(je,jb)

      ENDDO

    END DO !block loop
!$OMP END DO

!$OMP END PARALLEL

    CALL message (TRIM(routine), 'end')

  END SUBROUTINE calc_geo_factors


  !----------------------------------------------------------------------------
  SUBROUTINE nf(status)

    INTEGER, INTENT(in) :: status

    IF (status /= nf_noerr) THEN
      CALL finish('mo_ocean_topo netCDF error', nf_strerror(status))
    ENDIF

  END SUBROUTINE nf
!-------------------------------------------------------------------------  
!-------------------------------------------------------------------------  

END MODULE mo_ocean_topo
