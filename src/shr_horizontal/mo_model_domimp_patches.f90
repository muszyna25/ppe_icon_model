!>
!!               The module <i>mo_model_import_domain</i>.
!!
!!               The module <i>mo_model_import_domain</i>
!! provides functionality to import information about the models computational
!! domain. This information is read from several files that were generated by
!! the patch generator programm. The data types describing the model domain are
!! contained in <i>mo_domain_model</i>.
!!
!! @par Revision History
!! Initial version  by: Peter Korn,  MPI-M, Hamburg, June 2005
!! Modification by Thomas Heinze (2006-02-21):
!! - renamed m_modules to mo_modules
!! Modification by Thomas Heinze (2006-09-20):
!! - added routine grid_and_patch_diagnosis
!! Modification by Pilar Ripodas, DWD, (2007-01-31)
!! - addapted to the new TYPE grid_edges (system_orientation added)
!! Modification by Peter Korn,  MPI-M, (2006-12)
!! - implementation of topography and boundary treatment, i.e.
!!   initialization of the grid & patch components that carry
!!   information about topography and the lateral boundaries of
!!   the domain; this is not related to patch boundaries.
!!   topography can either be computed by analytical l,eans or
!!   by reading from database files.
!! Modification by Hui Wan, MPI-M, (2007-02-23)
!! - Subroutine <i>init_import</i> was changed to <i>setup_grid</i>.
!!   Namelist hierarchy_ini was renamed to <i>grid_ctl</i>, moved
!!   from <i>mo_io_utilities</i> to this module and now read from
!!   an external file in subroutine <i>setup_grid</i>.
!! - Some changes in <i>init_ocean_patch_component</i> after
!!   discussion with Peter.
!! - Calculation of the min. primal edge length was added to
!!   <i>import_patches</i>. However, shouldn't it be an array with
!!   one element for each patch, rather than a scalar?
!! Modification by P. Ripodas, DWD, (2007-03-14):
!! - Now the output of "import_patches" is the min_dual_edge_lenght
!!   instead of the min_primal_edge_lenght. It will be used to set
!!   the horizontal diffusion parameter. Now it is done as it was
!!   in the prototype.
!! Modification by Almut Gassmann, MPI-M (2007-04)
!! - removed loptimize to make compatible with new grid generator
!! - removed itoa for good programming style
!! - reorganized patch input to be compatible with the new patch generator
!! - cleaning up "destruct_patches"
!! Modification by Almut Gassmann, MPI-M (2007-04-13)
!! - remove grid type and perform related adaptations
!!   (grid information comes now inside a patch)
!! - changed subroutine name form setup_grid to setup_files
!! Modified by Hui Wan, MPI-M, (2008-04-04)
!!  - control variable loce renamed locean
!!  - topography_file_dir renamed topo_file_dir
!!  - for the hydro_atmos, control variable testtype renamed ctest_name.
!! Modified by Almut Gassmann, MPI-M, (2008-04-23)
!!  - itopo distinguishes now shallow water (itopo=1) orography function
!!    from hydro_atmos orography function (itopo=2)
!! Modification by Jochen Foerstner, DWD, (2008-07-16)
!!  - new fields in the derived type for the edges:
!!    grid_edges%primal_cart_normal (Cartesian normal to edge),
!!    grid_edges%quad_idx, grid_edges%quad_area and grid_edges%quad_orientation
!!    (indices of edges and area of the quadrilateral formed by two adjacent cells)
!!    up to now these new fields are initialized in the new routines
!!    calculate_primal_cart_normal and init_quad_twoadjcells
!!    rather than read from a grid/patch file.
!! Modification by Almut Gassmann, MPI-M, (2008-09-21)
!!  - remove reference to mask and height files, they are never used
!!  - use global_cell_type to distinguish cells as triangles or hexagons
!! Modification by Almut Gassmann, MPI-M (2008-10-30)
!!  - add subroutine init_coriolis to initialize Coriolis parameter
!! Modification by Stephan Lorenz, MPI-M (2010-02-18)
!!  - add subroutine init_ocean_patch to initialize ocean patch extensions
!! Modification by Daniel Reinert, DWD (2010-07-21)
!! - removed call of init_topography. This will be handeled within init_ext_data
!!
!! @par Copyright
!! 2002-2007 by DWD and MPI-M
!! This software is provided for non-commercial use only.
!! See the LICENSE and the WARRANTY conditions.
!!
!! @par License
!! The use of ICON is hereby granted free of charge for an unlimited time,
!! provided the following rules are accepted and applied:
!! <ol>
!! <li> You may use or modify this code for your own non commercial and non
!!    violent purposes.
!! <li> The code may not be re-distributed without the consent of the authors.
!! <li> The copyright notice and statement of authorship must appear in all
!!    copies.
!! <li> You accept the warranty conditions (see WARRANTY).
!! <li> In case you intend to use the code commercially, we oblige you to sign
!!    an according license agreement with DWD and MPI-M.
!! </ol>
!!
!! @par Warranty
!! This code has been tested up to a certain level. Defects and weaknesses,
!! which may be included in the code, do not establish any warranties by the
!! authors.
!! The authors do not make any warranty, express or implied, or assume any
!! liability or responsibility for the use, acquisition or application of this
!! software.
!!
!!
MODULE mo_model_domimp_patches
!-------------------------------------------------------------------------
!
!    ProTeX FORTRAN source: Style 2
!    modified for ICON project, DWD/MPI-M 2006
!
!-------------------------------------------------------------------------
!
!
!

USE mo_kind,               ONLY: wp
USE mo_io_units,           ONLY: filename_max
USE mo_impl_constants,     ONLY: SUCCESS, &
     &                           MAX_CHAR_LENGTH,  &
     &                           min_rlcell, max_rlcell, &
     &                           min_rledge, max_rledge, &
     &                           min_rlvert, max_rlvert
USE mo_exception,          ONLY: message_text, message, finish
USE mo_model_domain,       ONLY: t_patch
USE mo_parallel_configuration,  ONLY: nproma
USE mo_run_nml,            ONLY: locean
USE mo_model_domimp_setup, ONLY: reshape_int, reshape_real, calculate_cart_normal,&
     &                           init_quad_twoadjcells, init_coriolis
USE mo_grid_configuration, ONLY: start_lev, nroot, n_dom, n_dom_start,    &
     &                           lfeedback, l_limited_area, max_childdom, &
     & dynamics_grid_filename,  dynamics_parent_grid_id,  &
     & radiation_grid_filename, dynamics_radiation_grid_link,   &
     & no_of_dynamics_grids, no_of_radiation_grids,          &
     & global_cell_type, lplane
!DR USE mo_model_domimp_topo,  ONLY: init_topography
USE mo_ocean_topo,         ONLY: init_ocean_patch

USE mo_dynamics_config,    ONLY: dynamics_config

#ifndef NOMPI
! The USE statement below lets this module use the routines from
! mo_read_netcdf_parallel where only 1 processor is reading
! and broadcasting the results

USE mo_read_netcdf_parallel, ONLY:                &
   NF_NOWRITE, NF_GLOBAL, NF_NOERR, nf_strerror,  &
   nf_open            => p_nf_open,               &
   nf_close           => p_nf_close,              &
   nf_inq_dimid       => p_nf_inq_dimid,          &
   nf_inq_dimlen      => p_nf_inq_dimlen,         &
   nf_inq_varid       => p_nf_inq_varid,          &
   nf_get_att_int     => p_nf_get_att_int,        &
   nf_get_var_int     => p_nf_get_var_int,        &
   nf_get_var_double  => p_nf_get_var_double
#endif

IMPLICIT NONE

PRIVATE

#ifdef NOMPI
INCLUDE 'netcdf.inc'
#endif

CHARACTER(len=*), PARAMETER :: version = '$Id$'

!modules interface-------------------------------------------
!subroutines
PUBLIC :: import_patches
PUBLIC :: destruct_patches
PUBLIC :: allocate_patch
PUBLIC :: set_patches_grid_filename
PUBLIC :: get_patch_global_indexes
!-------------------------------------------------------------------------

CONTAINS

!-------------------------------------------------------------------------
SUBROUTINE get_patch_global_indexes(patch_no, entity_type, no_of_entities, global_indexes)
  USE mo_atmo_control, ONLY: p_patch
  USE mo_impl_constants, ONLY: CELLS, EDGES, VERTS

  INTEGER, INTENT(in) :: patch_no, entity_type
  INTEGER, INTENT(out) :: no_of_entities
  INTEGER, POINTER :: global_indexes(:)  ! this is intent out, but nec does not allows it

  INTEGER :: idx, return_status
  
  CHARACTER(len=*), PARAMETER :: method_name='get_patch_global_indexes'
  
  SELECT CASE(entity_type)

  CASE(CELLS)
    no_of_entities = p_patch(patch_no)%n_patch_cells
    ALLOCATE( global_indexes(no_of_entities), STAT=return_status )
    IF (return_status /= SUCCESS) THEN
      CALL finish (method_name,'allocation for global_indexes failed')
    ENDIF
    DO idx = 1, no_of_entities
      global_indexes(idx) = p_patch(patch_no)%cells%glb_index(idx)
      ! do some checking
      IF (global_indexes(idx) <= 0) &
        CALL finish (method_name,'glb_index(idx) <= 0')
      IF (global_indexes(idx) > p_patch(patch_no)%n_patch_cells_g) &
        CALL finish (method_name,'glb_index(idx) > n_patch_cells_g')
   ENDDO
      
  CASE(EDGES)
    no_of_entities = p_patch(patch_no)%n_patch_edges
    ALLOCATE( global_indexes(no_of_entities), STAT=return_status )
    IF (return_status /= SUCCESS) THEN
      CALL finish (method_name,'allocation for global_indexes failed')
    ENDIF
    DO idx = 1, no_of_entities
      global_indexes(idx) = p_patch(patch_no)%edges%glb_index(idx)
      ! do some checking
      IF (global_indexes(idx) <= 0) &
        CALL finish (method_name,'glb_index(idx) <= 0')
      IF (global_indexes(idx) > p_patch(patch_no)%n_patch_edges_g) &
        CALL finish (method_name,'glb_index(idx) > n_patch_edges_g')
    ENDDO

  CASE(VERTS)
    no_of_entities = p_patch(patch_no)%n_patch_verts
    ALLOCATE( global_indexes(no_of_entities), STAT=return_status )
    IF (return_status /= SUCCESS) THEN
      CALL finish (method_name,'allocation for global_indexes failed')
    ENDIF
    DO idx = 1, no_of_entities
      global_indexes(idx) = p_patch(patch_no)%verts%glb_index(idx)
      ! do some checking
      IF (global_indexes(idx) <= 0) &
        CALL finish (method_name,'glb_index(idx) <= 0')
      IF (global_indexes(idx) > p_patch(patch_no)%n_patch_verts_g) &
        CALL finish (method_name,'glb_index(idx) > n_patch_verts_g')
    ENDDO

  CASE DEFAULT
    CALL finish(method_name, 'entity_type not recognized')
  END SELECT
  
END SUBROUTINE get_patch_global_indexes
!-------------------------------------------------------------------------

!-------------------------------------------------------------------------
SUBROUTINE set_patches_grid_filename( p_patch )

  TYPE(t_patch), TARGET, INTENT(inout) :: p_patch(n_dom_start:)

  INTEGER :: jg

  !-----------------------------------------------------------------------
  DO jg = n_dom_start, n_dom

    IF (jg==0) THEN
      p_patch(jg)%grid_filename = radiation_grid_filename(1)
    ELSE
      p_patch(jg)%grid_filename = dynamics_grid_filename(jg)
    ENDIF
!     write(0,*) jg, "grid_filename:",TRIM(p_patch(jg)%grid_filename)
  ENDDO

END SUBROUTINE set_patches_grid_filename
!-------------------------------------------------------------------------


!-------------------------------------------------------------------------
!>
!!               This subroutine provides patch information to the model.
!!
!! Which data are required by the model is described in module
!! <i>mo_model_domain</i>. The components of the p_patch are initialized
!! with data stored in several patch files.
!!
!! @par Revision History
!! Developed  by  Peter Korn, MPI-M (2005).
!! @par
!! Modified by L. Bonaventura, MPI-M (2005),
!! to match completed patch
!! structure in advanced patch generator.
!! Modified by A. Gassmann, MPI-M (2007)
!! - cleaning up the code
!! Modified by A. Gassmann, MPI-M (2007-04)
!! - grid information belongs now to the patch type
!! Modified by Almut Gassmann, MPI-M (2008-09-21)
!! - min_dual_edge_length no longer needed for new Diffusion
!! Modified by Almut Gassmann, MPI-M (2008-10-30)
!! - new subroutine for Coriolis initialization
!! Modification by Stephan Lorenz, MPI-M (2010-02-06)
!!  - new subroutine for initialization of ocean patch
!!
SUBROUTINE import_patches( p_patch, nlev,nlevp1,num_lev,num_levp1,nshift )

INTEGER,INTENT(IN) :: nlev, nlevp1
INTEGER,INTENT(IN) :: num_lev(:), num_levp1(:), nshift(:)
TYPE(t_patch), TARGET, INTENT(inout) :: p_patch(n_dom_start:)

INTEGER :: jg, jg1, jlev, n_chd

LOGICAL :: l_exist

CHARACTER(filename_max) :: patch_file, gridtype

TYPE(t_patch), POINTER ::  &
  &  p_single_patch => NULL()

!-----------------------------------------------------------------------

CALL message ('mo_model_domimp_patches:import_patches', &
  'start to import patches')

! Set some basic flow control variables on the patch

max_childdom = 0

IF(n_dom_start==0) THEN
  ! The physics parent (parent of the root patch) should also be read
  p_patch(0)%id = 0
  p_patch(0)%level = start_lev-1
  p_patch(0)%parent_id = -1
  p_patch(0)%parent_child_index = 0
  p_patch(0)%n_childdom = 1
  p_patch(0)%child_id(1) = 1

  p_patch(1)%parent_child_index = 1
ELSE
  p_patch(1)%parent_child_index = 0
ENDIF

DO jg = 1, n_dom

  p_patch(jg)%id = jg

  IF (jg == 1) THEN
    p_patch(jg)%level = start_lev
    p_patch(jg)%parent_id = 0
  ELSE
    ! Note: the first element of parent_id refers to jg=2
    p_patch(jg)%level = p_patch(dynamics_parent_grid_id(jg))%level + 1
!     p_patch(jg)%parent_id = parent_id(jg-1)
    p_patch(jg)%parent_id = dynamics_parent_grid_id(jg)
  ENDIF

  n_chd = 0

  DO jg1 = jg+1, n_dom
    IF (jg == dynamics_parent_grid_id(jg1)) THEN
      n_chd = n_chd + 1
      p_patch(jg)%child_id(n_chd) = jg1
      p_patch(jg1)%parent_child_index = n_chd
    ENDIF
  ENDDO

  p_patch(jg)%n_childdom = n_chd
  max_childdom = MAX(1,max_childdom,n_chd)

  ! 
  ! store information about vertical levels
  !
  p_patch(jg)%nlev   = num_lev(jg)
  p_patch(jg)%nlevp1 = num_levp1(jg)

  IF (jg > 1) THEN
    IF (nshift(jg) > 0 ) THEN 
      ! nshift has been modified via Namelist => use it
      p_patch(jg)%nshift = nshift(jg)
    ELSE 
      ! set default value, assuming 
      !- superimposed vertical levels
      !- 1 nested domain per grid level
      p_patch(jg)%nshift = num_lev(p_patch(jg)%parent_id) - num_lev(jg)
    ENDIF
  ELSE
    ! Note: the first nshift-value refers to the global domain
    p_patch(jg)%nshift = 0
  ENDIF

ENDDO

DO jg = 1, n_dom

  ! make nshift parameter also available for the parent patch
  IF (p_patch(jg)%n_childdom >= 1) THEN
    p_patch(jg)%nshift_child = p_patch(p_patch(jg)%child_id(1))%nshift
    DO jg1 = 1, p_patch(jg)%n_childdom
      IF (p_patch(p_patch(jg)%child_id(jg1))%nshift /= p_patch(jg)%nshift_child) &
        CALL finish ('mo_model_domimp_patches:import_patches', &
                     'multiple nests at the same level must have the same nshift')
    ENDDO
  ELSE
    p_patch(jg)%nshift_child = 0
  ENDIF

ENDDO

IF (n_dom_start == 0) THEN ! reduced grid for radiation
  ! In case of n_dom_start == 0 nlev, nlevp1, nshift need to be copied from 
  ! jg=1 to jg=0
  p_patch(0)%nlev   = p_patch(1)%nlev
  p_patch(0)%nlevp1 = p_patch(1)%nlevp1
  p_patch(0)%nshift = p_patch(1)%nshift
  ! The reduced grid always has the same levels as the global one
  p_patch(0)%nshift_child = 0
ENDIF

p_patch(n_dom_start:n_dom)%max_childdom =  max_childdom


!init patch by reading data from file
!required: path to patch directory and file names, see top of module
! l_exist = .FALSE.

! IF (lplane) THEN
!   gridtype='plan'
! ELSE
!   gridtype='icon'
! END IF


CALL set_patches_grid_filename(p_patch)

GRID_LEVEL_LOOP: DO jg = n_dom_start, n_dom

!   jlev = p_patch(jg)%level

  ! Allow file names without "DOM" specifier if n_dom=1.
!   IF (n_dom == 1) THEN
!     ! Check if file name without "DOM" specifier exists.
!     WRITE (patch_file,'(a,a,i0,a,i2.2,a)') &
!          & TRIM(gridtype),'R',nroot,'B',jlev,'-grid.nc'
!     INQUIRE (FILE=patch_file, EXIST=l_exist)
!     ! Otherwise use file name with "DOM" specifier
!     IF (.NOT. l_exist)                                            &
!          & WRITE (patch_file,'(a,a,i0,2(a,i2.2),a)')              &
!          & TRIM(gridtype),'R',nroot,'B',jlev,'_DOM',jg,'-grid.nc'
!   ELSE
!     ! n_dom >1 --> "'_DOM',jg" required in file name
!     WRITE (patch_file,'(a,a,i0,2(a,i2.2),a)') &
!          & TRIM(gridtype),'R',nroot,'B',jlev,'_DOM',jg,'-grid.nc'
!   ENDIF


  p_single_patch => p_patch(jg)

  CALL read_patch( jg, p_single_patch )

  ! calculate Cartesian components of primal normal
  ! (later these should be provided by the grid generator)
  CALL calculate_cart_normal( dynamics_config(jg)%lcoriolis, p_single_patch )

  ! Initialize the data for the quadrilateral cells
  ! formed by the two adjacent cells of an edge.
  ! (later this should be provided by the grid generator)
  CALL init_quad_twoadjcells( p_single_patch )

  CALL init_coriolis( dynamics_config(jg)%lcoriolis, &
                      lplane, p_single_patch )


  IF (locean) THEN

    ! #slo# old ocean init routines - not used any more
    ! CALL mark_lateral_boundary_edges( p_single_patch )
    ! CALL init_ocean_patch_component( p_single_patch )

    ! #slo# new ocean init routine
    CALL init_ocean_patch( p_single_patch )

  END IF

ENDDO GRID_LEVEL_LOOP


END SUBROUTINE import_patches
!-------------------------------------------------------------------------
!
!> Allocates all arrays in a patch
!!
!! @par Revision History
!! Initial version (split out from read_patch) Rainer Johanni, Oct. 2010
!!
SUBROUTINE allocate_patch(p_patch)

  TYPE(t_patch), INTENT(INOUT) :: p_patch

  INTEGER :: max_childdom

  ! Please note: The following variables in the patch MUST already be set:
  ! - nblks_c
  ! - nblks_e
  ! - nblks_v
  ! - n_patch_cells
  ! - n_patch_edges
  ! - n_patch_verts
  ! - n_patch_cells_g
  ! - n_patch_edges_g
  ! - n_patch_verts_g
  ! - max_childdom

  p_patch%cell_type = global_cell_type
  max_childdom = p_patch%max_childdom

  !
  ! !grid cells
  !
  ALLOCATE( p_patch%cells%idx(nproma,p_patch%nblks_c) )
  ALLOCATE( p_patch%cells%blk(nproma,p_patch%nblks_c) )
  ALLOCATE( p_patch%cells%num_edges(nproma,p_patch%nblks_c) )
  ALLOCATE( p_patch%cells%parent_idx(nproma,p_patch%nblks_c) )
  ALLOCATE( p_patch%cells%parent_blk(nproma,p_patch%nblks_c) )
  ALLOCATE( p_patch%cells%child_idx(nproma,p_patch%nblks_c,4) )
  ALLOCATE( p_patch%cells%child_blk(nproma,p_patch%nblks_c,4) )
  ALLOCATE( p_patch%cells%child_id(nproma,p_patch%nblks_c) )
  ALLOCATE( p_patch%cells%phys_id(nproma,p_patch%nblks_c) )
  ALLOCATE( p_patch%cells%neighbor_idx(nproma,p_patch%nblks_c,p_patch%cell_type) )
  ALLOCATE( p_patch%cells%neighbor_blk(nproma,p_patch%nblks_c,p_patch%cell_type) )
  ALLOCATE( p_patch%cells%edge_idx(nproma,p_patch%nblks_c,p_patch%cell_type) )
  ALLOCATE( p_patch%cells%edge_blk(nproma,p_patch%nblks_c,p_patch%cell_type) )
  ALLOCATE( p_patch%cells%vertex_idx(nproma,p_patch%nblks_c,p_patch%cell_type) )
  ALLOCATE( p_patch%cells%vertex_blk(nproma,p_patch%nblks_c,p_patch%cell_type) )
  ALLOCATE( p_patch%cells%edge_orientation(nproma,p_patch%nblks_c,p_patch%cell_type) )
  ALLOCATE( p_patch%cells%center(nproma,p_patch%nblks_c) )
  ALLOCATE( p_patch%cells%area(nproma,p_patch%nblks_c) )
  ALLOCATE( p_patch%cells%f_c(nproma,p_patch%nblks_c) )
  ALLOCATE( p_patch%cells%refin_ctrl(nproma,p_patch%nblks_c) )
  ALLOCATE( p_patch%cells%start_idx(min_rlcell:max_rlcell,max_childdom) )
  ALLOCATE( p_patch%cells%end_idx(min_rlcell:max_rlcell,max_childdom) )
  ALLOCATE( p_patch%cells%start_blk(min_rlcell:max_rlcell,max_childdom) )
  ALLOCATE( p_patch%cells%end_blk(min_rlcell:max_rlcell,max_childdom) )

  ALLOCATE( p_patch%cells%decomp_domain(nproma,p_patch%nblks_c) )
  ALLOCATE( p_patch%cells%owner_mask(nproma,p_patch%nblks_c) )
  ALLOCATE( p_patch%cells%glb_index(p_patch%n_patch_cells) )
  ALLOCATE( p_patch%cells%loc_index(p_patch%n_patch_cells_g) )
  ALLOCATE( p_patch%cells%owner_g(p_patch%n_patch_cells_g))

  !
  ! !grid edges
  !
  ALLOCATE( p_patch%edges%idx(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%blk(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%parent_idx(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%parent_blk(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%child_idx(nproma,p_patch%nblks_e,4) )
  ALLOCATE( p_patch%edges%child_blk(nproma,p_patch%nblks_e,4) )
  ALLOCATE( p_patch%edges%child_id(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%phys_id(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%cell_idx(nproma,p_patch%nblks_e,2) )
  ALLOCATE( p_patch%edges%cell_blk(nproma,p_patch%nblks_e,2) )
  ALLOCATE( p_patch%edges%vertex_idx(nproma,p_patch%nblks_e,4) )
  ALLOCATE( p_patch%edges%vertex_blk(nproma,p_patch%nblks_e,4) )
  ALLOCATE( p_patch%edges%system_orientation(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%quad_idx(nproma,p_patch%nblks_e,4) )
  ALLOCATE( p_patch%edges%quad_blk(nproma,p_patch%nblks_e,4) )
  ALLOCATE( p_patch%edges%quad_orientation(nproma,p_patch%nblks_e,4) )
  ALLOCATE( p_patch%edges%center(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%primal_normal(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%primal_cart_normal(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%dual_normal(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%dual_cart_normal(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%primal_normal_cell(nproma,p_patch%nblks_e,2) )
  ALLOCATE( p_patch%edges%dual_normal_cell(nproma,p_patch%nblks_e,2) )
  ALLOCATE( p_patch%edges%primal_normal_vert(nproma,p_patch%nblks_e,4) )
  ALLOCATE( p_patch%edges%dual_normal_vert(nproma,p_patch%nblks_e,4) )
  ALLOCATE( p_patch%edges%primal_edge_length(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%inv_primal_edge_length(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%dual_edge_length(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%inv_dual_edge_length(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%edge_vert_length(nproma,p_patch%nblks_e,2) )
  ALLOCATE( p_patch%edges%inv_vert_vert_length(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%edge_cell_length(nproma,p_patch%nblks_e,2) )
  ALLOCATE( p_patch%edges%area_edge(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%quad_area(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%f_e(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%refin_ctrl(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%start_idx(min_rledge:max_rledge,max_childdom) )
  ALLOCATE( p_patch%edges%end_idx(min_rledge:max_rledge,max_childdom) )
  ALLOCATE( p_patch%edges%start_blk(min_rledge:max_rledge,max_childdom) )
  ALLOCATE( p_patch%edges%end_blk(min_rledge:max_rledge,max_childdom) )

  ALLOCATE( p_patch%edges%decomp_domain(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%owner_mask(nproma,p_patch%nblks_e) )
  ALLOCATE( p_patch%edges%glb_index(p_patch%n_patch_edges) )
  ALLOCATE( p_patch%edges%loc_index(p_patch%n_patch_edges_g) )
  ALLOCATE( p_patch%edges%owner_g(p_patch%n_patch_edges_g))

  !
  ! !grid verts
  !
  ALLOCATE( p_patch%verts%idx(nproma,p_patch%nblks_v) )
  ALLOCATE( p_patch%verts%blk(nproma,p_patch%nblks_v) )
  ALLOCATE( p_patch%verts%neighbor_idx(nproma,p_patch%nblks_v,9-p_patch%cell_type) )
  ALLOCATE( p_patch%verts%neighbor_blk(nproma,p_patch%nblks_v,9-p_patch%cell_type) )
  ALLOCATE( p_patch%verts%cell_idx(nproma,p_patch%nblks_v,9-p_patch%cell_type) )
  ALLOCATE( p_patch%verts%cell_blk(nproma,p_patch%nblks_v,9-p_patch%cell_type) )
  ALLOCATE( p_patch%verts%edge_idx(nproma,p_patch%nblks_v,9-p_patch%cell_type) )
  ALLOCATE( p_patch%verts%edge_blk(nproma,p_patch%nblks_v,9-p_patch%cell_type) )
  ALLOCATE( p_patch%verts%edge_orientation(nproma,p_patch%nblks_v,9-p_patch%cell_type) )
  ALLOCATE( p_patch%verts%num_edges(nproma,p_patch%nblks_v) )
  ALLOCATE( p_patch%verts%vertex(nproma,p_patch%nblks_v) )
  ALLOCATE( p_patch%verts%dual_area(nproma,p_patch%nblks_v) )
  ALLOCATE( p_patch%verts%f_v(nproma,p_patch%nblks_v) )
  ALLOCATE( p_patch%verts%refin_ctrl(nproma,p_patch%nblks_v) )
  ALLOCATE( p_patch%verts%start_idx(min_rlvert:max_rlvert,max_childdom) )
  ALLOCATE( p_patch%verts%end_idx(min_rlvert:max_rlvert,max_childdom) )
  ALLOCATE( p_patch%verts%start_blk(min_rlvert:max_rlvert,max_childdom) )
  ALLOCATE( p_patch%verts%end_blk(min_rlvert:max_rlvert,max_childdom) )

  ALLOCATE( p_patch%verts%decomp_domain(nproma,p_patch%nblks_v) )
  ALLOCATE( p_patch%verts%owner_mask(nproma,p_patch%nblks_v) )
  ALLOCATE( p_patch%verts%glb_index(p_patch%n_patch_verts) )
  ALLOCATE( p_patch%verts%loc_index(p_patch%n_patch_verts_g) )
  ALLOCATE( p_patch%verts%owner_g(p_patch%n_patch_verts_g))

END SUBROUTINE allocate_patch

!-------------------------------------------------------------------------
!
!

!>
!!               Initialization of the patch components with data stored.
!!
!!               Initialization of the patch components with data stored
!! in files.
!!
!! @par Revision History
!! Developed  by  Peter Korn, MPI-M (2005).
!! Modified by L. Bonaventura, MPI-M (2005),
!! to match completed patch
!! structure in advanced patch generator.
!! Modified by A. Gassmann, MPI-M (2007-04-03)
!! - cleaning up and adaptations for reading multiple patches
!! Modified by A. Gassmann, MPI-M (2007-04-03)
!! - patch owns grid information, global grid is obsolete.
!! - changed name from init_patch to read_patch
!! Modified by A. Gassmann, MPI-M (2008-09-21)
!! - remove all not netcdf stuff
!! - HERE we must think of how to use different 'global_cell_type's
!! Modified by A. Gassmann, MPI-M (2008-10-30)
!! - read in grid for either triangles or hexagons
!!
SUBROUTINE read_patch( ig, p_patch, patch_file )


INTEGER,             INTENT(in)    ::  ig           ! domain ID
CHARACTER(len=*),    INTENT(in), OPTIONAL  ::  patch_file   ! name of grid file

TYPE(t_patch), TARGET, INTENT(inout) ::  p_patch      ! patch data structure

INTEGER, ALLOCATABLE :: &
  &  array_c_int(:,:),  &  ! temporary arrays to read in integer values
  &  array_e_int(:,:),  &
  &  array_v_int(:,:)

REAL(wp), ALLOCATABLE :: &
  &  array_c_real(:,:), &  ! temporary arrays to read in real values
  &  array_e_real(:,:), &
  &  array_v_real(:,:)

INTEGER, ALLOCATABLE :: &
  &  array_c_indlist(:,:),  &  ! temporary arrays to read in index lists
  &  array_e_indlist(:,:),  &
  &  array_v_indlist(:,:)

! dummy values for number of internal halo cells, edges, vertices
INTEGER :: n_e_halo_cells
INTEGER :: n_e_halo_edges
INTEGER :: n_e_halo_verts

! INTEGER :: patch_unit

! LOGICAL :: lnetcdf = .TRUE.
! CHARACTER(len=filename_max) :: file

! status variable
INTEGER :: ist

INTEGER :: ncid, dimid, varid
INTEGER :: ji
INTEGER :: jv, jc, je, jvc, jcv, jve, jce, ilv, ibv, ilc, ibc
INTEGER :: icheck, ilev, igrid_level, igrid_id, iparent_id, i_max_childdom, ipar_id

!-----------------------------------------------------------------------

! set dummy values to zero
n_e_halo_cells = 0
n_e_halo_edges = 0
n_e_halo_verts = 0

ilev = p_patch%level
ipar_id = p_patch%parent_id

!
! start to fill patch type
!
IF (PRESENT(patch_file)) THEN
  p_patch%grid_filename=patch_file
ENDIF

! this should be read into
!  at the moment is filled in the patch allocation
! p_patch%cell_type = global_cell_type
  
CALL message ('mo_model_domimp_patches:read_patch', 'start to init patch')

WRITE(message_text,'(a,a)') 'Read gridmap file ', TRIM(p_patch%grid_filename)
CALL message ('', TRIM(message_text))

CALL nf(nf_open(TRIM(p_patch%grid_filename), NF_NOWRITE, ncid))

CALL nf(nf_get_att_int(ncid, NF_GLOBAL, 'grid_root', icheck))
IF (icheck /= nroot) THEN
   WRITE(message_text,'(a)') &
     & '"grid_root" global attribute in grid file differs from the "R" parameter in the filename'
   CALL finish  ('mo_model_domain_import/read_patch', TRIM(message_text))
END IF

CALL nf(nf_get_att_int(ncid, NF_GLOBAL, 'grid_level', igrid_level))
IF (igrid_level /= ilev) THEN
   WRITE(message_text,'(a)') &
     & '"grid_level" global attribute in grid file differs from the "B" parameter in the filename'
   CALL finish  ('mo_model_domain_import/read_patch', TRIM(message_text))
END IF

! Check additional attributes for consistency with the current namelist settings
CALL nf(nf_get_att_int(ncid, NF_GLOBAL, 'grid_ID', igrid_id))
IF ((.NOT.l_limited_area).AND.(igrid_id /= ig)) THEN
   WRITE(message_text,'(a)') &
     & '"grid ID" global attribute in input file does not match the namelist setting'
   CALL finish  ('mo_model_domain_import/read_patch', TRIM(message_text))
END IF

CALL nf(nf_get_att_int(ncid, NF_GLOBAL, 'parent_grid_ID', iparent_id))
IF ((.NOT.l_limited_area).AND.(iparent_id /= ipar_id)) THEN
   WRITE(message_text,'(a)') &
     & '"parent grid ID" global attribute in input file does not match the namelist setting'
   CALL finish  ('mo_model_domain_import/read_patch', TRIM(message_text))
END IF

CALL nf(nf_get_att_int(ncid, NF_GLOBAL, 'max_childdom', i_max_childdom))
IF (i_max_childdom /= max_childdom) THEN
   WRITE(message_text,'(a)') &
     & '"max_childdom" of the namelist differs from that of the input file global attribute'
   CALL finish  ('mo_model_domain_import/read_patch', TRIM(message_text))
END IF

!
! get number of cells, edges and vertices
!
CALL nf(nf_inq_dimid(ncid, 'cell', dimid))
IF (global_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_inq_dimlen(ncid, dimid, p_patch%n_patch_cells))
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_inq_dimlen(ncid, dimid, p_patch%n_patch_verts))
ENDIF

CALL nf(nf_inq_dimid(ncid, 'edge', dimid))
CALL nf(nf_inq_dimlen(ncid, dimid, p_patch%n_patch_edges))

CALL nf(nf_inq_dimid(ncid, 'vertex', dimid))
IF (global_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_inq_dimlen(ncid, dimid, p_patch%n_patch_verts))
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_inq_dimlen(ncid, dimid, p_patch%n_patch_cells))
ENDIF

!
! calculate and save values for the blocking
!
! ... for the cells
p_patch%nblks_c       = ( p_patch%n_patch_cells + n_e_halo_cells - 1 )  &
  &                   / nproma + 1
p_patch%nblks_int_c   = ( p_patch%n_patch_cells - 1 ) / nproma + 1
p_patch%npromz_int_c  = p_patch%n_patch_cells  &
  &                   - (p_patch%nblks_int_c - 1)*nproma
! total number of cells
p_patch%n_patch_cells = p_patch%n_patch_cells + n_e_halo_cells
p_patch%npromz_c      = p_patch%n_patch_cells - (p_patch%nblks_c - 1)*nproma

! ... for the edges
p_patch%nblks_e       = ( p_patch%n_patch_edges + n_e_halo_edges - 1 )  &
  &                   / nproma + 1
p_patch%nblks_int_e   = ( p_patch%n_patch_edges - 1 ) / nproma + 1
p_patch%npromz_int_e  = p_patch%n_patch_edges  &
  &                   - (p_patch%nblks_int_e - 1)*nproma
! total number of edges
p_patch%n_patch_edges = p_patch%n_patch_edges + n_e_halo_edges
p_patch%npromz_e      = p_patch%n_patch_edges - (p_patch%nblks_e - 1)*nproma

! ... for the vertices
p_patch%nblks_v       = ( p_patch%n_patch_verts + n_e_halo_verts - 1 )  &
  &                   / nproma + 1
p_patch%nblks_int_v   = ( p_patch%n_patch_verts - 1 ) / nproma + 1
p_patch%npromz_int_v  = p_patch%n_patch_verts  &
  &                   - (p_patch%nblks_int_v - 1)*nproma
! total number of vertices
p_patch%n_patch_verts = p_patch%n_patch_verts + n_e_halo_verts
p_patch%npromz_v      = p_patch%n_patch_verts - (p_patch%nblks_v - 1)*nproma

!
! allocate temporary arrays to read in data form the grid/patch generator
!
! integer arrays
ALLOCATE( array_c_int(p_patch%n_patch_cells,6),  &
  &       array_e_int(p_patch%n_patch_edges,6),  &
  &       array_v_int(p_patch%n_patch_verts,6),  &
  &       STAT=ist )
IF (ist /= SUCCESS) THEN
  CALL finish ('mo_model_domain_import:read_patch',  &
    &             'allocation for array_[cev]_int failed')
ENDIF
! real arrays
ALLOCATE( array_c_real(p_patch%n_patch_cells,6),  &
  &       array_e_real(p_patch%n_patch_edges,6),  &
  &       array_v_real(p_patch%n_patch_verts,6),  &
  &       STAT=ist )
IF (ist /= SUCCESS) THEN
  CALL finish ('mo_model_domain_import:read_patch',  &
    &             'allocation for array_[cev]_real failed')
ENDIF
! integer arrays for index lists
ALLOCATE( array_c_indlist(min_rlcell:max_rlcell,max_childdom),  &
  &       array_e_indlist(min_rledge:max_rledge,max_childdom),  &
  &       array_v_indlist(min_rlvert:max_rlvert,max_childdom),  &
  &       STAT=ist )

IF (ist /= SUCCESS) THEN
  CALL finish ('mo_model_domain_import:read_patch',  &
    &          'allocation for array_[cev]_indlist failed')
ENDIF

! Number of global cells/edges/verts
! These are needed for patch allocation
! For a non-divided patch they are identical to the non-global values

p_patch%n_patch_cells_g = p_patch%n_patch_cells
p_patch%n_patch_edges_g = p_patch%n_patch_edges
p_patch%n_patch_verts_g = p_patch%n_patch_verts

!
! Allocate all patch arrays
!
CALL allocate_patch( p_patch )

! p_patch%cells%idx(:,:)
! p_patch%cells%blk(:,:)
CALL nf(nf_inq_varid(ncid, 'cell_index', varid))
IF (global_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1)))
   CALL reshape_idx( array_c_int(:,1), p_patch%nblks_c, p_patch%npromz_c,  &
     &               p_patch%cells%idx(:,:),  &
     &               p_patch%cells%blk(:,:) )
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_int(ncid, varid, array_v_int(:,1)))
   CALL reshape_idx( array_v_int(:,1), p_patch%nblks_v, p_patch%npromz_v,  &
     &               p_patch%verts%idx(:,:),  &
     &               p_patch%verts%blk(:,:) )
ENDIF

! p_patch%cells%parent_idx(:,:)
! p_patch%cells%parent_blk(:,:)
CALL nf(nf_inq_varid(ncid, 'parent_cell_index', varid))
IF (global_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1)))
   CALL reshape_idx( array_c_int(:,1), p_patch%nblks_c, p_patch%npromz_c,  &
     &               p_patch%cells%parent_idx(:,:),  &
     &               p_patch%cells%parent_blk(:,:) )
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   CALL message ('read_patch',&
                 'parent_cell_index incompatible with hexagonal grid')
ENDIF

! p_patch%cells%child_idx(:,:,:)
! p_patch%cells%child_blk(:,:,:)
CALL nf(nf_inq_varid(ncid, 'child_cell_index', varid))
IF (global_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1:4)))
   DO ji = 1, 4
      CALL reshape_idx( array_c_int(:,ji), p_patch%nblks_c, p_patch%npromz_c,  &
        &               p_patch%cells%child_idx(:,:,ji),  &
        &               p_patch%cells%child_blk(:,:,ji) )
   END DO
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   CALL message ('read_patch',&
                 'child_cell_index incompatible with hexagonal grid')
ENDIF

! p_patch%cells%child_id(:,:)
CALL nf(nf_inq_varid(ncid, 'child_cell_id', varid))
IF (global_cell_type == 3) THEN ! triangular grid
  CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1)))
  CALL reshape_int( array_c_int(:,1), p_patch%nblks_c, p_patch%npromz_c,  &
     &               p_patch%cells%child_id(:,:) )
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
  CALL message ('read_patch',&
                'child_cell_id incompatible with hexagonal grid')
ENDIF

! p_patch%cells%phys_id(:,:)
CALL nf(nf_inq_varid(ncid, 'phys_cell_id', varid))
IF (global_cell_type == 3) THEN ! triangular grid
  CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1)))
  CALL reshape_int( array_c_int(:,1), p_patch%nblks_c, p_patch%npromz_c,  &
     &               p_patch%cells%phys_id(:,:) )
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
  CALL message ('read_patch',&
                'phys_cell_id not udes for hexagonal grid')
ENDIF

! p_patch%cells%neighbor_idx(:,:,:)
! p_patch%cells%neighbor_blk(:,:,:)
CALL nf(nf_inq_varid(ncid, 'neighbor_cell_index', varid))
IF (global_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1:3)))
   DO ji = 1, 3
      CALL reshape_idx( array_c_int(:,ji), p_patch%nblks_c, p_patch%npromz_c,  &
        &               p_patch%cells%neighbor_idx(:,:,ji),  &
        &               p_patch%cells%neighbor_blk(:,:,ji) )
   END DO
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_int(ncid, varid, array_v_int(:,1:3)))
   DO ji = 1, 3
     CALL reshape_idx( array_v_int(:,ji), p_patch%nblks_v, p_patch%npromz_v,  &
       &               p_patch%verts%neighbor_idx(:,:,ji),  &
       &               p_patch%verts%neighbor_blk(:,:,ji) )
   END DO
ENDIF

! p_patch%cells%edge_idx(:,:,:)
! p_patch%cells%edge_blk(:,:,:)
CALL nf(nf_inq_varid(ncid, 'edge_of_cell', varid))
IF (global_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1:3)))
   DO ji = 1, 3
     CALL reshape_idx( array_c_int(:,ji), p_patch%nblks_c, p_patch%npromz_c,  &
       &               p_patch%cells%edge_idx(:,:,ji),  &
       &               p_patch%cells%edge_blk(:,:,ji) )
   END DO
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_int(ncid, varid, array_v_int(:,1:3)))
   DO ji = 1, 3
     CALL reshape_idx( array_v_int(:,ji), p_patch%nblks_v, p_patch%npromz_v,  &
       &               p_patch%verts%edge_idx(:,:,ji),  &
       &               p_patch%verts%edge_blk(:,:,ji) )
   END DO
ENDIF

! p_patch%cells%vertex_idx(:,:,:)
! p_patch%cells%vertex_blk(:,:,:)
CALL nf(nf_inq_varid(ncid, 'vertex_of_cell', varid))
IF (global_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1:3)))
   DO ji = 1, 3
     CALL reshape_idx( array_c_int(:,ji), p_patch%nblks_c, p_patch%npromz_c,  &
       &               p_patch%cells%vertex_idx(:,:,ji),  &
       &               p_patch%cells%vertex_blk(:,:,ji) )
   END DO
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_int(ncid, varid, array_v_int(:,1:3)))
   DO ji = 1, 3
     CALL reshape_idx( array_v_int(:,ji), p_patch%nblks_v, p_patch%npromz_v,  &
       &               p_patch%verts%cell_idx(:,:,ji),  &
       &               p_patch%verts%cell_blk(:,:,ji) )
   END DO
ENDIF

! p_patch%cells%edge_orientation(:,:,:)
CALL nf(nf_inq_varid(ncid, 'orientation_of_normal', varid))
IF (global_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1:3)))
   DO ji = 1, 3
     CALL reshape_real( REAL(array_c_int(:,ji),wp),            &
                      & p_patch%nblks_c, p_patch%npromz_c,     &
                      & p_patch%cells%edge_orientation(:,:,ji) )
   END DO
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_int(ncid, varid, array_v_int(:,1:3)))
   DO ji = 1, 3
     CALL reshape_real( REAL(array_v_int(:,ji),wp),            &
                      & p_patch%nblks_v, p_patch%npromz_v,     &
                      & p_patch%verts%edge_orientation(:,:,ji) )
   END DO
ENDIF

! p_patch%cells%center(:,:)%lon
CALL nf(nf_inq_varid(ncid, 'lon_cell_centre', varid))
IF (global_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_double(ncid, varid, array_c_real(:,1)))
   CALL reshape_real( array_c_real(:,1), p_patch%nblks_c, p_patch%npromz_c,  &
     &                p_patch%cells%center(:,:)%lon )
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_double(ncid, varid, array_v_real(:,1)))
   CALL reshape_real( array_v_real(:,1), p_patch%nblks_v, p_patch%npromz_v,  &
     &                p_patch%verts%vertex(:,:)%lon )
ENDIF

! p_patch%cells%center(:,:)%lat
CALL nf(nf_inq_varid(ncid, 'lat_cell_centre', varid))
IF (global_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_double(ncid, varid, array_c_real(:,1)))
   CALL reshape_real( array_c_real(:,1), p_patch%nblks_c, p_patch%npromz_c,  &
     &                p_patch%cells%center(:,:)%lat )
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_double(ncid, varid, array_v_real(:,1)))
   CALL reshape_real( array_v_real(:,1), p_patch%nblks_v, p_patch%npromz_v,  &
     &                p_patch%verts%vertex(:,:)%lat )
ENDIF

! p_patch%cells%area(:,:)
CALL nf(nf_inq_varid(ncid, 'cell_area_p', varid))
IF (global_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_double(ncid, varid, array_c_real(:,1)))
   CALL reshape_real( array_c_real(:,1), p_patch%nblks_c, p_patch%npromz_c,  &
     &                p_patch%cells%area(:,:) )
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_double(ncid, varid, array_v_real(:,1)))
   CALL reshape_real( array_v_real(:,1), p_patch%nblks_v, p_patch%npromz_v,  &
     &                p_patch%verts%dual_area(:,:) )
ENDIF

! p_patch%cells%refin_ctrl(:,:)
CALL nf(nf_inq_varid(ncid, 'refin_c_ctrl', varid))
IF (global_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1)))
   CALL reshape_int( array_c_int(:,1), p_patch%nblks_c, p_patch%npromz_c,  &
     &               p_patch%cells%refin_ctrl(:,:) )
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_int(ncid, varid, array_v_int(:,1)))
   CALL reshape_int( array_v_int(:,1), p_patch%nblks_v, p_patch%npromz_v,  &
     &               p_patch%verts%refin_ctrl(:,:) )
ENDIF

! p_patch%cells%start_idx(:,:)
! p_patch%cells%start_blk(:,:)
! p_patch%cells%end_idx(:,:)
! p_patch%cells%end_blk(:,:)

CALL nf(nf_inq_varid(ncid, 'start_idx_c', varid))
IF (global_cell_type == 3) THEN ! triangular grid
  CALL nf(nf_get_var_int(ncid, varid, array_c_indlist(:,:)))
  CALL reshape_idx_list( array_c_indlist,                                &
   &                    p_patch%cells%start_idx, p_patch%cells%start_blk )
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
  CALL nf(nf_get_var_int(ncid, varid, array_v_indlist(:,:)))
  CALL reshape_idx_list( array_v_indlist,                                &
   &                    p_patch%verts%start_idx, p_patch%verts%start_blk )
ENDIF
CALL nf(nf_inq_varid(ncid, 'end_idx_c', varid))
IF (global_cell_type == 3) THEN ! triangular grid
  CALL nf(nf_get_var_int(ncid, varid, array_c_indlist(:,:)))
  CALL reshape_idx_list( array_c_indlist,                                &
   &                    p_patch%cells%end_idx, p_patch%cells%end_blk )
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
  CALL nf(nf_get_var_int(ncid, varid, array_v_indlist(:,:)))
  CALL reshape_idx_list( array_v_indlist,                                &
   &                    p_patch%verts%end_idx, p_patch%verts%end_blk )
ENDIF

! p_patch%edges%idx(:,:)
! p_patch%edges%blk(:,:)
CALL nf(nf_inq_varid(ncid, 'edge_index', varid))
CALL nf(nf_get_var_int(ncid, varid, array_e_int(:,1)))
CALL reshape_idx( array_e_int(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
  &               p_patch%edges%idx(:,:),  &
  &               p_patch%edges%blk(:,:) )

! p_patch%edges%parent_idx(:,:)
! p_patch%edges%parent_blk(:,:)
CALL nf(nf_inq_varid(ncid, 'parent_edge_index', varid))
CALL nf(nf_get_var_int(ncid, varid, array_e_int(:,1)))
CALL reshape_idx( array_e_int(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
  &               p_patch%edges%parent_idx(:,:),  &
  &               p_patch%edges%parent_blk(:,:) )

! p_patch%edges%child_idx(:,:,:)
! p_patch%edges%child_blk(:,:,:)
CALL nf(nf_inq_varid(ncid, 'child_edge_index', varid))
CALL nf(nf_get_var_int(ncid, varid, array_e_int(:,1:4)))
DO ji = 1, 4
  CALL reshape_idx( array_e_int(:,ji), p_patch%nblks_e, p_patch%npromz_e,  &
    &               p_patch%edges%child_idx(:,:,ji),  &
    &               p_patch%edges%child_blk(:,:,ji) )
END DO

! p_patch%edges%child_id(:,:)
CALL nf(nf_inq_varid(ncid, 'child_edge_id', varid))
CALL nf(nf_get_var_int(ncid, varid, array_e_int(:,1)))
CALL reshape_int( array_e_int(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
     &            p_patch%edges%child_id(:,:) )

! p_patch%edges%phys_id(:,:)
CALL nf(nf_inq_varid(ncid, 'phys_edge_id', varid))
CALL nf(nf_get_var_int(ncid, varid, array_e_int(:,1)))
CALL reshape_int( array_e_int(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
     &            p_patch%edges%phys_id(:,:) )

! p_patch%edges%cell_idx(:,:,:)
! p_patch%edges%cell_blk(:,:,:)
CALL nf(nf_inq_varid(ncid, 'adjacent_cell_of_edge', varid))
CALL nf(nf_get_var_int(ncid, varid, array_e_int(:,1:2)))
IF (global_cell_type == 3) THEN ! triangular grid
  DO ji = 1, 2
    CALL reshape_idx( array_e_int(:,ji), p_patch%nblks_e, p_patch%npromz_e,  &
      &               p_patch%edges%cell_idx(:,:,ji),  &
      &               p_patch%edges%cell_blk(:,:,ji) )
  END DO
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
  DO ji = 1, 2
    CALL reshape_idx( array_e_int(:,ji), p_patch%nblks_e, p_patch%npromz_e,  &
      &               p_patch%edges%vertex_idx(:,:,ji),  &
      &               p_patch%edges%vertex_blk(:,:,ji) )
  END DO
ENDIF

! p_patch%edges%vertex_idx(:,:,:)
! p_patch%edges%vertex_blk(:,:,:)
CALL nf(nf_inq_varid(ncid, 'edge_vertices', varid))
CALL nf(nf_get_var_int(ncid, varid, array_e_int(:,1:2)))
IF (global_cell_type == 3) THEN ! triangular grid
  DO ji = 1, 2
    CALL reshape_idx( array_e_int(:,ji), p_patch%nblks_e, p_patch%npromz_e,  &
      &               p_patch%edges%vertex_idx(:,:,ji),  &
      &               p_patch%edges%vertex_blk(:,:,ji) )
  END DO
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
  DO ji = 1, 2
    CALL reshape_idx( array_e_int(:,ji), p_patch%nblks_e, p_patch%npromz_e,  &
      &               p_patch%edges%cell_idx(:,:,ji),  &
      &               p_patch%edges%cell_blk(:,:,ji) )
  END DO
ENDIF

! p_patch%edges%system_orientation(:,:)
CALL nf(nf_inq_varid(ncid, 'edge_system_orientation', varid))
CALL nf(nf_get_var_int(ncid, varid, array_e_int(:,1)))
CALL reshape_real( REAL(array_e_int(:,1),wp),            &
                 & p_patch%nblks_e, p_patch%npromz_e,    &
                 & p_patch%edges%system_orientation(:,:) )

! p_patch%edges%center(:,:)%lon
CALL nf(nf_inq_varid(ncid, 'lon_edge_centre', varid))
CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
CALL reshape_real( array_e_real(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
  &                p_patch%edges%center(:,:)%lon )

! p_patch%edges%center(:,:)%lat
CALL nf(nf_inq_varid(ncid, 'lat_edge_centre', varid))
CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
CALL reshape_real( array_e_real(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
  &                p_patch%edges%center(:,:)%lat )

! p_patch%edges%primal_normal(:,:)%v1
CALL nf(nf_inq_varid(ncid, 'zonal_normal_primal_edge', varid))
CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
IF (global_cell_type == 3) THEN ! triangular grid
   CALL reshape_real( array_e_real(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
     &                p_patch%edges%primal_normal(:,:)%v1 )
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   CALL reshape_real( array_e_real(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
     &                p_patch%edges%dual_normal(:,:)%v1 )
ENDIF

! p_patch%edges%primal_normal(:,:)%v2
CALL nf(nf_inq_varid(ncid, 'meridional_normal_primal_edge', varid))
CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
IF (global_cell_type == 3) THEN ! triangular grid
   CALL reshape_real( array_e_real(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
     &                p_patch%edges%primal_normal(:,:)%v2 )
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   CALL reshape_real( array_e_real(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
     &                p_patch%edges%dual_normal(:,:)%v2 )
ENDIF

! p_patch%edges%dual_normal(:,:)%v1
CALL nf(nf_inq_varid(ncid, 'zonal_normal_dual_edge', varid))
CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
IF (global_cell_type == 3) THEN ! triangular grid
   CALL reshape_real( array_e_real(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
     &                p_patch%edges%dual_normal(:,:)%v1 )
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   CALL reshape_real( array_e_real(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
     &                p_patch%edges%primal_normal(:,:)%v1 )
ENDIF

! p_patch%edges%dual_normal(:,:)%v2
CALL nf(nf_inq_varid(ncid, 'meridional_normal_dual_edge', varid))
CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
IF (global_cell_type == 3) THEN ! triangular grid
   CALL reshape_real( array_e_real(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
     &                p_patch%edges%dual_normal(:,:)%v2 )
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   CALL reshape_real( array_e_real(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
     &                p_patch%edges%primal_normal(:,:)%v2 )
ENDIF

! p_patch%edges%primal_edge_length(:,:)
CALL nf(nf_inq_varid(ncid, 'edge_length', varid))
CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
IF (global_cell_type == 3) THEN ! triangular grid
   CALL reshape_real( array_e_real(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
     &                p_patch%edges%primal_edge_length(:,:) )
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   CALL reshape_real( array_e_real(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
     &                p_patch%edges%dual_edge_length(:,:) )
ENDIF

! p_patch%edges%dual_edge_length(:,:)
CALL nf(nf_inq_varid(ncid, 'dual_edge_length', varid))
CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
IF (global_cell_type == 3) THEN ! triangular grid
   CALL reshape_real( array_e_real(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
     &                p_patch%edges%dual_edge_length(:,:) )
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   CALL reshape_real( array_e_real(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
     &                p_patch%edges%primal_edge_length(:,:) )
ENDIF

! p_patch%edges%edge_vert_length(:,:)
CALL nf(nf_inq_varid(ncid, 'edge_vert_distance', varid))
CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1:2)))
IF (global_cell_type == 3) THEN ! triangular grid
   DO ji = 1, 2
     CALL reshape_real( array_e_real(:,ji), p_patch%nblks_e, p_patch%npromz_e, &
       &                p_patch%edges%edge_vert_length(:,:,ji) )
   ENDDO
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   DO ji = 1, 2
     CALL reshape_real( array_e_real(:,ji), p_patch%nblks_e, p_patch%npromz_e, &
       &                p_patch%edges%edge_cell_length(:,:,ji) )
   ENDDO
ENDIF

! p_patch%edges%edge_cell_length(:,:)
CALL nf(nf_inq_varid(ncid, 'edge_cell_distance', varid))
CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1:2)))
IF (global_cell_type == 3) THEN ! triangular grid
   DO ji = 1, 2
     CALL reshape_real( array_e_real(:,ji), p_patch%nblks_e, p_patch%npromz_e, &
       &                p_patch%edges%edge_cell_length(:,:,ji) )
   ENDDO
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   DO ji = 1, 2
     CALL reshape_real( array_e_real(:,ji), p_patch%nblks_e, p_patch%npromz_e, &
       &                p_patch%edges%edge_vert_length(:,:,ji) )
   ENDDO
ENDIF

! p_patch%edges%refin_ctrl(:,:)
CALL nf(nf_inq_varid(ncid, 'refin_e_ctrl', varid))
CALL nf(nf_get_var_int(ncid, varid, array_e_int(:,1)))
CALL reshape_int( array_e_int(:,1), p_patch%nblks_e, p_patch%npromz_e,  &
  &               p_patch%edges%refin_ctrl(:,:) )

! p_patch%edges%start_idx(:,:)
! p_patch%edges%start_blk(:,:)
! p_patch%edges%end_idx(:,:)
! p_patch%edges%end_blk(:,:)
CALL nf(nf_inq_varid(ncid, 'start_idx_e', varid))
CALL nf(nf_get_var_int(ncid, varid, array_e_indlist(:,:)))
CALL reshape_idx_list( array_e_indlist,                                &
  &                    p_patch%edges%start_idx, p_patch%edges%start_blk )
CALL nf(nf_inq_varid(ncid, 'end_idx_e', varid))
CALL nf(nf_get_var_int(ncid, varid, array_e_indlist(:,:)))
CALL reshape_idx_list( array_e_indlist,                                &
  &                    p_patch%edges%end_idx, p_patch%edges%end_blk )

! p_patch%verts%idx(:,:)
! p_patch%verts%blk(:,:)
CALL nf(nf_inq_varid(ncid, 'vertex_index', varid))
IF (global_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_int(ncid, varid, array_v_int(:,1)))
   CALL reshape_idx( array_v_int(:,1), p_patch%nblks_v, p_patch%npromz_v,  &
     &               p_patch%verts%idx(:,:),  &
     &               p_patch%verts%blk(:,:) )
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1)))
   CALL reshape_idx( array_c_int(:,1), p_patch%nblks_c, p_patch%npromz_c,  &
     &               p_patch%cells%idx(:,:),  &
     &               p_patch%cells%blk(:,:) )
ENDIF

! p_patch%verts%neighbor_idx(:,:,:)
! p_patch%verts%neighbor_blk(:,:,:)
CALL nf(nf_inq_varid(ncid, 'vertices_of_vertex', varid))
IF (global_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_int(ncid, varid, array_v_int(:,1:6)))
   DO ji = 1, 6
     CALL reshape_idx( array_v_int(:,ji), p_patch%nblks_v, p_patch%npromz_v,  &
       &               p_patch%verts%neighbor_idx(:,:,ji),  &
       &               p_patch%verts%neighbor_blk(:,:,ji) )
   END DO
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1:6)))
   DO ji = 1, 6
     CALL reshape_idx( array_c_int(:,ji), p_patch%nblks_c, p_patch%npromz_c,  &
       &               p_patch%cells%neighbor_idx(:,:,ji),  &
       &               p_patch%cells%neighbor_blk(:,:,ji) )
   END DO
   !
   ! account for dummy edges arising in case of a pentagon
   !
   DO jc = 1, p_patch%n_patch_cells
     DO ji = 1, 6
       IF ( array_c_int(jc,ji) == 0 ) THEN
         ibc = ( jc - 1 ) / nproma + 1
         ilc = jc - ( ibc - 1 )*nproma
         IF ( ji /= 6 ) THEN
           p_patch%cells%neighbor_idx(ilc,ibc,ji) =  &
             &  p_patch%cells%neighbor_idx(ilc,ibc,6)
           p_patch%cells%neighbor_blk(ilc,ibc,ji) =  &
             &  p_patch%cells%neighbor_blk(ilc,ibc,6)
         END IF
         ! Fill dummy neighbor with an existing index to simplify do loops
         ! Note, however, that related multiplication factors must be zero
         p_patch%cells%neighbor_idx(ilc,ibc,6) = p_patch%cells%neighbor_idx(ilc,ibc,5)
         p_patch%cells%neighbor_blk(ilc,ibc,6) = p_patch%cells%neighbor_blk(ilc,ibc,5)
       END IF
     END DO
   END DO
ENDIF

! p_patch%verts%cell_idx(:,:,:)
! p_patch%verts%cell_blk(:,:,:)
CALL nf(nf_inq_varid(ncid, 'cells_of_vertex', varid))
IF (global_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_int(ncid, varid, array_v_int(:,1:6)))
   DO ji = 1, 6
     CALL reshape_idx( array_v_int(:,ji), p_patch%nblks_v, p_patch%npromz_v,  &
       &               p_patch%verts%cell_idx(:,:,ji),  &
       &               p_patch%verts%cell_blk(:,:,ji) )
   END DO
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1:6)))
   DO ji = 1, 6
     CALL reshape_idx( array_c_int(:,ji), p_patch%nblks_c, p_patch%npromz_c,  &
       &               p_patch%cells%vertex_idx(:,:,ji),  &
       &               p_patch%cells%vertex_blk(:,:,ji) )
   END DO
ENDIF

!
! account for dummy cells arising in case of a pentagon
!
IF (global_cell_type == 3) THEN ! triangular grid
  DO jv = 1, p_patch%n_patch_verts
    DO jvc = 1, 6
      IF ( array_v_int(jv,jvc) == 0 ) THEN
        ibv = ( jv - 1 ) / nproma + 1
        ilv = jv - ( ibv - 1 )*nproma
        IF ( jvc /= 6 ) THEN
          p_patch%verts%cell_idx(ilv,ibv,jvc) =  &
            &  p_patch%verts%cell_idx(ilv,ibv,6)
          p_patch%verts%cell_blk(ilv,ibv,jvc) =  &
            &  p_patch%verts%cell_blk(ilv,ibv,6)
        END IF
        ! Fill dummy edge with existing index to simplify do loops
        ! Note, however, that related multiplication factors must be zero
        p_patch%verts%cell_idx(ilv,ibv,6) = p_patch%verts%cell_idx(ilv,ibv,5)
        p_patch%verts%cell_blk(ilv,ibv,6) = p_patch%verts%cell_blk(ilv,ibv,5)
      END IF
    END DO
  END DO
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
  DO jc = 1, p_patch%n_patch_cells
    DO jcv = 1, 6
      IF ( array_c_int(jc,jcv) == 0 ) THEN
        ibc = ( jc - 1 ) / nproma + 1
        ilc = jc - ( ibc - 1 )*nproma
        IF ( jcv /= 6 ) THEN
          p_patch%cells%vertex_idx(ilc,ibc,jcv) =  &
            &  p_patch%cells%vertex_idx(ilc,ibc,6)
          p_patch%cells%vertex_blk(ilc,ibc,jcv) =  &
            &  p_patch%cells%vertex_blk(ilc,ibc,6)
        END IF
        ! Fill dummy edge with existing index to simplify do loops
        ! Note, however, that related multiplication factors must be zero
        p_patch%cells%vertex_idx(ilc,ibc,6) = p_patch%cells%vertex_idx(ilc,ibc,5)
        p_patch%cells%vertex_blk(ilc,ibc,6) = p_patch%cells%vertex_blk(ilc,ibc,5)
      END IF
    END DO
  END DO
ENDIF

! p_patch%verts%edge_idx(:,:,:)
! p_patch%verts%edge_blk(:,:,:)
CALL nf(nf_inq_varid(ncid, 'edges_of_vertex', varid))
IF (global_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_int(ncid, varid, array_v_int(:,1:6)))
   DO ji = 1, 6
     CALL reshape_idx( array_v_int(:,ji), p_patch%nblks_v, p_patch%npromz_v,  &
       &               p_patch%verts%edge_idx(:,:,ji),  &
       &               p_patch%verts%edge_blk(:,:,ji) )
   END DO
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1:6)))
   DO ji = 1, 6
     CALL reshape_idx( array_c_int(:,ji), p_patch%nblks_c, p_patch%npromz_c,  &
       &               p_patch%cells%edge_idx(:,:,ji),  &
       &               p_patch%cells%edge_blk(:,:,ji) )
   END DO
ENDIF


!
! initialize verts%num_edges to 6
!
IF (global_cell_type == 3) THEN ! triangular grid
   p_patch%cells%num_edges(:,:) = 3
   p_patch%verts%num_edges(:,:) = 6
   !
   ! account for dummy edges arising in case of a pentagon
   ! JF:  useful to provide verts%num_edges via grid/patch generator?!
   !
   DO jv = 1, p_patch%n_patch_verts
     DO jve = 1, 6
       IF ( array_v_int(jv,jve) == 0 ) THEN
         ibv = ( jv - 1 ) / nproma + 1
         ilv = jv - ( ibv - 1 )*nproma
         IF ( jve /= 6 ) THEN
           p_patch%verts%edge_idx(ilv,ibv,jve) =  &
             &  p_patch%verts%edge_idx(ilv,ibv,6)
           p_patch%verts%edge_blk(ilv,ibv,jve) =  &
             &  p_patch%verts%edge_blk(ilv,ibv,6)
         END IF
         ! Fill dummy edge with existing index to simplify do loops
         ! Note, however, that related multiplication factors must be zero
         p_patch%verts%edge_idx(ilv,ibv,6) = p_patch%verts%edge_idx(ilv,ibv,5)
         p_patch%verts%edge_blk(ilv,ibv,6) = p_patch%verts%edge_blk(ilv,ibv,5)
         ! set num_edges to 5
         p_patch%verts%num_edges(ilv,ibv) = 5
       END IF
     END DO
   END DO
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   p_patch%verts%num_edges(:,:) = 3
   p_patch%cells%num_edges(:,:) = 6
   !
   ! account for dummy edges arising in case of a pentagon
   !
   DO jc = 1, p_patch%n_patch_cells
     DO jce = 1, 6
       IF ( array_c_int(jc,jce) == 0 ) THEN
         ibc = ( jc - 1 ) / nproma + 1
         ilc = jc - ( ibc - 1 )*nproma
         IF ( jce /= 6 ) THEN
           p_patch%cells%edge_idx(ilc,ibc,jce) =  &
             &  p_patch%cells%edge_idx(ilc,ibc,6)
           p_patch%cells%edge_blk(ilc,ibc,jce) =  &
             &  p_patch%cells%edge_blk(ilc,ibc,6)
         END IF
         ! Fill dummy edge with existing index to simplify do loops
         ! Note, however, that related multiplication factors must be zero
         p_patch%cells%edge_idx(ilc,ibc,6) = p_patch%cells%edge_idx(ilc,ibc,5)
         p_patch%cells%edge_blk(ilc,ibc,6) = p_patch%cells%edge_blk(ilc,ibc,5)
         ! set num_edges to 5
         p_patch%cells%num_edges(ilc,ibc) = 5
       END IF
     END DO
   END DO
ENDIF

! p_patch%verts%edge_orientation(:,:,:)
CALL nf(nf_inq_varid(ncid, 'edge_orientation', varid))
IF (global_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_int(ncid, varid, array_v_int(:,1:6)))
   DO ji = 1, 6
     CALL reshape_real( REAL(array_v_int(:,ji),wp),            &
                      & p_patch%nblks_v, p_patch%npromz_v,     &
                      & p_patch%verts%edge_orientation(:,:,ji) )
   END DO
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1:6)))
   DO ji = 1, 6
     CALL reshape_real( REAL(array_c_int(:,ji),wp),            &
                      & p_patch%nblks_c, p_patch%npromz_c,     &
                      & p_patch%cells%edge_orientation(:,:,ji) )
   END DO
ENDIF

!
! set edge orientation of dummy edges to zero
!
IF (global_cell_type == 3) THEN ! triangular grid
   !
   DO jv = 1, p_patch%n_patch_verts
     DO jve = 1, 6
       IF ( array_v_int(jv,jve) == 0 ) THEN
         ibv = ( jv - 1 ) / nproma + 1
         ilv = jv - ( ibv - 1 )*nproma
         IF ( jve /= 6 ) THEN
           p_patch%verts%edge_orientation(ilv,ibv,jve) =  &
             &  p_patch%verts%edge_orientation(ilv,ibv,6)
         END IF
         p_patch%verts%edge_orientation(ilv,ibv,6) = 0._wp
       END IF
     END DO
   END DO
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   !
   DO jc = 1, p_patch%n_patch_cells
     DO jce = 1, 6
       IF ( array_c_int(jc,jce) == 0 ) THEN
         ibc = ( jc - 1 ) / nproma + 1
         ilc = jc - ( ibc - 1 )*nproma
         IF ( jce /= 6 ) THEN
           p_patch%cells%edge_orientation(ilc,ibc,jce) =  &
             &  p_patch%cells%edge_orientation(ilc,ibc,6)
         END IF
         p_patch%cells%edge_orientation(ilc,ibc,6) = 0._wp
       END IF
     END DO
   END DO
ENDIF

! p_patch%verts%vertex(:,:)%lon
CALL nf(nf_inq_varid(ncid, 'longitude_vertices', varid))
IF (global_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_double(ncid, varid, array_v_real(:,1)))
   CALL reshape_real( array_v_real(:,1), p_patch%nblks_v, p_patch%npromz_v,  &
     &                p_patch%verts%vertex(:,:)%lon )
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_double(ncid, varid, array_c_real(:,1)))
   CALL reshape_real( array_c_real(:,1), p_patch%nblks_c, p_patch%npromz_c,  &
     &                p_patch%cells%center(:,:)%lon )
ENDIF

! p_patch%verts%vertex(:,:)%lat
CALL nf(nf_inq_varid(ncid, 'latitude_vertices', varid))
IF (global_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_double(ncid, varid, array_v_real(:,1)))
   CALL reshape_real( array_v_real(:,1), p_patch%nblks_v, p_patch%npromz_v,  &
     &                p_patch%verts%vertex(:,:)%lat )
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_double(ncid, varid, array_c_real(:,1)))
   CALL reshape_real( array_c_real(:,1), p_patch%nblks_c, p_patch%npromz_c,  &
     &                p_patch%cells%center(:,:)%lat )
ENDIF

! p_patch%verts%dual_area(:,:)
CALL nf(nf_inq_varid(ncid, 'dual_area_p', varid))
IF (global_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_double(ncid, varid, array_v_real(:,1)))
   CALL reshape_real( array_v_real(:,1), p_patch%nblks_v, p_patch%npromz_v,  &
     &                p_patch%verts%dual_area(:,:) )
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_double(ncid, varid, array_c_real(:,1)))
   CALL reshape_real( array_c_real(:,1), p_patch%nblks_c, p_patch%npromz_c,  &
     &                p_patch%cells%area(:,:) )
ENDIF

! p_patch%verts%refin_ctrl(:,:)
CALL nf(nf_inq_varid(ncid, 'refin_v_ctrl', varid))
IF (global_cell_type == 3) THEN ! triangular grid
   CALL nf(nf_get_var_int(ncid, varid, array_v_int(:,1)))
   CALL reshape_int( array_v_int(:,1), p_patch%nblks_v, p_patch%npromz_v,  &
     &               p_patch%verts%refin_ctrl(:,:) )
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
   CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1)))
   CALL reshape_int( array_c_int(:,1), p_patch%nblks_c, p_patch%npromz_c,  &
     &               p_patch%cells%refin_ctrl(:,:) )
ENDIF
! p_patch%verts%start_idx(:,:)
! p_patch%verts%start_blk(:,:)
! p_patch%verts%end_idx(:,:)
! p_patch%verts%end_blk(:,:)
CALL nf(nf_inq_varid(ncid, 'start_idx_v', varid))
IF (global_cell_type == 3) THEN ! triangular grid
  CALL nf(nf_get_var_int(ncid, varid, array_v_indlist(:,:)))
  CALL reshape_idx_list( array_v_indlist,                                &
   &                    p_patch%verts%start_idx, p_patch%verts%start_blk )
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
  CALL nf(nf_get_var_int(ncid, varid, array_c_indlist(:,:)))
  CALL reshape_idx_list( array_c_indlist,                                &
   &                    p_patch%cells%start_idx, p_patch%cells%start_blk )
ENDIF
CALL nf(nf_inq_varid(ncid, 'end_idx_v', varid))
IF (global_cell_type == 3) THEN ! triangular grid
  CALL nf(nf_get_var_int(ncid, varid, array_v_indlist(:,:)))
  CALL reshape_idx_list( array_v_indlist,                                &
   &                    p_patch%verts%end_idx, p_patch%verts%end_blk )
ELSEIF (global_cell_type == 6) THEN ! hexagonal grid
  CALL nf(nf_get_var_int(ncid, varid, array_c_indlist(:,:)))
  CALL reshape_idx_list( array_c_indlist,                                &
   &                    p_patch%cells%end_idx, p_patch%cells%end_blk )
ENDIF

CALL nf(nf_close(ncid))


!
! deallocate temporary arrays to read in data form the grid/patch generator
!
! integer arrays
DEALLOCATE( array_c_int, array_e_int, array_v_int,  &
  &         STAT=ist )
IF (ist /= SUCCESS) THEN
  CALL finish ('mo_model_domain_import:read_patch',  &
    &             'deallocation for array_[cev]_int failed')
ENDIF
! real arrays
DEALLOCATE( array_c_real, array_e_real, array_v_real,  &
  &         STAT=ist )
IF (ist /= SUCCESS) THEN
  CALL finish ('mo_model_domain_import:read_patch',  &
    &             'deallocation for array_[cev]_real failed')
ENDIF
! index lists arrays
DEALLOCATE( array_c_indlist, array_e_indlist, array_v_indlist,  &
  &         STAT=ist )
IF (ist /= SUCCESS) THEN
  CALL finish ('mo_model_domain_import:read_patch',  &
    &             'deallocation for array_[cev]_indlist failed')
ENDIF

!
! Set values which are needed for parallel runs
! to the correct values for a single patch owner
!
p_patch%comm   = 0
p_patch%rank   = 0
p_patch%n_proc = 1
p_patch%proc0  = 0

! decomp_domain/owner mask:
! Everywhere 0 or .true. with the exception of unused entries

p_patch%cells%decomp_domain = 0
p_patch%edges%decomp_domain = 0
p_patch%verts%decomp_domain = 0
p_patch%cells%owner_mask = .TRUE.
p_patch%edges%owner_mask = .TRUE.
p_patch%verts%owner_mask = .TRUE.

p_patch%cells%decomp_domain(p_patch%npromz_c+1:nproma,p_patch%nblks_c) = -1
p_patch%edges%decomp_domain(p_patch%npromz_e+1:nproma,p_patch%nblks_e) = -1
p_patch%verts%decomp_domain(p_patch%npromz_v+1:nproma,p_patch%nblks_v) = -1

p_patch%cells%owner_mask(p_patch%npromz_c+1:nproma,p_patch%nblks_c) = .FALSE.
p_patch%edges%owner_mask(p_patch%npromz_e+1:nproma,p_patch%nblks_e) = .FALSE.
p_patch%verts%owner_mask(p_patch%npromz_v+1:nproma,p_patch%nblks_v) = .FALSE.

! The following arrays are currently never needed for non parallel runs,
! we set them nontheless.

DO jc = 1, p_patch%n_patch_cells
  p_patch%cells%glb_index(jc) = jc
  p_patch%cells%loc_index(jc) = jc
  p_patch%cells%owner_g(jc) = 0
ENDDO

DO je = 1, p_patch%n_patch_edges
  p_patch%edges%glb_index(je) = je
  p_patch%edges%loc_index(je) = je
  p_patch%edges%owner_g(je) = 0
ENDDO

DO jv = 1, p_patch%n_patch_verts
  p_patch%verts%glb_index(jv) = jv
  p_patch%verts%loc_index(jv) = jv
  p_patch%verts%owner_g(jv) = 0
ENDDO

CALL message ('mo_model_domimp_patches:read_patch', 'read_patches finished')

END SUBROUTINE read_patch

!-------------------------------------------------------------------------

!-------------------------------------------------------------------------
!
!

!>
!!               reshape an integer index array for the blocking.
!!
!!
!! @par Revision History
!! Developed  by  Jochen Foerstner, DWD (2008-10-21)
!!
SUBROUTINE reshape_idx( p_idx_array_in, nblks, npromz,  &
  &                     p_reshaped_idx_array_out,       &
  &                     p_reshaped_blk_array_out )



! input index array
INTEGER, INTENT(in) :: p_idx_array_in(:)
! number of blocks
INTEGER, INTENT(in) :: nblks
! chunk length
INTEGER, INTENT(in) :: npromz

! output line index array
INTEGER, INTENT(inout) :: p_reshaped_idx_array_out(:,:)
! output block index array
INTEGER, INTENT(inout) :: p_reshaped_blk_array_out(:,:)

INTEGER :: nlen
INTEGER :: jl, jb
INTEGER :: il, idx_in, idx, blk

!-----------------------------------------------------------------------

DO jb = 1, nblks

  IF (jb /= nblks) THEN
    nlen = nproma
  ELSE
    nlen = npromz
    DO jl = npromz+1, nproma
      p_reshaped_idx_array_out(jl,nblks) = 0
      p_reshaped_blk_array_out(jl,nblks) = 0
    END DO
  END IF

  DO jl = 1, nlen
    il  = jl + ( jb - 1 )*nproma
    idx_in = p_idx_array_in(il)
    blk = ( ABS(idx_in) - 1 ) / nproma + 1
    idx = SIGN( ABS(idx_in) - ( blk - 1 )*nproma, idx_in )
    p_reshaped_idx_array_out(jl,jb) = idx
    p_reshaped_blk_array_out(jl,jb) = blk
  END DO

END DO

END SUBROUTINE reshape_idx

!-------------------------------------------------------------------------

!-------------------------------------------------------------------------
!
!

!>
!!               reshape an index list array for the blocking.
!!
!!
!! @par Revision History
!! Developed  by Guenther Zaengl, DWD (2008-10-23)
!!
SUBROUTINE reshape_indlist( indlist_in,                     &
  &                         start_idx_out, start_blk_out,   &
  &                         end_idx_out,   end_blk_out )



! input index array
INTEGER, INTENT(in) :: indlist_in(:,:)

! output line index array
INTEGER, INTENT(inout) :: start_idx_out(:,:), end_idx_out(:,:)
! output block index array
INTEGER, INTENT(inout) :: start_blk_out(:,:), end_blk_out(:,:)

!-----------------------------------------------------------------------

start_blk_out(:,1) = (indlist_in(:,1) - 1) / nproma + 1
start_idx_out(:,1) =  indlist_in(:,1) - (start_blk_out(:,1) - 1) * nproma

end_blk_out(:,1) = (indlist_in(:,2) - 1) / nproma + 1
end_idx_out(:,1) =  indlist_in(:,2) - (end_blk_out(:,1) - 1) * nproma


END SUBROUTINE reshape_indlist


!-------------------------------------------------------------------------
!
!

!>
!!               reshape the start_idx / end_idx fields for blocking.
!!
!!
!! @par Revision History
!! Developed  by Guenther Zaengl, DWD (2009-07-22)
!!
SUBROUTINE reshape_idx_list( indlist_in, idx_out, blk_out )



! input index array
INTEGER, INTENT(in) :: indlist_in(:,:)

! output line index array
INTEGER, INTENT(inout) :: idx_out(:,:)
! output block index array
INTEGER, INTENT(inout) :: blk_out(:,:)

!-----------------------------------------------------------------------

blk_out(:,1:max_childdom) = (indlist_in(:,1:max_childdom) - 1) / nproma + 1
idx_out(:,1:max_childdom) =  indlist_in(:,1:max_childdom) - &
                            (blk_out(:,1:max_childdom) - 1) * nproma

END SUBROUTINE reshape_idx_list

!-------------------------------------------------------------------------

!-------------------------------------------------------------------------
!
!

!>
!!               Deallocation of all memory that was allocated.
!!
!!               Deallocation of all memory that was allocated
!!               to store the patch information of all levels.
!!
!! @par Revision History
!! Developed  by  Peter Korn, MPI-M (2005).
!! Modification by Almut Gassmann, MPI-M (2007-04-04)
!! - adaptations for new multiple patch structure, cleaning up
!! Modification by Almut Gassmann, MPI-M (2007-04-19)
!! - grid information belong here
!! Modification by Almut Gassmann, MPI-M (2008-10-30)
!! - add Coriolis destruction
!!
  SUBROUTINE destruct_patches( p_patch )
!
!

    TYPE(t_patch), TARGET, INTENT(inout) :: p_patch(n_dom_start:)

    CHARACTER(len=MAX_CHAR_LENGTH), PARAMETER :: &
    &        routine = 'mo_model_domimp_patches:destruct_patches'

!local variables
INTEGER :: jg, ist
!-----------------------------------------------------------------------

    CALL message (TRIM(routine), 'start')

GRID_LEVEL_LOOP: DO jg = n_dom_start, n_dom

  !
  ! DEALLOCATE EXTERNAL DATA
  !

  IF (locean) THEN

    ! deallocate vertical domain
    DEALLOCATE(p_patch(jg)%patch_oce%del_zlev_i,STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'deallocating del_zlev_i failed')
    ENDIF

    DEALLOCATE(p_patch(jg)%patch_oce%zlev_m,STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'deallocating zlev_m failed')
    ENDIF
    DEALLOCATE(p_patch(jg)%patch_oce%zlev_i,STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'deallocating zlev_i failed')
    ENDIF
    DEALLOCATE(p_patch(jg)%patch_oce%del_zlev_m,STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'deallocating del_zlev_m failed')
    ENDIF

    ! deallocate bathymetry
    DEALLOCATE(p_patch(jg)%patch_oce%bathymetry_c,STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'deallocating bathymetry_c failed')
    ENDIF
    DEALLOCATE(p_patch(jg)%patch_oce%bathymetry_e,STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'deallocating bathymetry_e failed')
    ENDIF

    ! deallocate 3-dim land-sea-mask
    DEALLOCATE(p_patch(jg)%patch_oce%lsm_oce_c,STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'deallocating lsm_oce_c failed')
    ENDIF
    DEALLOCATE(p_patch(jg)%patch_oce%lsm_oce_e,STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'deallocating lsm_oce_e failed')
    ENDIF
    ! deepest ocean layer in column
    DEALLOCATE(p_patch(jg)%patch_oce%dolic_c,STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'deallocating dolic_c failed')
    ENDIF
    DEALLOCATE(p_patch(jg)%patch_oce%dolic_e,STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'deallocating dolic_e failed')
    ENDIF
    ! deallocate 3-dim real land-sea-mask
    DEALLOCATE(p_patch(jg)%patch_oce%wet_c,STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'deallocating wet_c failed')
    ENDIF
    DEALLOCATE(p_patch(jg)%patch_oce%wet_e,STAT=ist)
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'deallocating wet_e failed')
    ENDIF
    !DEALLOCATE(p_patch(jg)%patch_oce%wet_i,STAT=ist)
    !IF (ist /= SUCCESS) THEN
    !  CALL finish (routine,'deallocating wet_i failed')
    !ENDIF

    ! deallocate arrays for reconstruction
    !DEALLOCATE(p_patch(jg)%patch_oce%cell2edge_vec,STAT=ist)
    !IF (ist /= SUCCESS) THEN
    !  CALL finish (routine,'deallocating cell2edge_vec failed')
    !ENDIF
    !DEALLOCATE(p_patch(jg)%patch_oce%cell2edge_weight,STAT=ist)
    !IF (ist /= SUCCESS) THEN
    !  CALL finish (routine,'deallocating cell2edge_weight failed')
    !ENDIF
    !DEALLOCATE(p_patch(jg)%patch_oce%vertex2dualedge_mid_vec,STAT=ist)
    !IF (ist /= SUCCESS) THEN
    !  CALL finish (routine,'deallocating vertex2dualedge_mid_vec failed')
    !ENDIF
    !DEALLOCATE(p_patch(jg)%patch_oce%vertex2dualedge_mid_weight,STAT=ist)
    !IF (ist /= SUCCESS) THEN
    !  CALL finish (routine,'deallocating vertex2dualedge_mid_weight failed')
    !ENDIF
!     DEALLOCATE(p_patch(jg)%patch_oce%mid_dual_edge,STAT=ist)
!     IF (ist /= SUCCESS) THEN
!       CALL finish (routine,'deallocating mid_dual_edge failed')
!     ENDIF
!     DEALLOCATE(p_patch(jg)%patch_oce%dist_vert2vert,STAT=ist)
!     IF (ist /= SUCCESS) THEN
!       CALL finish (routine,'deallocating dist_vert2vert failed')
!     ENDIF
      DEALLOCATE(p_patch(jg)%patch_oce%edge2cell_coeff_cc,STAT=ist)
      IF (ist /= SUCCESS) THEN
        CALL finish (routine,'deallocating edge2cell_coeff failed')
      ENDIF
     DEALLOCATE(p_patch(jg)%patch_oce%edge2cell_coeff_cc_t,STAT=ist)
     IF (ist /= SUCCESS) THEN
       CALL finish (routine,'deallocating edge2cell_coeff_t failed')
     ENDIF
     DEALLOCATE(p_patch(jg)%patch_oce%edge2vert_coeff_cc,STAT=ist)
     IF (ist /= SUCCESS) THEN
       CALL finish (routine,'deallocating edge2vert_coeff cc failed')
     ENDIF
     DEALLOCATE(p_patch(jg)%patch_oce%edge2vert_coeff_cc_t,STAT=ist)
     IF (ist /= SUCCESS) THEN
       CALL finish (routine,'deallocating edge2vert_coeff_cc t failed')
     ENDIF
     DEALLOCATE(p_patch(jg)%patch_oce%fixed_vol_norm,STAT=ist)
     IF (ist /= SUCCESS) THEN
       CALL finish (routine,'deallocating fixed_vol_norm failed')
     ENDIF
     DEALLOCATE(p_patch(jg)%patch_oce%variable_vol_norm,STAT=ist)
     IF (ist /= SUCCESS) THEN
       CALL finish (routine,'deallocating variable_vol_norm failed')
     ENDIF
     DEALLOCATE(p_patch(jg)%patch_oce%variable_dual_vol_norm,STAT=ist)
     IF (ist /= SUCCESS) THEN
       CALL finish (routine,'deallocating variable_dual_vol_norm failed')
     ENDIF


    ! deallocate geometrical factors
    DEALLOCATE (p_patch(jg)%patch_oce%geofac_div, STAT=ist )
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocation for geofac_div failed')
    ENDIF
    DEALLOCATE (p_patch(jg)%patch_oce%geofac_qdiv, STAT=ist )
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocation for geofac_qdiv failed')
    ENDIF
    DEALLOCATE (p_patch(jg)%patch_oce%geofac_rot, STAT=ist )
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocation for geofac_rot failed')
    ENDIF
    DEALLOCATE (p_patch(jg)%patch_oce%geofac_n2s, STAT=ist )
    IF (ist /= SUCCESS) THEN
      CALL finish (routine,'allocation for geofac_n2s failed')
    ENDIF

  ENDIF

  !
  ! Deallocate grid information
  !
  ! CELLS
  DEALLOCATE( p_patch(jg)%cells%idx,  &
    &         p_patch(jg)%cells%blk,  &
    &         p_patch(jg)%cells%num_edges,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell index failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%cells%parent_idx,  &
    &         p_patch(jg)%cells%parent_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell parent index failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%cells%child_idx,  &
    &         p_patch(jg)%cells%child_blk,  &
    &         p_patch(jg)%cells%child_id,   &
    &         p_patch(jg)%cells%phys_id,    &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell child index failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%cells%neighbor_idx,  &
    &         p_patch(jg)%cells%neighbor_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell neighbor index failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%cells%edge_idx,  &
    &         p_patch(jg)%cells%edge_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell edge index failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%cells%vertex_idx,  &
    &         p_patch(jg)%cells%vertex_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell vertex index failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%cells%edge_orientation,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell edge_orientation failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%cells%center,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell center failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%cells%area,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell area failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%cells%f_c,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell f_c failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%cells%refin_ctrl,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell refin_ctrl failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%cells%start_idx,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell start_idx failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%cells%end_idx,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell end_idx failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%cells%start_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell start_blk failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%cells%end_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell end_blk failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%cells%decomp_domain,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell decomp_domain failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%cells%owner_mask,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell owner_mask failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%cells%glb_index,  &
    &         p_patch(jg)%cells%loc_index,  &
    &         p_patch(jg)%cells%owner_g,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch cell data failed')
  ENDIF
  !
  !
  ! EDGES
  DEALLOCATE( p_patch(jg)%edges%idx,  &
    &         p_patch(jg)%edges%blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge index failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%parent_idx,  &
    &         p_patch(jg)%edges%parent_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge parent index failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%child_idx,  &
    &         p_patch(jg)%edges%child_blk,  &
    &         p_patch(jg)%edges%child_id,   &
    &         p_patch(jg)%edges%phys_id,    &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge child index failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%cell_idx,  &
    &         p_patch(jg)%edges%cell_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge cell index failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%vertex_idx,  &
    &         p_patch(jg)%edges%vertex_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge vertex index failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%system_orientation,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge system orientation failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%quad_idx,  &
    &         p_patch(jg)%edges%quad_blk,  &
    &         STAT=ist)
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge quad index failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%quad_orientation,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge quad orientation failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%center,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge center failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%primal_normal,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge primal_normal failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%primal_cart_normal,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge primal_cart_normal failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%dual_normal,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge dual_normal failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%dual_cart_normal,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge dual_cart_normal failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%primal_normal_cell,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge primal_normal_cell failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%dual_normal_cell,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge dual_normal_cell failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%primal_normal_vert,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge primal_normal_vert failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%dual_normal_vert,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge dual_normal_vert failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%primal_edge_length,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge primal edge length failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%inv_primal_edge_length,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for inverse patch edge primal edge length failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%dual_edge_length,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge dual edge length failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%inv_dual_edge_length,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for inverse patch edge dual edge length failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%edge_vert_length,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for edge_vert_length failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%inv_vert_vert_length,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for inverse vert_vert_length failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%edge_cell_length,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for edge_cell_length failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%area_edge,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge area_edge failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%quad_area,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge quad area failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%f_e,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge f_e failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%refin_ctrl,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge refin_ctrl failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%start_idx,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge start_idx failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%end_idx,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge end_idx failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%start_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge start_blk failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%end_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge end_blk failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%decomp_domain,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge decomp_domain failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%owner_mask,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge owner_mask failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%edges%glb_index,  &
    &         p_patch(jg)%edges%loc_index,  &
    &         p_patch(jg)%edges%owner_g,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch edge data failed')
  ENDIF
  !
  !
  ! VERTICES
  DEALLOCATE( p_patch(jg)%verts%idx,  &
    &         p_patch(jg)%verts%blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vertex index failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%verts%neighbor_idx,  &
    &         p_patch(jg)%verts%neighbor_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vertex neighbor index failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%verts%cell_idx,  &
    &         p_patch(jg)%verts%cell_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vertex cell index failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%verts%edge_idx,  &
    &         p_patch(jg)%verts%edge_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vertex edge index failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%verts%edge_orientation,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vertex edge orientation failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%verts%num_edges,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vertex number of edges failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%verts%vertex,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vertex vertex failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%verts%dual_area,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vertex dual area failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%verts%f_v,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vertex f_v failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%verts%refin_ctrl,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vertex edge refin_ctrl failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%verts%start_idx,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vertex edge start_idx failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%verts%end_idx,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vertex edge end_idx failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%verts%start_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vertex edge start_blk failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%verts%end_blk,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vertex edge end_blk failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%verts%decomp_domain,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vert decomp_domain failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%verts%owner_mask,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vert owner_mask failed')
  ENDIF
  DEALLOCATE( p_patch(jg)%verts%glb_index,  &
    &         p_patch(jg)%verts%loc_index,  &
    &         p_patch(jg)%verts%owner_g,  &
    &         STAT=ist )
  IF(ist/=SUCCESS)THEN
    CALL finish  ('mo_model_domain_import:destruct_patches', &
      'deallocate for patch vert data failed')
  ENDIF

  !
  CALL message (routine, 'destruct_patches finished')

END DO GRID_LEVEL_LOOP

END SUBROUTINE destruct_patches


!-------------------------------------------------------------------------

SUBROUTINE nf(status)

INTEGER, INTENT(in) :: status

IF (status /= nf_noerr) THEN
  CALL finish('mo_model_domain_import netCDF error', nf_strerror(status))
ENDIF

END SUBROUTINE nf

END MODULE mo_model_domimp_patches
