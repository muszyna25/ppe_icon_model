!>
!!               The module <i>mo_model_import_domain</i>.
!! provides functionality to import information about the models computational
!! domain. This information is read from several files that were generated by
!! the patch generator programm. The data types describing the model domain are
!! contained in <i>mo_domain_model</i>.
!!
!! @par Revision History
!! Initial version  by: Peter Korn,  MPI-M, Hamburg, June 2005
!! Modification by Thomas Heinze (2006-02-21):
!! - renamed m_modules to mo_modules
!! Modification by Thomas Heinze (2006-09-20):
!! - added method_name grid_and_patch_diagnosis
!! Modification by Pilar Ripodas, DWD, (2007-01-31)
!! - addapted to the new TYPE grid_edges (system_orientation added)
!! Modification by Peter Korn,  MPI-M, (2006-12)
!! - implementation of topography and boundary treatment, i.e.
!!   initialization of the grid & patch components that carry
!!   information about topography and the lateral boundaries of
!!   the domain; this is not related to patch boundaries.
!!   topography can either be computed by analytical l,eans or
!!   by reading from database files.
!! Modification by Hui Wan, MPI-M, (2007-02-23)
!! - Subroutine <i>init_import</i> was changed to <i>setup_grid</i>.
!!   Namelist hierarchy_ini was renamed to <i>grid_ctl</i>, moved
!!   from <i>mo_io_utilities</i> to this module and now read from
!!   an external file in subroutine <i>setup_grid</i>.
!! - Some changes in <i>init_ocean_patch_component</i> after
!!   discussion with Peter.
!! - Calculation of the min. primal edge length was added to
!!   <i>import_patches</i>. However, shouldn't it be an array with
!!   one element for each patch, rather than a scalar?
!! Modification by P. Ripodas, DWD, (2007-03-14):
!! - Now the output of "import_patches" is the min_dual_edge_lenght
!!   instead of the min_primal_edge_lenght. It will be used to set
!!   the horizontal diffusion parameter. Now it is done as it was
!!   in the prototype.
!! Modification by Almut Gassmann, MPI-M (2007-04)
!! - removed loptimize to make compatible with new grid generator
!! - removed itoa for good programming style
!! - reorganized patch input to be compatible with the new patch generator
!! - cleaning up "destruct_patches"
!! Modification by Almut Gassmann, MPI-M (2007-04-13)
!! - remove grid type and perform related adaptations
!!   (grid information comes now inside a patch)
!! - changed subroutine name form setup_grid to setup_files
!! Modified by Hui Wan, MPI-M, (2008-04-04)
!!  - topography_file_dir renamed topo_file_dir
!!  - for the hydro_atmos, control variable testtype renamed ctest_name.
!! Modified by Almut Gassmann, MPI-M, (2008-04-23)
!!  - itopo distinguishes now shallow water (itopo=1) orography function
!!    from hydro_atmos orography function (itopo=2)
!! Modification by Jochen Foerstner, DWD, (2008-07-16)
!!  - new fields in the derived type for the edges:
!!    grid_edges%primal_cart_normal (Cartesian normal to edge),
!!    grid_edges%quad_idx, grid_edges%quad_area and grid_edges%quad_orientation
!!    (indices of edges and area of the quadrilateral formed by two adjacent cells)
!!    up to now these new fields are initialized in the new routines
!!    calculate_primal_cart_normal and init_quad_twoadjcells
!!    rather than read from a grid/patch file.
!! Modification by Almut Gassmann, MPI-M, (2008-09-21)
!!  - remove reference to mask and height files, they are never used
!!  - use global_cell_type to distinguish cells as triangles or hexagons
!! Modification by Almut Gassmann, MPI-M (2008-10-30)
!!  - add subroutine init_coriolis to initialize Coriolis parameter
!! Modification by Stephan Lorenz, MPI-M (2010-02-18)
!!  - add subroutine init_ocean_patch to initialize ocean patch extensions
!! Modification by Daniel Reinert, DWD (2010-07-21)
!! - removed call of init_topography. This will be handeled within init_ext_data
!!
!! @par Copyright and License
!!
!! This code is subject to the DWD and MPI-M-Software-License-Agreement in
!! its most recent form.
!! Please see the file LICENSE in the root of the source tree for this code.
!! Where software is supplied by third parties, it is indicated in the
!! headers of the routines.
!!
!!

!----------------------------
#include "omp_definitions.inc"
!----------------------------

MODULE mo_model_domimp_patches
  !-------------------------------------------------------------------------

  USE mo_kind,               ONLY: wp
  !USE mo_io_units,           ONLY: filename_max
  USE mo_impl_constants,     ONLY: success,                &
    &                              max_char_length,        &
    &                              min_rlcell, max_rlcell, &
    &                              min_rledge, max_rledge, &
    &                              min_rlvert, max_rlvert, &
    &                              max_dom,                &
    &                              min_rlcell_int,         &
    &                              min_rledge_int,         &
    &                              min_rlvert_int
  USE mo_exception,          ONLY: message_text, message, warning, finish, em_warn
  USE mo_model_domain,       ONLY: t_patch, t_pre_patch, &
                                   t_pre_grid_edges, p_patch_local_parent
  USE mo_decomposition_tools,ONLY: t_glb2loc_index_lookup, get_valid_local_index
  USE mo_parallel_config,    ONLY: nproma
  USE mo_model_domimp_setup, ONLY: reshape_int, reshape_real,  &
    & init_quad_twoadjcells, init_coriolis, set_verts_phys_id, &
    & init_butterfly_idx, fill_grid_subsets
  USE mo_grid_tools,         ONLY: calculate_patch_cartesian_positions, rescale_grid
  USE mo_grid_config,        ONLY: start_lev, nroot, n_dom, n_dom_start,    &
    & lfeedback, l_limited_area, max_childdom, &
    & dynamics_grid_filename,   dynamics_parent_grid_id,  &
    & radiation_grid_filename,  lplane,                   &
    & grid_length_rescale_factor,                         &
    & is_plane_torus, grid_sphere_radius,                 &
    & use_duplicated_connectivity,  use_dummy_cell_closure
  USE mo_dynamics_config,    ONLY: lcoriolis
  USE mo_run_config,         ONLY: grid_generatingCenter, grid_generatingSubcenter, &
    &                              number_of_grid_used, msg_level
  USE mo_master_control,     ONLY: my_process_is_ocean
  USE mo_impl_constants_grf, ONLY: grf_bdyintp_start_c, grf_bdyintp_start_e
  USE mo_loopindices,        ONLY: get_indices_c, get_indices_e
  USE mo_mpi,                ONLY: my_process_is_mpi_parallel, p_comm_work, get_my_global_mpi_id
  USE mo_sync,               ONLY: disable_sync_checks, enable_sync_checks
  USE mo_communication,      ONLY: idx_no, blk_no, idx_1d
  USE mo_util_uuid,          ONLY: uuid_string_length, uuid_parse, clear_uuid
  USE mo_name_list_output_config, ONLY: is_grib_output
  USE mo_master_nml,         ONLY: model_base_dir

  USE mo_grid_geometry_info, ONLY: planar_torus_geometry, sphere_geometry, &
    &  set_grid_geometry_derived_info, copy_grid_geometry_info,            &
    & parallel_read_geometry_info, triangular_cell
  USE mo_alloc_patches,      ONLY: set_patches_grid_filename, &
    & allocate_pre_patch, allocate_remaining_patch
  USE mo_math_constants,     ONLY: pi, pi_2
  USE mo_grid_subset,        ONLY: t_subset_range, get_index_range
  USE mo_reorder_patches,    ONLY: reorder_cells, reorder_edges, &
    &                              reorder_verts
#ifndef __NO_ICON_ATMO__
  USE mo_interpol_config,    ONLY: nudge_zone_width
#endif

#ifndef NOMPI
  ! The USE statement below lets this module use the routines from
  ! mo_read_netcdf_parallel where only 1 processor is reading
  ! and broadcasting the results

  USE mo_read_netcdf_parallel, ONLY:                 &
    & nf_nowrite, nf_global, nf_noerr, nf_strerror,  &
    & nf_inq_attid       => p_nf_inq_attid,          &
    & nf_open            => p_nf_open,               &
    & nf_close           => p_nf_close,              &
    & nf_inq_dimid       => p_nf_inq_dimid,          &
    & nf_inq_dimlen      => p_nf_inq_dimlen,         &
    & nf_inq_varid       => p_nf_inq_varid,          &
    & nf_get_att_text    => p_nf_get_att_text,       &
    & nf_get_att_int     => p_nf_get_att_int,        &
    & nf_get_att_double  => p_nf_get_att_double,     &
    & nf_get_var_int     => p_nf_get_var_int,        &
    & nf_get_var_double  => p_nf_get_var_double
#endif

  IMPLICIT NONE

  PRIVATE

#ifdef NOMPI
  INCLUDE 'netcdf.inc'
#endif

  !modules interface-------------------------------------------
  !subroutines
  PUBLIC :: import_pre_patches
  PUBLIC :: complete_patches
  PUBLIC :: reorder_patch_refin_ctrl

  INTEGER, SAVE :: ishift_child_id

  !-------------------------------------------------------------------------

CONTAINS

  !-------------------------------------------------------------------------
  !>
  !!               This subroutine provides patch information to the model.
  !!
  !! Which data are required by the model is described in module
  !! <i>mo_model_domain</i>. The components of the patch are initialized
  !! with data stored in several patch files.
  !!
  !! @par Revision History
  !! Developed  by  Peter Korn, MPI-M (2005).
  !! @par
  !! Modified by L. Bonaventura, MPI-M (2005),
  !! to match completed patch
  !! structure in advanced patch generator.
  !! Modified by A. Gassmann, MPI-M (2007)
  !! - cleaning up the code
  !! Modified by A. Gassmann, MPI-M (2007-04)
  !! - grid information belongs now to the patch type
  !! Modified by Almut Gassmann, MPI-M (2008-09-21)
  !! - min_dual_edge_length no longer needed for new Diffusion
  !! Modified by Almut Gassmann, MPI-M (2008-10-30)
  !! - new subroutine for Coriolis initialization
  !! Modification by Stephan Lorenz, MPI-M (2010-02-06)
  !!  - new subroutine for initialization of ocean patch
  !! Modification by Rainer Johanni (2011-12-04)
  !!  - renamed to import_basic_patches
  !!  - only basic patch information for subdivision is read here
  !!    into the full (undivided, global) patch data structure
  !!
  SUBROUTINE import_pre_patches( patch_pre,num_lev,num_levp1,nshift)

    INTEGER,INTENT(in) :: num_lev(:), num_levp1(:), nshift(:)
    TYPE(t_pre_patch), TARGET, INTENT(inout) :: patch_pre(n_dom_start:)

    INTEGER :: jg, jg1, n_chd, n_chdc
    INTEGER :: jgp            ! parent patch index
    !INTEGER :: jlev

    !LOGICAL :: l_exist

    !CHARACTER(filename_max) :: patch_file, gridtype

    TYPE(t_pre_patch), POINTER ::  &
      & p_single_patch => NULL()

    CHARACTER(LEN=*), PARAMETER :: method_name = 'mo_model_domimp_patches/import_basic_patch'
    !-----------------------------------------------------------------------

    CALL message ('mo_model_domimp_patches:import_pre_patches', &
      & 'start to import patches')

    ! Set some basic flow control variables on the patch

    max_childdom = 0

    IF(n_dom_start==0) THEN
      ! The physics parent (parent of the root patch) should also be read
      patch_pre(0)%id = 0
      patch_pre(0)%level = start_lev-1
      patch_pre(0)%parent_id = -1
      patch_pre(0)%parent_child_index = 0
      patch_pre(0)%n_childdom = 1
      patch_pre(0)%n_chd_total = n_dom
      patch_pre(0)%child_id(1) = 1
      DO jg = 1, n_dom
        patch_pre(0)%child_id_list(jg) = jg
      ENDDO
      patch_pre(1)%parent_child_index = 1
    ELSE
      patch_pre(1)%parent_child_index = 0
    ENDIF

    DO jg = 1, n_dom

      patch_pre(jg)%id = jg

      IF (jg == 1) THEN
        patch_pre(jg)%level = start_lev
        patch_pre(jg)%parent_id = 0
      ELSE
        patch_pre(jg)%level = patch_pre(dynamics_parent_grid_id(jg))%level + 1
        patch_pre(jg)%parent_id = dynamics_parent_grid_id(jg)
      ENDIF

      n_chd = 0

      DO jg1 = jg+1, n_dom
        IF (jg == dynamics_parent_grid_id(jg1)) THEN
          n_chd = n_chd + 1
          patch_pre(jg)%child_id(n_chd) = jg1
          patch_pre(jg1)%parent_child_index = n_chd
        ENDIF
      ENDDO

      patch_pre(jg)%n_childdom = n_chd
      max_childdom = MAX(1,max_childdom,n_chd)

      !
      ! store information about vertical levels
      !
      patch_pre(jg)%nlev   = num_lev(jg)
      patch_pre(jg)%nlevp1 = num_levp1(jg)

      IF (jg > 1) THEN
        IF (nshift(jg) > 0 ) THEN
          ! nshift has been modified via Namelist => use it
          patch_pre(jg)%nshift = nshift(jg)
        ELSE
          ! set default value, assuming
          !- superimposed vertical levels
          !- 1 nested domain per grid level
          patch_pre(jg)%nshift = num_lev(patch_pre(jg)%parent_id) - num_lev(jg)
        ENDIF

        jgp = patch_pre(jg)%parent_id
        patch_pre(jg)%nshift_total = patch_pre(jgp)%nshift_total + patch_pre(jg)%nshift
      ELSE
        ! Note: the first nshift-value refers to the global domain
        patch_pre(jg)%nshift = 0
        patch_pre(jg)%nshift_total = 0
      ENDIF

    ENDDO

    ! Set information about total number of child domains (called recursively)
    ! and corresponding index lists

    ! Initialization
    DO jg = 1, n_dom
      patch_pre(jg)%n_chd_total      = 0
      patch_pre(jg)%child_id_list(:) = 0
    ENDDO

    DO jg = n_dom, 2, -1
      jg1 = patch_pre(jg)%parent_id
      n_chd = patch_pre(jg1)%n_chd_total
      n_chdc = patch_pre(jg)%n_chd_total
      patch_pre(jg1)%child_id_list(n_chd+1) = jg
      IF (n_chdc > 0) THEN
        patch_pre(jg1)%child_id_list(n_chd+2:n_chd+1+n_chdc) = &
          patch_pre(jg)%child_id_list(1:n_chdc)
      ENDIF
      patch_pre(jg1)%n_chd_total = n_chd+1+n_chdc
    ENDDO


    DO jg = 1, n_dom

      ! make nshift parameter also available for the parent patch
      IF (patch_pre(jg)%n_childdom >= 1) THEN
        patch_pre(jg)%nshift_child = patch_pre(patch_pre(jg)%child_id(1))%nshift
        DO jg1 = 1, patch_pre(jg)%n_childdom
          IF (patch_pre(patch_pre(jg)%child_id(jg1))%nshift /= &
            & patch_pre(jg)%nshift_child) &
            & CALL finish ('mo_model_domimp_patches:import_pre_patches', &
            & 'multiple nests at the same level must have the same nshift')
        ENDDO
      ELSE
        patch_pre(jg)%nshift_child = 0
      ENDIF

    ENDDO

    IF (n_dom_start == 0) THEN ! reduced grid for radiation
      ! In case of n_dom_start == 0 nlev, nlevp1, nshift need to be copied from
      ! jg=1 to jg=0
      patch_pre(0)%nlev   = patch_pre(1)%nlev
      patch_pre(0)%nlevp1 = patch_pre(1)%nlevp1
      patch_pre(0)%nshift = patch_pre(1)%nshift
      ! The reduced grid always has the same levels as the global one
      patch_pre(0)%nshift_child = 0
    ENDIF

    patch_pre(n_dom_start:n_dom)%max_childdom =  max_childdom


    !init patch by reading data from file
    !required: path to patch directory and file names, see top of module
    ! l_exist = .FALSE.

    ! IF (lplane) THEN
    !   gridtype='plan'
    ! ELSE
    !   gridtype='icon'
    ! END IF

    CALL set_patches_grid_filename(patch_pre)

    ishift_child_id = 0

    grid_level_loop: DO jg = n_dom_start, n_dom

      !   jlev = patch_pre(jg)%level

      ! Allow file names without "DOM" specifier if n_dom=1.
      !   IF (n_dom == 1) THEN
      !     ! Check if file name without "DOM" specifier exists.
      !     WRITE (patch_file,'(a,a,i0,a,i2.2,a)') &
      !          & TRIM(gridtype),'R',nroot,'B',jlev,'-grid.nc'
      !     INQUIRE (FILE=patch_file, EXIST=l_exist)
      !     ! Otherwise use file name with "DOM" specifier
      !     IF (.NOT. l_exist)                                            &
      !          & WRITE (patch_file,'(a,a,i0,2(a,i2.2),a)')              &
      !          & TRIM(gridtype),'R',nroot,'B',jlev,'_DOM',jg,'-grid.nc'
      !   ELSE
      !     ! n_dom >1 --> "'_DOM',jg" required in file name
      !     WRITE (patch_file,'(a,a,i0,2(a,i2.2),a)') &
      !          & TRIM(gridtype),'R',nroot,'B',jlev,'_DOM',jg,'-grid.nc'
      !   ENDIF


      p_single_patch => patch_pre(jg)

      CALL read_pre_patch( jg, p_single_patch )

    ENDDO grid_level_loop

    CALL set_pc_idx(patch_pre)

  END SUBROUTINE import_pre_patches
  !-------------------------------------------------------------------------

  !-------------------------------------------------------------------------
  !>
  !! This method_name completes basic patches by
  !! - allocating the remaining arrays
  !! - reading the remaining arrays which are not in the basic patch
  !! - calculating arrays which are not read from input file

  SUBROUTINE complete_patches(patch)

    TYPE(t_patch), TARGET, INTENT(inout) :: patch(n_dom_start:)

    INTEGER :: jg, jgp, n_lp, id_lp(max_dom)
    CHARACTER(LEN=*), PARAMETER :: method_name = 'mo_model_domimp_patches:complete_patches'

    DO jg = n_dom_start, n_dom

      ! Allocate and preset remaining arrays in patch
      ! operation mode=3: allocate all but the parallelization-related arrays
      !                   (the parallelization-related arrays are allocated in mo_setup_subdivision)
      CALL allocate_remaining_patch(patch(jg),3)
      IF (jg > n_dom_start)  &
        CALL allocate_remaining_patch(p_patch_local_parent(jg),3)
    ENDDO

    ! Fill the subsets information
    DO jg = n_dom_start, n_dom
      CALL fill_grid_subsets(patch(jg))
      IF (jg > n_dom_start)  CALL fill_grid_subsets( p_patch_local_parent(jg) )
    ENDDO

    DO jg = n_dom_start, n_dom
      n_lp = 0 ! Number of local parents on the same level
      ! Assemble a list of local parents living on the same level as the current patch
      DO jgp = n_dom_start+1, n_dom
        IF(patch(jgp)%parent_id == jg) THEN
          n_lp = n_lp+1
          id_lp(n_lp) = jgp  ! these are children of the current patch
        ENDIF
      ENDDO

      ! Get all patch information not read by read_pre_patch
      CALL read_remaining_patch( jg, patch(jg), n_lp, id_lp )
    ENDDO

    ! rescale grids
    DO jg = n_dom_start, n_dom
      CALL rescale_grid( patch(jg), grid_length_rescale_factor  )
      IF (jg > n_dom_start)  CALL rescale_grid( p_patch_local_parent(jg), grid_length_rescale_factor )
    ENDDO

    ! do other stuff
    DO jg = n_dom_start, n_dom
      CALL set_verts_phys_id( patch(jg) )
    ENDDO

    IF (.not. my_process_is_ocean()) THEN
      DO jg = n_dom_start, n_dom
        ! Initialize the data for the quadrilateral cells
        ! formed by the two adjacent cells of an edge.
        ! (later this should be provided by the grid generator)
        CALL init_quad_twoadjcells( patch(jg) )
        ! Initialize butterfly data structure, formed by the
        ! 4 cells sharing the 2 vertices which bound a given edge.
        IF (patch(jg)%cell_type == 3) THEN
          ! not useful for hexagonal grid
          CALL init_butterfly_idx( patch(jg) )
        ENDIF

        CALL init_coriolis( lcoriolis, lplane, patch(jg) )

        ! The same has to be done for local parents in parallel runs
        !
        ! Please note: The call to init_quad_twoadjcells involves boundary
        ! exchange and is not repeated here for local parents.
        ! The arrays calculated there are transfered to the local parent
        ! in transfer_interpol_state where also a lot of other arrays
        ! from the patch state are transferred

        IF (jg>n_dom_start) THEN
          CALL disable_sync_checks
          CALL init_coriolis( lcoriolis, lplane, p_patch_local_parent(jg) )
          CALL set_verts_phys_id( p_patch_local_parent(jg) )
          CALL enable_sync_checks
        ENDIF

      ENDDO
    ENDIF

  END SUBROUTINE complete_patches
  !-------------------------------------------------------------------------


  !-------------------------------------------------------------------------
  !> reorder patch data structure according to the refin_ctrl flags.
  !
  !  Only interior cells/edges/vertices are sorted in decreasing
  !  order.
  !
  !  @author F. Prill, DWD (2013-07-31)
  !
  !  @todo OpenMP parallelization!
  !
  !
  SUBROUTINE reorder_patch_refin_ctrl(patch, child_patch)
    TYPE(t_patch),         INTENT(INOUT) :: patch, child_patch   ! patch data structures
    ! local variables
    INTEGER, ALLOCATABLE :: old2new(:)
    INTEGER              :: n, irefin, ic, ntot, ninterior

    ! -- reorder cells
    ntot      = idx_1d( patch%cells%end_index(min_rlcell), &
      &                 patch%cells%end_block(min_rlcell) )
    ninterior = idx_1d( patch%cells%start_index(min_rlcell_int-1), &
      &                 patch%cells%start_block(min_rlcell_int-1) ) - 1
    ALLOCATE(old2new(ntot))
    DO ic = 1,ntot
      old2new(ic) = ic
    END DO
    n = 0
    DO irefin = -1,min_rlcell_int,-1
      DO ic = 1,ninterior
        IF (patch%cells%refin_ctrl(idx_no(ic), blk_no(ic)) == irefin) THEN
          n = n + 1
          old2new(ic) = n
        END IF
      END DO
      ! update start_idx/blk and end_idx_blk
      patch%cells%end_index(irefin)     = idx_no(n)
      patch%cells%end_block(irefin)     = blk_no(n)
      patch%cells%start_index(irefin-1) = idx_no(n+1)
      patch%cells%start_block(irefin-1) = blk_no(n+1)
    END DO
    CALL reorder_cells(patch, old2new, opt_child_pp=child_patch)
    DEALLOCATE(old2new)

    ! -- reorder edges
    ntot      = idx_1d( patch%edges%end_index(min_rledge), &
      &                 patch%edges%end_block(min_rledge) )
    ninterior = idx_1d( patch%edges%start_index(min_rledge_int-1), &
      &                 patch%edges%start_block(min_rledge_int-1) ) - 1
    ALLOCATE(old2new(ntot))
    DO ic = 1,ntot
      old2new(ic) = ic
    END DO
    n = 0
    DO irefin = -1,min_rledge_int,-1
      DO ic = 1,ninterior
        IF (patch%edges%refin_ctrl(idx_no(ic), blk_no(ic)) == irefin) THEN
          n = n + 1
          old2new(ic) = n
        END IF
      END DO
      ! update start_idx/blk and end_idx_blk
      patch%edges%end_index(irefin)     = idx_no(n)
      patch%edges%end_block(irefin)     = blk_no(n)
      patch%edges%start_index(irefin-1) = idx_no(n+1)
      patch%edges%start_block(irefin-1) = blk_no(n+1)
    END DO
    CALL reorder_edges(patch, old2new, opt_child_pp=child_patch)
    DEALLOCATE(old2new)

    ! -- reorder verts
    ntot      = idx_1d( patch%verts%end_index(min_rlvert), &
      &                 patch%verts%end_block(min_rlvert) )
    ninterior = idx_1d( patch%verts%start_index(min_rlvert_int-1), &
      &                 patch%verts%start_block(min_rlvert_int-1) ) - 1
    ALLOCATE(old2new(ntot))
    DO ic = 1,ntot
      old2new(ic) = ic
    END DO
    n = 0
    DO irefin = -1,min_rlvert_int,-1
      DO ic = 1,ninterior
        IF (patch%verts%refin_ctrl(idx_no(ic), blk_no(ic)) == irefin) THEN
          n = n + 1
          old2new(ic) = n
        END IF
      END DO
      ! update start_idx/blk and end_idx_blk
      patch%verts%end_index(irefin)     = idx_no(n)
      patch%verts%end_block(irefin)     = blk_no(n)
      patch%verts%start_index(irefin-1) = idx_no(n+1)
      patch%verts%start_block(irefin-1) = blk_no(n+1)
    END DO
    CALL reorder_verts(patch, old2new)
    DEALLOCATE(old2new)

    ! Copy index bounds to the old 2D fields until the restructuring is completed
    DO n = 1, patch%max_childdom
      patch%cells%end_idx(:,n)   = patch%cells%end_index(:)
      patch%cells%end_blk(:,n)   = patch%cells%end_block(:)
      patch%cells%start_idx(:,n) = patch%cells%start_index(:)
      patch%cells%start_blk(:,n) = patch%cells%start_block(:)
      patch%edges%end_idx(:,n)   = patch%edges%end_index(:)
      patch%edges%end_blk(:,n)   = patch%edges%end_block(:)
      patch%edges%start_idx(:,n) = patch%edges%start_index(:)
      patch%edges%start_blk(:,n) = patch%edges%start_block(:)
      patch%verts%end_idx(:,n)   = patch%verts%end_index(:)
      patch%verts%end_blk(:,n)   = patch%verts%end_block(:)
      patch%verts%start_idx(:,n) = patch%verts%start_index(:)
      patch%verts%start_blk(:,n) = patch%verts%start_block(:)
    ENDDO

  END SUBROUTINE reorder_patch_refin_ctrl
  !-------------------------------------------------------------------------


  !-------------------------------------------------------------------------
  !>
  ! calculate mean geometry properties for old grids,
  ! the new grids should have these values filled
  ! All the patches should have the same geometry type
  SUBROUTINE set_missing_geometry_info( patch )
    TYPE(t_patch), INTENT(inout), TARGET ::  patch

    CHARACTER(LEN=*), PARAMETER :: method_name = 'mo_model_domimp_patches:set_missing_geometry_info'

    !-----------------------------------------------------------------------
    SELECT CASE(patch%geometry_info%geometry_type)

    CASE (planar_torus_geometry)

      CALL finish(method_name, "planar_torus_geometry should be read from the grid file")

    CASE (sphere_geometry)
      ! if geometry_info is missing then the grid is trianguler by default
      patch%geometry_info%cell_type = triangular_cell
      IF (patch%cells%max_connectivity /= 3) &
        CALL finish("set_missing_geometry_info","cells%max_cell_connectivity /= 3")

      ! note that the grid_sphere_radius is already rescaled
      patch%geometry_info%sphere_radius = grid_sphere_radius / grid_length_rescale_factor
      ! divide the sphere surface by the number of cells
      ! Note: this works only for old grids
      patch%geometry_info%mean_cell_area = &
        & (4._wp * pi * patch%geometry_info%sphere_radius**2) &
        & / (REAL(20*nroot**2,wp)*4._wp**patch%level)

      patch%geometry_info%domain_length  = 2.0_wp * pi * patch%geometry_info%sphere_radius
      patch%geometry_info%domain_height  = patch%geometry_info%domain_length

      ! Note: the mean_edge_length is not used for the sphere geometry,
      ! and calculating will require global communication. Set to 0
      patch%geometry_info%mean_edge_length = 0.0_wp

    CASE default
      CALL finish(method_name, "Undefined geometry type")

    END SELECT

  END SUBROUTINE set_missing_geometry_info

  !-------------------------------------------------------------------------
  !>
  !! This method_name sets the parent-child-index for cells and edges
  !!
  !! @par Revision History
  !! Developed  by Rainer Johanni, Dec 2011
  !!
  SUBROUTINE set_pc_idx(patch)

    TYPE(t_pre_patch), TARGET, INTENT(inout) :: patch(n_dom_start:)

    ! local variables

    INTEGER :: jg, jgp, jb, jl, ilp, ibp, nlen

    !-----------------------------------------------------------------------

    DO jg = n_dom_start+1, n_dom

      jgp = patch(jg)%parent_id

      patch(jg)%cells%pc_idx(:,:) = 0
      patch(jg)%edges%pc_idx(:,:) = 0

      DO jb = 1, patch(jg)%nblks_c

        IF (jb /= patch(jg)%nblks_c) THEN
          nlen = nproma
        ELSE
          nlen = patch(jg)%npromz_c
        ENDIF

        DO jl = 1, nlen

          ilp = patch(jg)%cells%parent_idx(jl,jb)
          ibp = patch(jg)%cells%parent_blk(jl,jb)

          IF(patch(jgp)%cells%child_idx(ilp,ibp,1) == jl .AND. &
            & patch(jgp)%cells%child_blk(ilp,ibp,1) == jb ) patch(jg)%cells%pc_idx(jl,jb) = 1
          IF(patch(jgp)%cells%child_idx(ilp,ibp,2) == jl .AND. &
            & patch(jgp)%cells%child_blk(ilp,ibp,2) == jb ) patch(jg)%cells%pc_idx(jl,jb) = 2
          IF(patch(jgp)%cells%child_idx(ilp,ibp,3) == jl .AND. &
            & patch(jgp)%cells%child_blk(ilp,ibp,3) == jb ) patch(jg)%cells%pc_idx(jl,jb) = 3
          IF(patch(jgp)%cells%child_idx(ilp,ibp,4) == jl .AND. &
            & patch(jgp)%cells%child_blk(ilp,ibp,4) == jb ) patch(jg)%cells%pc_idx(jl,jb) = 4
!          IF(patch(jg)%cells%pc_idx(jl,jb) == 0) CALL finish('set_pc_idx','cells%pc_idx')

        ENDDO

      ENDDO

      DO jb = 1, patch(jg)%nblks_e

        IF (jb /= patch(jg)%nblks_e) THEN
          nlen = nproma
        ELSE
          nlen = patch(jg)%npromz_e
        ENDIF

        DO jl = 1, nlen

          ilp = patch(jg)%edges%parent_idx(jl,jb)
          ibp = patch(jg)%edges%parent_blk(jl,jb)

          IF(patch(jgp)%edges%child_idx(ilp,ibp,1) == jl .AND. &
            & patch(jgp)%edges%child_blk(ilp,ibp,1) == jb ) patch(jg)%edges%pc_idx(jl,jb) = 1
          IF(patch(jgp)%edges%child_idx(ilp,ibp,2) == jl .AND. &
            & patch(jgp)%edges%child_blk(ilp,ibp,2) == jb ) patch(jg)%edges%pc_idx(jl,jb) = 2
          IF(patch(jgp)%edges%child_idx(ilp,ibp,3) == jl .AND. &
            & patch(jgp)%edges%child_blk(ilp,ibp,3) == jb ) patch(jg)%edges%pc_idx(jl,jb) = 3
          IF(patch(jgp)%edges%child_idx(ilp,ibp,4) == jl .AND. &
            & patch(jgp)%edges%child_blk(ilp,ibp,4) == jb ) patch(jg)%edges%pc_idx(jl,jb) = 4
!          IF(patch(jg)%edges%pc_idx(jl,jb) == 0) CALL finish('set_pc_idx','edges%pc_idx')

        ENDDO

      ENDDO

    ENDDO

  END SUBROUTINE set_pc_idx
  !-------------------------------------------------------------------------


  !-------------------------------------------------------------------------
  !>
  !! Initialization of the patch components with data stored
  !! in files.
  !!
  !! @par Revision History
  !! Developed  by  Peter Korn, MPI-M (2005).
  !! Modified by L. Bonaventura, MPI-M (2005),
  !! to match completed patch
  !! structure in advanced patch generator.
  !! Modified by A. Gassmann, MPI-M (2007-04-03)
  !! - cleaning up and adaptations for reading multiple patches
  !! Modified by A. Gassmann, MPI-M (2007-04-03)
  !! - patch owns grid information, global grid is obsolete.
  !! - changed name from init_patch to read_patch
  !! Modified by A. Gassmann, MPI-M (2008-09-21)
  !! - remove all not netcdf stuff
  !! - HERE we must think of how to use different 'global_cell_type's
  !! Modified by A. Gassmann, MPI-M (2008-10-30)
  !! - read in grid for either triangles or hexagons
  !! Modified by R. Johanni (2011-12-04)
  !! - split into read_basic_patch for reading the basic patch information
  !!   for subdivision into the fully allocated patch and read_remaining_patch
  !!   for reading the remaining information
  !!
  SUBROUTINE read_pre_patch( ig, patch_pre, patch_file )

    CHARACTER(LEN=*), PARAMETER :: method_name = 'mo_model_domimp_patches/read_pre_patch'
    INTEGER,             INTENT(in)    ::  ig           ! domain ID
    CHARACTER(LEN=*),    INTENT(in), OPTIONAL ::  patch_file   ! name of grid file

    TYPE(t_pre_patch), TARGET, INTENT(inout) ::  patch_pre      ! patch data structure

    INTEGER, ALLOCATABLE :: &
      & array_c_int(:,:),  &  ! temporary arrays to read in integer values
      & array_e_int(:,:),  &
      & array_v_int(:,:)

    REAL(wp), ALLOCATABLE :: &
      & array_c_real(:,:), &  ! temporary arrays to read in real values
      & array_e_real(:,:), &
      & array_v_real(:,:)

    INTEGER, ALLOCATABLE :: &
      & start_idx_c(:,:), end_idx_c(:,:), &  ! temporary arrays to read in index lists
      & start_idx_e(:,:), end_idx_e(:,:), &
      & start_idx_v(:,:), end_idx_v(:,:)

    ! dummy values for number of internal halo cells, edges, vertices, not actually used
!    INTEGER :: n_e_halo_cells
!    INTEGER :: n_e_halo_edges
!    INTEGER :: n_e_halo_verts

    ! INTEGER :: patch_unit

    ! LOGICAL :: lnetcdf = .TRUE.
    ! CHARACTER(len=filename_max) :: file

    CHARACTER(LEN=uuid_string_length) :: uuid_string

    ! status variables
    INTEGER :: ist, netcd_status

    INTEGER :: ncid, dimid, varid, max_cell_connectivity, max_verts_connectivity
    INTEGER :: ji
    INTEGER :: jc, je, ilc, ibc
    INTEGER :: icheck, ilev, igrid_level, igrid_id, iparent_id, i_max_childdom, ipar_id, dim_idxlist
    INTEGER :: block_size
    !-----------------------------------------------------------------------

    ! set dummy values to zero
!    n_e_halo_cells = 0
!    n_e_halo_edges = 0
!    n_e_halo_verts = 0

    ilev = patch_pre%level
    ipar_id = patch_pre%parent_id

    !
    ! start to fill patch type
    !
    IF (PRESENT(patch_file)) THEN
      patch_pre%grid_filename=patch_file
    ENDIF


    CALL message (TRIM(method_name), 'start to init patch_pre')

    WRITE(message_text,'(a,a)') 'Read grid file ', TRIM(patch_pre%grid_filename)
    CALL message ('', TRIM(message_text))

    CALL nf(nf_open(TRIM(patch_pre%grid_filename), nf_nowrite, ncid))

    uuid_string = 'warning: not given ...' ! To avoid null characters in the standard output

    IF (nf_get_att_text(ncid, nf_global, 'uuidOfHGrid', uuid_string) /= nf_noerr) THEN
      IF (is_grib_output()) THEN
        CALL message(TRIM(method_name), "Warning: uuidOfHGrid not set as an attribute!")
      END IF
      CALL clear_uuid(patch_pre%grid_uuid)
    ELSE
      CALL uuid_parse(uuid_string, patch_pre%grid_uuid)
      WRITE(message_text,'(a,a)') 'grid uuid: ', TRIM(uuid_string)
      CALL message  (TRIM(method_name), message_text)
    END IF

    ! Read additional grid identifiers
    ! grid_generatingCenter
    ! grid_generatingSubcenter
    ! number_of_grid_used
    netcd_status = nf_get_att_int(ncid, nf_global, 'center', &
      &                           grid_generatingCenter(ig)  )
    IF (netcd_status == nf_noerr) THEN
      WRITE(message_text,'(a,i4,a,i4)') &
        & 'generating center of patch ', ig, ': ',grid_generatingCenter(ig)
      CALL message  (TRIM(method_name), TRIM(message_text))
    ELSE
      WRITE(message_text,'(a,i4,a,i4)') &
        & 'WARNING: generating center of patch ', ig, ' not found'
      CALL message  (TRIM(method_name), TRIM(message_text))
      ! set default value
      grid_generatingCenter(ig) = 78    ! DWD
    ENDIF

    netcd_status = nf_get_att_int(ncid, nf_global, 'subcenter', &
      &                           grid_generatingSubcenter(ig)  )
    IF (netcd_status == nf_noerr) THEN
      WRITE(message_text,'(a,i4,a,i4)') &
        & 'generating subcenter of patch ', ig, ': ',grid_generatingSubcenter(ig)
      CALL message  (TRIM(method_name), TRIM(message_text))
    ELSE
      WRITE(message_text,'(a,i4,a,i4)') &
        & 'WARNING: generating subcenter of patch ', ig, ' not found'
      CALL message  (TRIM(method_name), TRIM(message_text))
      ! set default value
      grid_generatingSubcenter(ig) = 255
    ENDIF

    netcd_status = nf_get_att_int(ncid, nf_global, 'number_of_grid_used', &
      &            number_of_grid_used(ig))
    IF (netcd_status == nf_noerr) THEN
      WRITE(message_text,'(a,i4,a,i4)') &
        & 'number_of_grid_used of patch ', ig, ': ',number_of_grid_used(ig)
      CALL message  (TRIM(method_name), TRIM(message_text))
    ELSE
      WRITE(message_text,'(a,i4,a,i4)') &
        & 'WARNING: number_of_grid_used of patch ', ig, ' not found'
      CALL message  (TRIM(method_name), TRIM(message_text))
      ! set default value
      number_of_grid_used(ig) = 42
    ENDIF

    CALL nf(nf_get_att_int(ncid, nf_global, 'grid_root', icheck))
    IF (icheck /= nroot) THEN
      WRITE(message_text,'(a,i4,a,i4)') &
        & 'grid_root attribute:', icheck,', R:',nroot
      CALL message  (TRIM(method_name), TRIM(message_text))
      WRITE(message_text,'(a)') &
        & 'Mismatch between "grid_root" attribute and "R" parameter in the filename'
      CALL finish  (TRIM(method_name), TRIM(message_text))
    END IF

    CALL nf(nf_get_att_int(ncid, nf_global, 'grid_level', igrid_level))
    IF (igrid_level /= ilev) THEN
      WRITE(message_text,'(a,i4,a,i4)') &
        & 'grid_level attribute:', igrid_level,', B:',ilev
      CALL message  (TRIM(method_name), TRIM(message_text))
      WRITE(message_text,'(a)') &
        & 'Mismatch between "grid_level" attribute and "B" parameter in the filename'
      CALL finish  (TRIM(method_name), TRIM(message_text))
    END IF

    ! Check additional attributes for consistency with the current namelist settings
    CALL nf(nf_get_att_int(ncid, nf_global, 'grid_ID', igrid_id))
    IF ((.NOT.l_limited_area).AND.(igrid_id /= ig)) THEN
      WRITE(message_text,'(a,i4,a,i4)') &
        & 'grid ID attribute:', igrid_id,', namelist value:',ig
      CALL message  (TRIM(method_name), TRIM(message_text))
      WRITE(message_text,'(a)') &
        & 'Mismatch between "grid ID" attribute and corresponding namelist setting'
      CALL finish  (TRIM(method_name), TRIM(message_text))
    END IF

    CALL nf(nf_get_att_int(ncid, nf_global, 'parent_grid_ID', iparent_id))
    IF ((.NOT.l_limited_area).AND.(iparent_id /= ipar_id)) THEN
      WRITE(message_text,'(a,i4,a,i4)') &
        & 'parent ID attribute:', iparent_id,', namelist value:',ipar_id
      CALL message  (TRIM(method_name), TRIM(message_text))
      WRITE(message_text,'(a)') &
        & 'Mismatch between "parent grid ID" attribute and corresponding namelist setting'
      CALL finish  (TRIM(method_name), TRIM(message_text))
    END IF

    CALL nf(nf_get_att_int(ncid, nf_global, 'max_childdom', i_max_childdom))
    IF (i_max_childdom /= max_childdom) THEN
      WRITE(message_text,'(a,i4,a,i4)') &
        & 'max_childdom attribute:', i_max_childdom,', namelist value:',max_childdom
      CALL message  (TRIM(method_name), TRIM(message_text))
      WRITE(message_text,'(a)') &
        & 'Mismatch between "max_childdom" attribute and corresponding namelist setting'
      CALL message  (TRIM(method_name), TRIM(message_text))
    END IF


    !--------------------------------------
    ! get number of cells, edges and vertices
    CALL nf(nf_inq_dimid(ncid, 'edge', dimid))
    CALL nf(nf_inq_dimlen(ncid, dimid, patch_pre%n_patch_edges_g))
    CALL nf(nf_inq_dimid(ncid, 'cell', dimid))
    CALL nf(nf_inq_dimlen(ncid, dimid, patch_pre%n_patch_cells_g))
    CALL nf(nf_inq_dimid(ncid, 'vertex', dimid))
    CALL nf(nf_inq_dimlen(ncid, dimid, patch_pre%n_patch_verts_g))
    CALL nf(nf_inq_dimid(ncid, 'nv', dimid))
    CALL nf(nf_inq_dimlen(ncid, dimid, max_cell_connectivity))
    patch_pre%cells%max_connectivity = max_cell_connectivity
    CALL nf(nf_inq_dimid(ncid, 'ne', dimid))
    CALL nf(nf_inq_dimlen(ncid, dimid, max_verts_connectivity))
    patch_pre%verts%max_connectivity = max_verts_connectivity
    ! dimension of start/end index list fields (always 1 in new patch files, but this
    ! provides backward compatibility)
    CALL nf(nf_inq_dimid(ncid, 'max_chdom', dimid))
    CALL nf(nf_inq_dimlen(ncid, dimid, dim_idxlist))
    IF (dim_idxlist>1) THEN
      WRITE(message_text,'(a)') &
        & 'WARNING: you are using an old grid file with multiple nesting'
      CALL message  (TRIM(method_name), TRIM(message_text))
    ENDIF

    !
    ! calculate and save values for the blocking
    !
    ! ... for the cells
    patch_pre%nblks_c = ( patch_pre%n_patch_cells_g - 1 ) / nproma + 1
    patch_pre%npromz_c = patch_pre%n_patch_cells_g - &
      &                  (patch_pre%nblks_c - 1)*nproma
    patch_pre%alloc_cell_blocks = patch_pre%nblks_c

    ! ... for the edges
    patch_pre%nblks_e = ( patch_pre%n_patch_edges_g - 1 ) / nproma + 1
    patch_pre%npromz_e = patch_pre%n_patch_edges_g - &
      &                  (patch_pre%nblks_e - 1) * nproma

    ! ... for the vertices
    patch_pre%nblks_v = ( patch_pre%n_patch_verts_g - 1 ) / nproma + 1
    patch_pre%npromz_v = patch_pre%n_patch_verts_g - &
      &                  (patch_pre%nblks_v - 1)*nproma

    !
    ! allocate temporary arrays to read in data form the grid/patch generator
    !
    ! integer arrays
    ALLOCATE( array_c_int(patch_pre%n_patch_cells_g,6),  &
      & array_e_int(patch_pre%n_patch_edges_g,6),  &
      & array_v_int(patch_pre%n_patch_verts_g,6),  &
      & stat=ist )
    IF (ist /= success) THEN
      CALL finish (TRIM(method_name), 'allocation for array_[cev]_int failed')
    ENDIF
    ! real arrays
    ALLOCATE( array_c_real(patch_pre%n_patch_cells_g,6),  &
      & array_e_real(patch_pre%n_patch_edges_g,6),  &
      & array_v_real(patch_pre%n_patch_verts_g,6),  &
      & stat=ist )
    IF (ist /= success) THEN
      CALL finish (TRIM(method_name), 'allocation for array_[cev]_real failed')
    ENDIF
    ! integer arrays for index lists
    ALLOCATE( start_idx_c(min_rlcell:max_rlcell,dim_idxlist),  &
      & end_idx_c  (min_rlcell:max_rlcell,dim_idxlist),  &
      & start_idx_e(min_rledge:max_rledge,dim_idxlist),  &
      & end_idx_e  (min_rledge:max_rledge,dim_idxlist),  &
      & start_idx_v(min_rlvert:max_rlvert,dim_idxlist),  &
      & end_idx_v  (min_rlvert:max_rlvert,dim_idxlist),  &
      & stat=ist )

    IF (ist /= success) THEN
      CALL finish (TRIM(method_name), 'allocation for array_[cev]_indlist failed')
    ENDIF

    !
    ! Allocate patch arrays which are read here
    !
    CALL allocate_pre_patch( patch_pre )

    ! patch_pre%cells%start_idx(:,:)
    ! patch_pre%cells%start_blk(:,:)
    ! patch_pre%cells%end_idx(:,:)
    ! patch_pre%cells%end_blk(:,:)
    ! nesting does not work for hex grids
    CALL nf(nf_inq_varid(ncid, 'start_idx_c', varid))
    CALL nf(nf_get_var_int(ncid, varid, start_idx_c(:,:)))
    CALL reshape_idx_list( start_idx_c,                                &
      & patch_pre%cells%start_idx, patch_pre%cells%start_blk )
    CALL reshape_index_list( start_idx_c(:,1),                         &
      & patch_pre%cells%start_index, patch_pre%cells%start_block )
    CALL nf(nf_inq_varid(ncid, 'end_idx_c', varid))
    CALL nf(nf_get_var_int(ncid, varid, end_idx_c(:,:)))
    ! Needed for backward compatibility of old grids
    IF (dim_idxlist > 1) end_idx_c(min_rlcell_int,1) = patch_pre%n_patch_cells_g
    CALL reshape_idx_list( end_idx_c,                                &
        & patch_pre%cells%end_idx, patch_pre%cells%end_blk )
    CALL reshape_index_list( end_idx_c(:,1),                         &
        & patch_pre%cells%end_index, patch_pre%cells%end_block )

    ! patch_pre%edges%start_idx(:,:)
    ! patch_pre%edges%start_blk(:,:)
    ! patch_pre%edges%end_idx(:,:)
    ! patch_pre%edges%end_blk(:,:)
    CALL nf(nf_inq_varid(ncid, 'start_idx_e', varid))
    CALL nf(nf_get_var_int(ncid, varid, start_idx_e(:,:)))
    CALL reshape_idx_list( start_idx_e,                                &
      & patch_pre%edges%start_idx, patch_pre%edges%start_blk )
    CALL reshape_index_list( start_idx_e(:,1),                           &
      & patch_pre%edges%start_index, patch_pre%edges%start_block )
    CALL nf(nf_inq_varid(ncid, 'end_idx_e', varid))
    CALL nf(nf_get_var_int(ncid, varid, end_idx_e(:,:)))
    ! Needed for backward compatibility of old grids
    IF (dim_idxlist > 1) end_idx_e(min_rledge_int,1) = patch_pre%n_patch_edges_g
    CALL reshape_idx_list( end_idx_e,                                &
      & patch_pre%edges%end_idx, patch_pre%edges%end_blk )
    CALL reshape_index_list( end_idx_e(:,1),                           &
      & patch_pre%edges%end_index, patch_pre%edges%end_block )

    ! patch_pre%verts%start_idx(:,:)
    ! patch_pre%verts%start_blk(:,:)
    ! patch_pre%verts%end_idx(:,:)
    ! patch_pre%verts%end_blk(:,:)
    CALL nf(nf_inq_varid(ncid, 'start_idx_v', varid))
    CALL nf(nf_get_var_int(ncid, varid, start_idx_v(:,:)))
    CALL reshape_idx_list( start_idx_v,                                &
      & patch_pre%verts%start_idx, patch_pre%verts%start_blk )
    CALL reshape_index_list( start_idx_v(:,1),                           &
      & patch_pre%verts%start_index, patch_pre%verts%start_block )
    CALL nf(nf_inq_varid(ncid, 'end_idx_v', varid))
    CALL nf(nf_get_var_int(ncid, varid, end_idx_v(:,:)))
    ! Needed for backward compatibility of old grids
    IF (dim_idxlist > 1) end_idx_v(min_rlvert_int,1) = patch_pre%n_patch_verts_g
    CALL reshape_idx_list( end_idx_v,                                &
      & patch_pre%verts%end_idx, patch_pre%verts%end_blk )
    CALL reshape_index_list( end_idx_v(:,1),                           &
      & patch_pre%verts%end_index, patch_pre%verts%end_block )

    ! patch_pre%cells%phys_id(:,:)
    CALL nf(nf_inq_varid(ncid, 'phys_cell_id', varid))
    CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1)))
    CALL reshape_int( array_c_int(:,1), patch_pre%nblks_c, patch_pre%npromz_c, &
      & patch_pre%cells%phys_id(:,:) )

    ! patch_pre%cells%neighbor_idx(:,:,:)
    ! patch_pre%cells%neighbor_blk(:,:,:)
    CALL nf(nf_inq_varid(ncid, 'neighbor_cell_index', varid))
    CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1:max_cell_connectivity)))
    DO ji = 1, max_cell_connectivity
      CALL reshape_idx( array_c_int(:,ji), patch_pre%nblks_c, &
        & patch_pre%npromz_c,  &
        & patch_pre%cells%neighbor_idx(:,:,ji),  &
        & patch_pre%cells%neighbor_blk(:,:,ji) )
    END DO

    ! patch_pre%cells%edge_idx(:,:,:)
    ! patch_pre%cells%edge_blk(:,:,:)
    CALL nf(nf_inq_varid(ncid, 'edge_of_cell', varid))
    CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1:max_cell_connectivity)))
    DO ji = 1, max_cell_connectivity
      CALL reshape_idx( array_c_int(:,ji), patch_pre%nblks_c, &
        & patch_pre%npromz_c,  &
        & patch_pre%cells%edge_idx(:,:,ji),  &
        & patch_pre%cells%edge_blk(:,:,ji) )
    END DO

    ! patch_pre%cells%vertex_idx(:,:,:)
    ! patch_pre%cells%vertex_blk(:,:,:)
    CALL nf(nf_inq_varid(ncid, 'vertex_of_cell', varid))
    CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1:max_cell_connectivity)))
    DO ji = 1, max_cell_connectivity
      CALL reshape_idx( array_c_int(:,ji), patch_pre%nblks_c, &
        & patch_pre%npromz_c,  &
        & patch_pre%cells%vertex_idx(:,:,ji),  &
        & patch_pre%cells%vertex_blk(:,:,ji) )
    END DO

    ! patch_pre%cells%center(:,:)%lon
    CALL nf(nf_inq_varid(ncid, 'lon_cell_centre', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_c_real(:,1)))
    CALL reshape_real( array_c_real(:,1), patch_pre%nblks_c, &
      & patch_pre%npromz_c, patch_pre%cells%center(:,:)%lon )

    ! patch_pre%cells%center(:,:)%lat
    CALL nf(nf_inq_varid(ncid, 'lat_cell_centre', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_c_real(:,1)))
    CALL reshape_real( array_c_real(:,1), patch_pre%nblks_c, &
      & patch_pre%npromz_c, patch_pre%cells%center(:,:)%lat )

    ! patch_pre%verts%vertex(:,:)%lon
    CALL nf(nf_inq_varid(ncid, 'longitude_vertices', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_v_real(:,1)))
    CALL reshape_real( array_v_real(:,1), patch_pre%nblks_v, &
      & patch_pre%npromz_v, patch_pre%verts%vertex(:,:)%lon )

    ! patch_pre%verts%vertex(:,:)%lat
    CALL nf(nf_inq_varid(ncid, 'latitude_vertices', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_v_real(:,1)))
    CALL reshape_real( array_v_real(:,1), patch_pre%nblks_v, &
      & patch_pre%npromz_v, patch_pre%verts%vertex(:,:)%lat )

    !------------------------------------------
    ! nesting/lateral boundary indexes
    IF (max_cell_connectivity == 3) THEN ! triangular grid

      CALL nf(nf_inq_varid(ncid, 'parent_cell_index', varid))
      ! patch_pre%cells%parent_idx(:,:)
      ! patch_pre%cells%parent_blk(:,:)
      CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1)))
      CALL reshape_idx( array_c_int(:,1), patch_pre%nblks_c, &
        & patch_pre%npromz_c,  &
        & patch_pre%cells%parent_idx(:,:),  &
        & patch_pre%cells%parent_blk(:,:) )
      ! patch_pre%cells%child_idx(:,:,:)
      ! patch_pre%cells%child_blk(:,:,:)
      CALL nf(nf_inq_varid(ncid, 'child_cell_index', varid))
      CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1:4)))
      DO ji = 1, 4
        CALL reshape_idx( array_c_int(:,ji), patch_pre%nblks_c, &
          & patch_pre%npromz_c,  &
          & patch_pre%cells%child_idx(:,:,ji),  &
          & patch_pre%cells%child_blk(:,:,ji) )
      END DO
      ! patch_pre%cells%child_id(:,:)
      CALL nf(nf_inq_varid(ncid, 'child_cell_id', varid))
      CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1)))

      ! Preparation: In limited-area mode, check if child domain ID's read
      ! from the grid files need to be shifted
      IF (ig == 1 .AND. l_limited_area .AND. patch_pre%n_childdom>0) THEN
        ! domain ID of first nested domain should be 2
!        ishift_child_id = array_c_int(start_idx_c(grf_bdyintp_start_c,1),1) - 2
        ishift_child_id = MINVAL(array_c_int(:,1),MASK=array_c_int(:,1)>0) - 2
        WRITE(message_text,'(a,i4)') 'Limited-area mode: child cell IDs are shifted by ',ishift_child_id
        CALL message ('', TRIM(message_text))
      ENDIF

      IF(ishift_child_id /= 0 .AND. patch_pre%n_childdom>0) THEN
 !       DO jc = start_idx_c(grf_bdyintp_start_c,1), end_idx_c(min_rlcell,patch_pre%n_childdom)
 !         array_c_int(jc,1) = array_c_int(jc,1) - ishift_child_id
 !       ENDDO
        WHERE (array_c_int(:,1) > 0) array_c_int(:,1) = array_c_int(:,1) - ishift_child_id
      ENDIF

      CALL reshape_int( array_c_int(:,1), patch_pre%nblks_c, &
        & patch_pre%npromz_c, patch_pre%cells%child_id(:,:) )

    ELSE
      CALL message ('read_patch',&
        & 'nesting incompatible with non-triangular grid')
    ENDIF

    ! patch_pre%cells%refin_ctrl(:,:)
    CALL nf(nf_inq_varid(ncid, 'refin_c_ctrl', varid))
    CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1)))
    CALL reshape_int( array_c_int(:,1), patch_pre%nblks_c, &
      & patch_pre%npromz_c, patch_pre%cells%refin_ctrl(:,:) )

    ! patch_pre%edges%parent_idx(:,:)
    ! patch_pre%edges%parent_blk(:,:)
    CALL nf(nf_inq_varid(ncid, 'parent_edge_index', varid))
    CALL nf(nf_get_var_int(ncid, varid, array_e_int(:,1)))
    CALL reshape_idx( array_e_int(:,1), patch_pre%nblks_e, &
      & patch_pre%npromz_e,  &
      & patch_pre%edges%parent_idx(:,:),  &
      & patch_pre%edges%parent_blk(:,:) )

    ! patch_pre%edges%child_idx(:,:,:)
    ! patch_pre%edges%child_blk(:,:,:)
    CALL nf(nf_inq_varid(ncid, 'child_edge_index', varid))
    CALL nf(nf_get_var_int(ncid, varid, array_e_int(:,1:4)))

    ! First ensure that child edge indices are all positive;
    ! if there are negative values, grid files are too old
    IF(ANY(array_e_int(:,1:4)<0)) THEN
      CALL finish (TRIM(method_name), &
        & 'negative child edge indices detected - patch files are too old')
    ENDIF

    DO ji = 1, 4
      CALL reshape_idx( array_e_int(:,ji), patch_pre%nblks_e, &
        & patch_pre%npromz_e, &
        & patch_pre%edges%child_idx(:,:,ji),  &
        & patch_pre%edges%child_blk(:,:,ji) )
    END DO

    ! patch_pre%edges%child_id(:,:)
    CALL nf(nf_inq_varid(ncid, 'child_edge_id', varid))
    CALL nf(nf_get_var_int(ncid, varid, array_e_int(:,1)))

    IF(ishift_child_id /= 0 .AND. patch_pre%n_childdom>0) THEN
 !     DO je = start_idx_e(grf_bdyintp_start_e,1), end_idx_e(min_rledge,patch_pre%n_childdom)
 !       array_e_int(je,1) = array_e_int(je,1) - ishift_child_id
 !     ENDDO
      WHERE (array_e_int(:,1) > 0) array_e_int(:,1) = array_e_int(:,1) - ishift_child_id
    ENDIF

    CALL reshape_int( array_e_int(:,1), patch_pre%nblks_e, patch_pre%npromz_e, &
      & patch_pre%edges%child_id(:,:) )

    ! patch_pre%edges%refin_ctrl(:,:)
    CALL nf(nf_inq_varid(ncid, 'refin_e_ctrl', varid))
    CALL nf(nf_get_var_int(ncid, varid, array_e_int(:,1)))
    CALL reshape_int( array_e_int(:,1), patch_pre%nblks_e, patch_pre%npromz_e, &
      & patch_pre%edges%refin_ctrl(:,:) )

    ! patch_pre%verts%refin_ctrl(:,:)
    CALL nf(nf_inq_varid(ncid, 'refin_v_ctrl', varid))
    CALL nf(nf_get_var_int(ncid, varid, array_v_int(:,1)))
    CALL reshape_int( array_v_int(:,1), patch_pre%nblks_v, patch_pre%npromz_v, &
      & patch_pre%verts%refin_ctrl(:,:) )

    ! BEGIN NEW SUBDIV
    CALL nf(nf_inq_varid(ncid, 'cells_of_vertex', varid))
    CALL nf(nf_get_var_int(ncid, varid, array_v_int(:,1:max_verts_connectivity)))
    ! eliminate indices < 0, this should not happen but some older grid files
    ! seem to contain such indices
    WHERE(array_v_int < 0) array_v_int = 0
    ! account for dummy cells arising in case of a pentagon
    ! Fill dummy cell with existing index to simplify do loops
    ! Note, however, that related multiplication factors must be zero
    CALL move_dummies_to_end(array_v_int, patch_pre%n_patch_verts_g, &
         max_verts_connectivity, use_duplicated_connectivity)
    DO ji = 1, max_verts_connectivity
      CALL reshape_idx(array_v_int(:,ji), patch_pre%nblks_v, &
        & patch_pre%npromz_v,  &
        & patch_pre%verts%cell_idx(:,:,ji),  &
        & patch_pre%verts%cell_blk(:,:,ji) )
    END DO
    !
    ! Set verts%num_edges (in array_v_int(:,1))
    DO ji = 1, patch_pre%n_patch_verts_g
      array_v_int(ji,1) = COUNT(array_v_int(ji, 1:max_verts_connectivity) /= 0)
    END DO
    CALL reshape_int( array_v_int(:,1), patch_pre%nblks_v, patch_pre%npromz_v, &
         & patch_pre%verts%num_edges(:,:) )

    ! patch_pre%edges%cell_idx(:,:,:)
    ! patch_pre%edges%cell_blk(:,:,:)
    CALL nf(nf_inq_varid(ncid, 'adjacent_cell_of_edge', varid))
    CALL nf(nf_get_var_int(ncid, varid, array_e_int(:,1:2)))
    WHERE(array_e_int(:, 1:2) < 0) array_e_int(:, 1:2) = 0
    DO ji = 1, 2
      CALL reshape_idx( array_e_int(:,ji), patch_pre%nblks_e, &
        & patch_pre%npromz_e, &
        & patch_pre%edges%cell_idx(:,:,ji),  &
        & patch_pre%edges%cell_blk(:,:,ji) )
    END DO

    ! p_p%edges%vertex_idx(:,:,:)
    ! p_p%edges%vertex_blk(:,:,:)
    CALL nf(nf_inq_varid(ncid, 'edge_vertices', varid))
    CALL nf(nf_get_var_int(ncid, varid, array_e_int(:,1:2)))
    DO ji = 1, 2
      CALL reshape_idx( array_e_int(:,ji), patch_pre%nblks_e, &
        & patch_pre%npromz_e, &
        & patch_pre%edges%vertex_idx(:,:,ji),  &
        & patch_pre%edges%vertex_blk(:,:,ji) )
    END DO

    ! END NEW SUBDIV


    CALL nf(nf_close(ncid))


    !
    ! deallocate temporary arrays to read in data form the grid/patch generator
    !
    ! integer arrays
    DEALLOCATE( array_c_int, array_e_int, array_v_int,  &
      & stat=ist )
    IF (ist /= success) THEN
      CALL finish (TRIM(method_name), 'deallocation for array_[cev]_int failed')
    ENDIF
    ! real arrays
    DEALLOCATE( array_c_real, array_e_real, array_v_real,  &
      & stat=ist )
    IF (ist /= success) THEN
      CALL finish (TRIM(method_name), 'deallocation for array_[cev]_real failed')
    ENDIF
    ! index lists arrays
    DEALLOCATE( start_idx_c, end_idx_c, start_idx_e, end_idx_e, start_idx_v, end_idx_v, &
      & stat=ist )
    IF (ist /= success) THEN
      CALL finish (TRIM(method_name), 'deallocation for array_[cev]_indlist failed')
    ENDIF

    !----------------------------------------------------------------------------------
    ! compute cells%num_edges
    ! works for general unstructured grid
    DO ibc = 1, patch_pre%nblks_c
      block_size = nproma
      IF (ibc == patch_pre%nblks_c) block_size = patch_pre%npromz_c
      DO ilc=1, block_size

        patch_pre%cells%num_edges(ilc,ibc) = 0
        DO ji = 1, max_cell_connectivity
          IF ( patch_pre%cells%edge_idx(ilc,ibc,ji) > 0 ) &
            & patch_pre%cells%num_edges(ilc,ibc) = &
            & patch_pre%cells%num_edges(ilc,ibc) + 1
        END DO

      END DO
    END DO

    !----------------------------------------------------------------------------------
    ! account for pentagons in the hex gird,
    ! Note: this needs to be checked
    IF (max_cell_connectivity == 6 .AND. use_duplicated_connectivity) THEN
      DO ibc = 1, patch_pre%nblks_c
        block_size = nproma
        IF (ibc == patch_pre%nblks_c) block_size = patch_pre%npromz_c
        DO ilc=1, block_size

          DO ji = 1, 6

            ! account for dummy cells arising in case of a pentagon
            IF ( patch_pre%cells%neighbor_idx(ilc,ibc,ji) == 0 ) THEN
              IF ( ji /= 6 ) THEN
                patch_pre%cells%neighbor_idx(ilc,ibc,ji) =  &
                  & patch_pre%cells%neighbor_idx(ilc,ibc,6)
                patch_pre%cells%neighbor_blk(ilc,ibc,ji) =  &
                  & patch_pre%cells%neighbor_blk(ilc,ibc,6)
                ! this should not happen
  !               CALL finish(method_name, "cells%neighbor_idx=0 not at the end")
              END IF
              ! Fill dummy neighbor with an existing index to simplify do loops
              ! Note, however, that related multiplication factors must be zero
              patch_pre%cells%neighbor_idx(ilc,ibc,6) = patch_pre%cells%neighbor_idx(ilc,ibc,5)
              patch_pre%cells%neighbor_blk(ilc,ibc,6) = patch_pre%cells%neighbor_blk(ilc,ibc,5)
            END IF

            ! account for dummy verts arising in case of a pentagon
            IF ( patch_pre%cells%vertex_idx(ilc,ibc,ji) == 0 ) THEN
              IF ( ji /= 6 ) THEN
                patch_pre%cells%vertex_idx(ilc,ibc,ji) =  &
                  & patch_pre%cells%vertex_idx(ilc,ibc,6)
                patch_pre%cells%vertex_blk(ilc,ibc,ji) =  &
                  & patch_pre%cells%vertex_blk(ilc,ibc,6)
              END IF
              ! Fill dummy edge with existing index to simplify do loops
              ! Note, however, that related multiplication factors must be zero
              patch_pre%cells%vertex_idx(ilc,ibc,6) = patch_pre%cells%vertex_idx(ilc,ibc,5)
              patch_pre%cells%vertex_blk(ilc,ibc,6) = patch_pre%cells%vertex_blk(ilc,ibc,5)
            END IF

            ! account for dummy edges arising in case of a pentagon
            IF ( patch_pre%cells%edge_idx(ilc,ibc,ji) == 0 ) THEN
              IF ( ji /= 6 ) THEN
                patch_pre%cells%edge_idx(ilc,ibc,ji) =  &
                  & patch_pre%cells%edge_idx(ilc,ibc,6)
                patch_pre%cells%edge_blk(ilc,ibc,ji) =  &
                  & patch_pre%cells%edge_blk(ilc,ibc,6)
              END IF
              ! Fill dummy edge with existing index to simplify do loops
              ! Note, however, that related multiplication factors must be zero
              patch_pre%cells%edge_idx(ilc,ibc,6) = patch_pre%cells%edge_idx(ilc,ibc,5)
              patch_pre%cells%edge_blk(ilc,ibc,6) = patch_pre%cells%edge_blk(ilc,ibc,5)
            END IF

          END DO  ! ji = 1, 6

        END DO  ! ilc=1, block_size
      END DO ! blocks
    ENDIF

    CALL message (TRIM(method_name), 'read_patches finished')

  END SUBROUTINE read_pre_patch
  !-------------------------------------------------------------------------


  !-------------------------------------------------------------------------
  !> Reads the remaining patch information into the divided patch
  SUBROUTINE read_remaining_patch( ig, patch, n_lp, id_lp )

    INTEGER,       INTENT(in)    ::  ig       ! domain ID
    TYPE(t_patch), INTENT(inout), TARGET ::  patch  ! patch data structure
    INTEGER,       INTENT(in)    ::  n_lp     ! Number of local parents on the same level
    INTEGER,       INTENT(in)    ::  id_lp(:) ! IDs of local parents on the same level

    INTEGER, POINTER :: &
      & array_c_int(:,:),  &  ! temporary arrays to read in integer values
      & array_e_int(:,:),  &
      & array_v_int(:,:)

    REAL(wp), POINTER :: &
      & array_c_real(:,:), &  ! temporary arrays to read in real values
      & array_e_real(:,:), &
      & array_v_real(:,:)

    ! status variable
    INTEGER :: ist

    INTEGER :: ncid, dimid, varid
    INTEGER :: ip, ji, jv
    INTEGER :: max_cell_connectivity, max_verts_connectivity

    INTEGER :: return_status

    TYPE(t_patch), POINTER :: p_p, patch0

!    REAL(wp), POINTER :: tmp_check_array(:,:)
!    REAL(wp) :: max_diff

    CHARACTER(LEN=*), PARAMETER :: method_name = 'mo_model_domimp_patches/read_remaining_patch'
    !-----------------------------------------------------------------------

    CALL message ('mo_model_domimp_patches:read_remaining_patch', &
      & 'Read gridmap file '//TRIM(patch%grid_filename))

    CALL nf(nf_open(TRIM(patch%grid_filename), nf_nowrite, ncid))

    !-------------------------------------------------
    !
    ! allocate temporary arrays to read in data from the grid/patch generator
    !
    ! integer arrays
    ALLOCATE( array_c_int(patch%n_patch_cells_g,6),  &
      & array_e_int(patch%n_patch_edges_g,6),  &
      & array_v_int(patch%n_patch_verts_g,6),  &
      & stat=ist )
    IF (ist /= success) THEN
      CALL finish ('mo_model_domain_import:read_patch',  &
        & 'allocation for array_[cev]_int failed')
    ENDIF
    ! real arrays
    ALLOCATE( array_c_real(patch%n_patch_cells_g,6),  &
      & array_e_real(patch%n_patch_edges_g,6),  &
      & array_v_real(patch%n_patch_verts_g,6),  &
      & stat=ist )
    IF (ist /= success) THEN
      CALL finish ('mo_model_domain_import:read_patch',  &
        & 'allocation for array_[cev]_real failed')
    ENDIF

    !--------------------------------------------------
    CALL nf(nf_inq_dimid(ncid, 'nv', dimid))
    CALL nf(nf_inq_dimlen(ncid, dimid, max_cell_connectivity))
    CALL nf(nf_inq_dimid(ncid, 'ne', dimid))
    CALL nf(nf_inq_dimlen(ncid, dimid, max_verts_connectivity))
    !--------------------------------------------------
    patch%boundary_depth_index = 0
#ifndef __NO_ICON_ATMO__
    patch%boundary_depth_index = nudge_zone_width
    return_status = nf_inq_attid(ncid, nf_global, 'boundary_depth_index', varid)
    ! write(0,*) get_my_global_mpi_id(), " nf_inq_attid return_status=", return_status
    IF (return_status == nf_noerr) THEN
       CALL nf(nf_get_att_int(ncid, nf_global, 'boundary_depth_index', patch%boundary_depth_index))
       IF (nudge_zone_width < 0) THEN
         nudge_zone_width = patch%boundary_depth_index - 4
       ENDIF
!       IF ( nudge_zone_width > patch%boundary_depth_index - 4) THEN
!         CALL finish ('mo_model_domain_import:read_patch',  &
!           & 'nudge_zone_width > patch%boundary_depth_index - 4')
!       ENDIF
    ENDIF
#endif

    CALL nf(nf_inq_varid(ncid, 'phys_cell_id', varid))
    CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1)))
    ! 'phys_cell_id' seems not to be set for patch 0 and 1, it is always ig in this case
    IF(ig<=1) array_c_int(:,1) = ig
    ! shift physical IDs for limited-area mode
    IF (ig > 1 .AND. ishift_child_id > 0) array_c_int(:,1) = array_c_int(:,1) - ishift_child_id
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_int( array_c_int(:,1), p_p%n_patch_cells, p_p%cells%decomp_info%glb_index,  &
        & p_p%cells%phys_id(:,:) )
    ENDDO

    ! p_p%cells%edge_orientation(:,:,:)
    CALL nf(nf_inq_varid(ncid, 'orientation_of_normal', varid))
    CALL nf(nf_get_var_int(ncid, varid, array_c_int(:,1:max_cell_connectivity)))

    DO ji = 1, max_cell_connectivity
      DO ip = 0, n_lp
        p_p => get_patch_ptr(patch, id_lp, ip)
        CALL divide_real( REAL(array_c_int(:,ji),wp),            &
          & p_p%n_patch_cells, p_p%cells%decomp_info%glb_index,     &
          & p_p%cells%edge_orientation(:,:,ji) )
      ENDDO
    END DO

    ! p_p%cells%area(:,:)
    CALL nf(nf_inq_varid(ncid, 'cell_area_p', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_c_real(:,1)))
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_real( array_c_real(:,1), p_p%n_patch_cells, p_p%cells%decomp_info%glb_index, &
        & p_p%cells%area(:,:) )
    ENDDO


    ! p_p%edges%phys_id(:,:)
    CALL nf(nf_inq_varid(ncid, 'phys_edge_id', varid))
    CALL nf(nf_get_var_int(ncid, varid, array_e_int(:,1)))
    ! 'phys_edge_id' seems not to be set for patch 0 and 1, it is always ig in this case
    IF(ig<=1) array_e_int(:,1) = ig
    ! shift physical IDs for limited-area mode
    IF (ig > 1 .AND. ishift_child_id > 0) array_e_int(:,1) = array_e_int(:,1) - ishift_child_id
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_int( array_e_int(:,1), p_p%n_patch_edges, p_p%edges%decomp_info%glb_index,  &
        & p_p%edges%phys_id(:,:) )
    ENDDO

    ! p_p%edges%cell_idx(:,:,:)
    ! p_p%edges%cell_blk(:,:,:)
    CALL nf(nf_inq_varid(ncid, 'adjacent_cell_of_edge', varid))
    CALL nf(nf_get_var_int(ncid, varid, array_e_int(:,1:2)))
    DO ji = 1, 2
      DO ip = 0, n_lp
        p_p => get_patch_ptr(patch, id_lp, ip)
        CALL divide_idx( array_e_int(:,ji), p_p%n_patch_edges, &
          & p_p%edges%decomp_info%glb_index, p_p%cells%decomp_info%glb2loc_index, &
          & p_p%edges%cell_idx(:,:,ji), p_p%edges%cell_blk(:,:,ji) )
      END DO
    END DO

    ! p_p%edges%vertex_idx(:,:,:)
    ! p_p%edges%vertex_blk(:,:,:)
    CALL nf(nf_inq_varid(ncid, 'edge_vertices', varid))
    CALL nf(nf_get_var_int(ncid, varid, array_e_int(:,1:2)))
    DO ji = 1, 2
      DO ip = 0, n_lp
        p_p => get_patch_ptr(patch, id_lp, ip)
        CALL divide_idx( array_e_int(:,ji), p_p%n_patch_edges, &
          & p_p%edges%decomp_info%glb_index, p_p%verts%decomp_info%glb2loc_index, &
          & p_p%edges%vertex_idx(:,:,ji), p_p%edges%vertex_blk(:,:,ji) )
      END DO
    END DO

    ! p_p%edges%system_orientation(:,:)
    CALL nf(nf_inq_varid(ncid, 'edge_system_orientation', varid))
    CALL nf(nf_get_var_int(ncid, varid, array_e_int(:,1)))
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_real( REAL(array_e_int(:,1),wp),            &
        & p_p%n_patch_edges, p_p%edges%decomp_info%glb_index,    &
        & p_p%edges%system_orientation(:,:) )
    ENDDO

    ! p_p%edges%center(:,:)%lon
    CALL nf(nf_inq_varid(ncid, 'lon_edge_centre', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_real( array_e_real(:,1), p_p%n_patch_edges, p_p%edges%decomp_info%glb_index,  &
        & p_p%edges%center(:,:)%lon )
    ENDDO

    ! p_p%edges%center(:,:)%lat
    CALL nf(nf_inq_varid(ncid, 'lat_edge_centre', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_real( array_e_real(:,1), p_p%n_patch_edges, p_p%edges%decomp_info%glb_index,  &
        & p_p%edges%center(:,:)%lat )
    ENDDO

    ! p_p%edges%primal_normal(:,:)%v1
    CALL nf(nf_inq_varid(ncid, 'zonal_normal_primal_edge', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_real( array_e_real(:,1), p_p%n_patch_edges, p_p%edges%decomp_info%glb_index,  &
        & p_p%edges%primal_normal(:,:)%v1 )
    ENDDO

    ! p_p%edges%primal_normal(:,:)%v2
    CALL nf(nf_inq_varid(ncid, 'meridional_normal_primal_edge', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_real( array_e_real(:,1), p_p%n_patch_edges, p_p%edges%decomp_info%glb_index,  &
        & p_p%edges%primal_normal(:,:)%v2 )
    ENDDO

    ! p_p%edges%dual_normal(:,:)%v1
    CALL nf(nf_inq_varid(ncid, 'zonal_normal_dual_edge', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_real( array_e_real(:,1), p_p%n_patch_edges, p_p%edges%decomp_info%glb_index,  &
        & p_p%edges%dual_normal(:,:)%v1 )
    ENDDO

    ! p_p%edges%dual_normal(:,:)%v2
    CALL nf(nf_inq_varid(ncid, 'meridional_normal_dual_edge', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_real( array_e_real(:,1), p_p%n_patch_edges, p_p%edges%decomp_info%glb_index,  &
        & p_p%edges%dual_normal(:,:)%v2 )
    ENDDO

    ! p_p%edges%primal_edge_length(:,:)
    CALL nf(nf_inq_varid(ncid, 'edge_length', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_real( array_e_real(:,1), p_p%n_patch_edges, p_p%edges%decomp_info%glb_index,  &
        & p_p%edges%primal_edge_length(:,:) )
    ENDDO

    ! p_p%edges%dual_edge_length(:,:)
    CALL nf(nf_inq_varid(ncid, 'dual_edge_length', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_real( array_e_real(:,1), p_p%n_patch_edges, p_p%edges%decomp_info%glb_index,  &
        & p_p%edges%dual_edge_length(:,:) )
    ENDDO

    ! p_p%edges%edge_vert_length(:,:)
    CALL nf(nf_inq_varid(ncid, 'edge_vert_distance', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1:2)))
    DO ji = 1, 2
      DO ip = 0, n_lp
        p_p => get_patch_ptr(patch, id_lp, ip)
        CALL divide_real( array_e_real(:,ji), p_p%n_patch_edges, p_p%edges%decomp_info%glb_index, &
          & p_p%edges%edge_vert_length(:,:,ji) )
      ENDDO
    ENDDO

    ! p_p%edges%edge_cell_length(:,:)
    CALL nf(nf_inq_varid(ncid, 'edge_cell_distance', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1:2)))
    DO ji = 1, 2
      DO ip = 0, n_lp
        p_p => get_patch_ptr(patch, id_lp, ip)
        CALL divide_real( array_e_real(:,ji), p_p%n_patch_edges, p_p%edges%decomp_info%glb_index, &
          & p_p%edges%edge_cell_length(:,:,ji) )
      ENDDO
    ENDDO

    ! p_p%verts%neighbor_idx(:,:,:)
    ! p_p%verts%neighbor_blk(:,:,:)
    CALL nf(nf_inq_varid(ncid, 'vertices_of_vertex', varid))
    CALL nf(nf_get_var_int(ncid, varid, array_v_int(:,1:max_verts_connectivity)))
    DO ji = 1, max_verts_connectivity
      DO ip = 0, n_lp
        p_p => get_patch_ptr(patch, id_lp, ip)
        CALL divide_idx( array_v_int(:,ji), p_p%n_patch_verts, &
          & p_p%verts%decomp_info%glb_index, p_p%verts%decomp_info%glb2loc_index, &
          & p_p%verts%neighbor_idx(:,:,ji), p_p%verts%neighbor_blk(:,:,ji) )
      END DO
    END DO

    ! p_p%verts%cell_idx(:,:,:)
    ! p_p%verts%cell_blk(:,:,:)
    CALL nf(nf_inq_varid(ncid, 'cells_of_vertex', varid))
    CALL nf(nf_get_var_int(ncid, varid, array_v_int(:,1:max_verts_connectivity)))
    !
    ! account for dummy cells arising in case of a pentagon
    ! Fill dummy cell with existing index to simplify do loops
    ! Note, however, that related multiplication factors must be zero
    CALL move_dummies_to_end(array_v_int, patch%n_patch_verts, max_verts_connectivity, use_duplicated_connectivity)
    !
    DO ji = 1, max_verts_connectivity
      DO ip = 0, n_lp
        p_p => get_patch_ptr(patch, id_lp, ip)
        CALL divide_idx( array_v_int(:,ji), p_p%n_patch_verts, &
          & p_p%verts%decomp_info%glb_index, p_p%cells%decomp_info%glb2loc_index, &
          & p_p%verts%cell_idx(:,:,ji), p_p%verts%cell_blk(:,:,ji) )
      END DO
    END DO

    ! p_p%verts%edge_idx(:,:,:)
    ! p_p%verts%edge_blk(:,:,:)
    CALL nf(nf_inq_varid(ncid, 'edges_of_vertex', varid))
    CALL nf(nf_get_var_int(ncid, varid, array_v_int(:,1:max_verts_connectivity)))

    ! account for dummy cells arising in case of a pentagon
    ! Fill dummy cell with existing index to simplify do loops
    ! Note, however, that related multiplication factors must be zero
    CALL move_dummies_to_end(array_v_int, patch%n_patch_verts, max_verts_connectivity, use_duplicated_connectivity)
    !
    DO ji = 1, max_verts_connectivity
      DO ip = 0, n_lp
        p_p => get_patch_ptr(patch, id_lp, ip)
        CALL divide_idx( array_v_int(:,ji), p_p%n_patch_verts, &
          & p_p%verts%decomp_info%glb_index, p_p%edges%decomp_info%glb2loc_index, &
          & p_p%verts%edge_idx(:,:,ji), p_p%verts%edge_blk(:,:,ji) )
      END DO
    END DO

    !
    ! Set verts%num_edges (in array_v_int(:,1))
    IF (use_duplicated_connectivity) THEN
      DO jv = 1, p_p%n_patch_verts_g
        array_v_int(jv,1) &
             = COUNT(array_v_int(jv, 1:max_verts_connectivity) &
             /= array_v_int(jv, max_verts_connectivity)) + 1
      END DO
    ELSE
      DO jv = 1, p_p%n_patch_verts_g
        array_v_int(jv,1) &
             = COUNT(array_v_int(jv, 1:max_verts_connectivity) /= 0)
      END DO
    END IF

    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_int( array_v_int(:,1), p_p%n_patch_verts, p_p%verts%decomp_info%glb_index,  &
        & p_p%verts%num_edges(:,:) )
    ENDDO

    ! p_p%verts%edge_orientation(:,:,:)
    CALL nf(nf_inq_varid(ncid, 'edge_orientation', varid))
    CALL nf(nf_get_var_int(ncid, varid, array_v_int(:,1:max_verts_connectivity)))
    ! move dummy edges to end and set edge orientation to zero
    CALL move_dummies_to_end(array_v_int, patch%n_patch_verts, max_verts_connectivity, .FALSE.)
    DO ji = 1, max_verts_connectivity
      DO ip = 0, n_lp
        p_p => get_patch_ptr(patch, id_lp, ip)
        CALL divide_real( REAL(array_v_int(:,ji),wp),            &
          & p_p%n_patch_verts, p_p%verts%decomp_info%glb_index,     &
          & p_p%verts%edge_orientation(:,:,ji) )
      END DO
    END DO

    ! p_p%verts%dual_area(:,:)
    CALL nf(nf_inq_varid(ncid, 'dual_area_p', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_v_real(:,1)))
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_real( array_v_real(:,1), p_p%n_patch_verts, p_p%verts%decomp_info%glb_index, &
        & p_p%verts%dual_area(:,:) )
    ENDDO

    !-------------------------------------------------
    ! read geometry parameters
    patch0 => get_patch_ptr(patch, id_lp, 0)
    return_status = parallel_read_geometry_info(ncid, patch0%geometry_info)
    IF (return_status /= 0 ) THEN
      ! the information was missing from the file (ie old grids)
      ! calclulate basic settings
!       CALL finish("","did not read from file")
      CALL set_missing_geometry_info(patch0)
    ENDIF
    CALL set_grid_geometry_derived_info(patch0%geometry_info)

    DO ip = 1, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL copy_grid_geometry_info(from_geometry_info = patch0%geometry_info, &
        &                            to_geometry_info = p_p%geometry_info)
!       write(0,*) "-------------------------------------------------------"
!       write(0,*) "area, char_lenght=", p_p%geometry_info%mean_cell_area, &
!         & p_p%geometry_info%mean_characteristic_length
!       write(0,*) "-------------------------------------------------------"
    ENDDO
    !---------------------------------------------------
    ! read cartesian positions
    return_status = read_cartesian_positions(ncid, ig, patch, n_lp, id_lp, &
      & array_c_real, array_e_real, array_v_real)
    IF (return_status /= 0) & ! this is an old grid
      CALL calculate_cartesian_positions(ig, patch, n_lp, id_lp)
    !-------------------------------------------------


    CALL nf(nf_close(ncid))
    !-------------------------------------------------
     !Check for plane_torus case
    IF(p_p%geometry_info%geometry_type == planar_torus_geometry .AND. .NOT. is_plane_torus) THEN
      CALL message(TRIM(method_name), &
        & "Grid is plane torus: turning on is_plane_torus automatically")
      is_plane_torus = .TRUE.
    END IF

    IF(p_p%geometry_info%geometry_type /= planar_torus_geometry .AND. is_plane_torus) &
      CALL finish(TRIM(method_name),"Input grid is NOT plane torus, Stopping")
    !-------------------------------------------------


    !
    ! deallocate temporary arrays to read in data from the grid/patch generator
    !
    ! integer arrays
    DEALLOCATE( array_c_int, array_e_int, array_v_int,  &
      & stat=ist )
    IF (ist /= success) THEN
      CALL finish ('mo_model_domain_import:read_remaining_patch',  &
        & 'deallocation for array_[cev]_int failed')
    ENDIF
    ! real arrays
    DEALLOCATE( array_c_real, array_e_real, array_v_real,  &
      & stat=ist )
    IF (ist /= success) THEN
      CALL finish ('mo_model_domain_import:read_remaining_patch',  &
        & 'deallocation for array_[cev]_real failed')
    ENDIF

    CALL message ('mo_model_domimp_patches:read_remaining_patch', 'read finished')

  END SUBROUTINE read_remaining_patch
  !-------------------------------------------------------------------------

  !-------------------------------------------------------------------------
  ! Checks for the pentagon case and moves dummy cells to end.
  ! The dummy entry is either set to 0 or duplicated from the last one
  SUBROUTINE move_dummies_to_end(array, array_size, max_connectivity, duplicate)

    INTEGER, INTENT(inout) :: array(:,:)
    INTEGER, INTENT(in) :: array_size, max_connectivity
    LOGICAL, INTENT(in) :: duplicate

    INTEGER :: i, j, je, first_zero, last_no_zero, icount, listlen
    INTEGER, ALLOCATABLE :: indlist(:)
    CHARACTER(LEN=*), PARAMETER :: method_name = 'mo_model_domimp_patches:move_dummies_to_end'

    IF (array_size > UBOUND(array, 1) ) &
         & CALL finish(method_name, "array_size > UBOUND(array, 1)" )

    ! GZ: this routine is called before executing the domain decomposition; thus, all grid points must be processed
    ! To save computing time, we first create an index list of grid points with dummy indices

    listlen = MAX(12, UBOUND(array, 1)/25)  ! this is usually sufficient, except for small limited-area domains
    ALLOCATE (indlist(listlen))
    icount = 0
    DO j = 1,  UBOUND(array, 1)
      IF (ANY(array(j,1:max_connectivity) == 0)) THEN
        icount = icount+1
        IF (icount <= listlen) indlist(icount) = j
      ENDIF
    ENDDO

    ! Recompute the list if the number of grid points with dummy indices was too large
    IF (icount > listlen) THEN
      DEALLOCATE (indlist)
      ALLOCATE (indlist(icount))
      icount = 0
      DO j = 1,  UBOUND(array, 1)
        IF (ANY(array(j,1:max_connectivity) == 0)) THEN
          icount = icount+1
          indlist(icount) = j
        ENDIF
      ENDDO
    ENDIF

    DO i = 1, icount
      j = indlist(i)
      last_no_zero = 0
      first_zero = 0
      DO WHILE(last_no_zero >=  first_zero)
        ! find first zero, last non-zero
        DO je = 1, max_connectivity
          IF (array(j,je) /= 0) THEN
            last_no_zero = je
          ELSEIF ( first_zero <= 0) THEN
            first_zero = je
          ENDIF
        ENDDO

        IF (first_zero == 0) THEN
          ! no zeros found, exit
          EXIT
        ELSEIF ( last_no_zero == 0) THEN
          CALL warning(method_name, "no connectivity found")
          EXIT
        ELSEIF ( first_zero <  last_no_zero) THEN
          !swap
          array(j,first_zero) = array(j,last_no_zero)
          array(j,last_no_zero) = 0
          ! check again
          last_no_zero = 0
          first_zero = 0
        ENDIF
      ENDDO ! WHILE(last_no_zero >=  first_zero)

      IF (first_zero == 0)   CYCLE   ! no zeros found, get next one
      IF (last_no_zero == 0) CYCLE ! no connectivity found"

      IF ( duplicate ) THEN
        ! fill zero connectivity with last_no_zero
        DO je = first_zero, max_connectivity
          IF (array(j,je) /= 0) &
               CALL finish(method_name, "Error when swapping!")
          array(j,je) =  array(j,last_no_zero)
        ENDDO
      ENDIF

    ENDDO ! j = 1, UBOUND(array,1)

    DEALLOCATE (indlist)

  END SUBROUTINE move_dummies_to_end

  !-------------------------------------------------------------------------
  INTEGER FUNCTION read_cartesian_positions(ncid, ig, patch, n_lp, id_lp, &
    & array_c_real, array_e_real, array_v_real)

    INTEGER,       INTENT(in)    :: ncid
    INTEGER,       INTENT(in)    ::  ig       ! domain ID
    TYPE(t_patch), INTENT(inout), TARGET ::  patch  ! patch data structure
    INTEGER,       INTENT(in)    ::  n_lp     ! Number of local parents on the same level
    INTEGER,       INTENT(in)    ::  id_lp(:) ! IDs of local parents on the same level

    REAL(wp), POINTER :: &
      & array_c_real(:,:), &  ! temporary arrays to read in real values
      & array_e_real(:,:), &
      & array_v_real(:,:)

    INTEGER :: varid
    INTEGER :: ip

    INTEGER :: return_status

    TYPE(t_patch), POINTER :: p_p

    CHARACTER(LEN=*), PARAMETER :: method_name = 'mo_model_domimp_patches:read_cartesian_positions'
    !-----------------------------------------------------------------------
    read_cartesian_positions = -1
    return_status = nf_inq_varid(ncid, 'cell_circumcenter_cartesian_x', varid)
    IF (return_status /= nf_noerr) RETURN ! ERROR

    CALL nf(nf_get_var_double(ncid, varid, array_c_real(:,1)))
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_real( array_c_real(:,1), p_p%n_patch_cells, p_p%cells%decomp_info%glb_index, &
        & p_p%cells%cartesian_center(:,:)%x(1) )
    ENDDO

    CALL nf(nf_inq_varid(ncid, 'cell_circumcenter_cartesian_y', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_c_real(:,1)))
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_real( array_c_real(:,1), p_p%n_patch_cells, p_p%cells%decomp_info%glb_index, &
        & p_p%cells%cartesian_center(:,:)%x(2) )
    ENDDO

    CALL nf(nf_inq_varid(ncid, 'cell_circumcenter_cartesian_z', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_c_real(:,1)))
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_real( array_c_real(:,1), p_p%n_patch_cells, p_p%cells%decomp_info%glb_index, &
        & p_p%cells%cartesian_center(:,:)%x(3) )
    ENDDO


    CALL nf(nf_inq_varid(ncid, 'edge_middle_cartesian_x', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_real( array_e_real(:,1), p_p%n_patch_edges, p_p%edges%decomp_info%glb_index, &
        & p_p%edges%cartesian_center(:,:)%x(1) )
    ENDDO

    CALL nf(nf_inq_varid(ncid, 'edge_middle_cartesian_y', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_real( array_e_real(:,1), p_p%n_patch_edges, p_p%edges%decomp_info%glb_index, &
        & p_p%edges%cartesian_center(:,:)%x(2) )
    ENDDO

    CALL nf(nf_inq_varid(ncid, 'edge_middle_cartesian_z', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_real( array_e_real(:,1), p_p%n_patch_edges, p_p%edges%decomp_info%glb_index, &
        & p_p%edges%cartesian_center(:,:)%x(3) )
    ENDDO

    CALL nf(nf_inq_varid(ncid, 'edge_dual_middle_cartesian_x', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_real( array_e_real(:,1), p_p%n_patch_edges, p_p%edges%decomp_info%glb_index, &
        & p_p%edges%cartesian_dual_middle(:,:)%x(1) )
    ENDDO

    CALL nf(nf_inq_varid(ncid, 'edge_dual_middle_cartesian_y', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_real( array_e_real(:,1), p_p%n_patch_edges, p_p%edges%decomp_info%glb_index, &
        & p_p%edges%cartesian_dual_middle(:,:)%x(2) )
    ENDDO

    CALL nf(nf_inq_varid(ncid, 'edge_dual_middle_cartesian_z', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_real( array_e_real(:,1), p_p%n_patch_edges, p_p%edges%decomp_info%glb_index, &
        & p_p%edges%cartesian_dual_middle(:,:)%x(3) )
    ENDDO

    CALL nf(nf_inq_varid(ncid, 'edge_primal_normal_cartesian_x', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_real( array_e_real(:,1), p_p%n_patch_edges, p_p%edges%decomp_info%glb_index, &
        & p_p%edges%primal_cart_normal(:,:)%x(1) )
    ENDDO

    CALL nf(nf_inq_varid(ncid, 'edge_primal_normal_cartesian_y', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_real( array_e_real(:,1), p_p%n_patch_edges, p_p%edges%decomp_info%glb_index, &
        & p_p%edges%primal_cart_normal(:,:)%x(2) )
    ENDDO

    CALL nf(nf_inq_varid(ncid, 'edge_primal_normal_cartesian_z', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_real( array_e_real(:,1), p_p%n_patch_edges, p_p%edges%decomp_info%glb_index, &
        & p_p%edges%primal_cart_normal(:,:)%x(3) )
    ENDDO

    CALL nf(nf_inq_varid(ncid, 'edge_dual_normal_cartesian_x', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_real( array_e_real(:,1), p_p%n_patch_edges, p_p%edges%decomp_info%glb_index, &
        & p_p%edges%dual_cart_normal(:,:)%x(1) )
    ENDDO

    CALL nf(nf_inq_varid(ncid, 'edge_dual_normal_cartesian_y', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_real( array_e_real(:,1), p_p%n_patch_edges, p_p%edges%decomp_info%glb_index, &
        & p_p%edges%dual_cart_normal(:,:)%x(2) )
    ENDDO

    CALL nf(nf_inq_varid(ncid, 'edge_dual_normal_cartesian_z', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_e_real(:,1)))
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_real( array_e_real(:,1), p_p%n_patch_edges, p_p%edges%decomp_info%glb_index, &
        & p_p%edges%dual_cart_normal(:,:)%x(3) )
    ENDDO

    CALL nf(nf_inq_varid(ncid, 'cartesian_x_vertices', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_v_real(:,1)))
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_real( array_v_real(:,1), p_p%n_patch_verts, p_p%verts%decomp_info%glb_index, &
        & p_p%verts%cartesian(:,:)%x(1) )
    ENDDO

    CALL nf(nf_inq_varid(ncid, 'cartesian_y_vertices', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_v_real(:,1)))
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_real( array_v_real(:,1), p_p%n_patch_verts, p_p%verts%decomp_info%glb_index, &
        & p_p%verts%cartesian(:,:)%x(2) )
    ENDDO

    CALL nf(nf_inq_varid(ncid, 'cartesian_z_vertices', varid))
    CALL nf(nf_get_var_double(ncid, varid, array_v_real(:,1)))
    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)
      CALL divide_real( array_v_real(:,1), p_p%n_patch_verts, p_p%verts%decomp_info%glb_index, &
        & p_p%verts%cartesian(:,:)%x(3) )
    ENDDO

    IF (MAXVAL(ABS(patch%edges%primal_cart_normal(1,1)%x(:))) < 0.001_wp) &
      & RETURN  ! Error , the normal are filled properly

    read_cartesian_positions = 0

  END FUNCTION read_cartesian_positions
  !-------------------------------------------------------------------------

  !-------------------------------------------------------------------------
  SUBROUTINE calculate_cartesian_positions(ig, patch, n_lp, id_lp)

    INTEGER,       INTENT(in)    ::  ig       ! domain ID
    TYPE(t_patch), INTENT(inout), TARGET ::  patch  ! patch data structure
    INTEGER,       INTENT(in)    ::  n_lp     ! Number of local parents on the same level
    INTEGER,       INTENT(in)    ::  id_lp(:) ! IDs of local parents on the same level

    TYPE(t_patch), POINTER :: p_p

    INTEGER :: ip
    CHARACTER(LEN=*), PARAMETER :: method_name = 'mo_model_domimp_patches:calculate_cartesian_positions'
    !-----------------------------------------------------------------------
    ! GZ: This routine is always called with grids from the global grid generator, so this warning
    ! is more confusing than useful
    IF (msg_level >= 15 .OR. patch%geometry_info%geometry_type /= sphere_geometry) THEN
      CALL warning(method_name, " is called")
    ENDIF
    IF (patch%geometry_info%geometry_type /= sphere_geometry) &
      CALL finish(method_name, "geometry_type /= sphere_geometry")

    DO ip = 0, n_lp
      p_p => get_patch_ptr(patch, id_lp, ip)

      ! calculate Cartesian components of primal normal
      ! (these are old grids)
      CALL calculate_patch_cartesian_positions( p_p )

    ENDDO

  END SUBROUTINE calculate_cartesian_positions
  !-------------------------------------------------------------------------

  !-------------------------------------------------------------------------
  ! get_patch_ptr returns a pointer to patch for idx=0,
  ! a pointer to a local parent patch from the list otherwise
  FUNCTION get_patch_ptr(patch, id_lp, idx) result(patch_ptr)
    TYPE(t_patch), TARGET ::  patch  ! patch data structure
    INTEGER,       INTENT(in) ::  id_lp(:) ! IDs of local parents on the same level
    TYPE(t_patch), POINTER :: patch_ptr
    INTEGER, INTENT(in)    :: idx

    IF (idx == 0) THEN
      patch_ptr => patch
    ELSE
      patch_ptr => p_patch_local_parent(id_lp(idx))
    ENDIF
  END FUNCTION get_patch_ptr
  !-------------------------------------------------------------------------

  !-------------------------------------------------------------------------
  !>
  !! Divide and reshape (for blocking) a real array
  !!
  !! @par Revision History
  !! Developed  by Rainer Johanni (2011-12-04)
  !!
  SUBROUTINE divide_real( p_real_array_in, nvals, glb_index, &
    & p_divided_real_array_out )

    ! input array
    REAL(wp), INTENT(in):: p_real_array_in(:)
    ! number of values
    INTEGER, INTENT(in) :: nvals
    ! global index of values
    INTEGER, INTENT(in) :: glb_index(:)
    ! output array
    REAL(wp), INTENT(inout) :: p_divided_real_array_out(:,:)

    ! local variables:
    CHARACTER(LEN=*), PARAMETER :: routine = 'mo_model_domimp_patches:divide_real'
    INTEGER nblks, npromz, n, nlen, jb, jl, chk_blocks

    nblks  = (nvals-1)/nproma + 1
    npromz = nvals - (nblks-1)*nproma
    chk_blocks = nblks
    IF (use_dummy_cell_closure) THEN
      IF (npromz == nproma) chk_blocks = nblks + 1
    ENDIF

    ! consistency check
    IF ( (SIZE(p_divided_real_array_out,1) /= nproma) .OR.  &
      &  (SIZE(p_divided_real_array_out,2) >  chk_blocks) ) THEN
      CALL finish(routine, "Internal error!")
    END IF

    n = 0
    DO jb = 1, nblks

      IF (jb /= nblks) THEN
        nlen = nproma
      ELSE
        nlen = npromz
      END IF

      DO jl = 1, nlen
        n = n+1
        p_divided_real_array_out(jl,jb) = p_real_array_in(glb_index(n))
      END DO

    END DO

  END SUBROUTINE divide_real
  !-------------------------------------------------------------------------

  !-------------------------------------------------------------------------
  !>
  !! Divide and reshape (for blocking) a integer array
  !!
  !! @par Revision History
  !! Developed  by Rainer Johanni (2011-12-04)
  !!
  SUBROUTINE divide_int( p_int_array_in, nvals, glb_index, &
    & p_divided_int_array_out )

    ! input array
    INTEGER, INTENT(in):: p_int_array_in(:)
    ! number of values
    INTEGER, INTENT(in) :: nvals
    ! global index of values
    INTEGER, INTENT(in) :: glb_index(:)
    ! output array
    INTEGER, INTENT(inout) :: p_divided_int_array_out(:,:)

    ! local variables:
    CHARACTER(LEN=*), PARAMETER :: routine = 'mo_model_domimp_patches:divide_int'
    INTEGER nblks, npromz, n, nlen, jb, jl, chk_blocks

    nblks  = (nvals-1)/nproma + 1
    npromz = nvals - (nblks-1)*nproma
    chk_blocks = nblks
    IF (use_dummy_cell_closure) THEN
      IF (npromz == nproma) chk_blocks = nblks + 1
    ENDIF

    ! consistency check
    IF ( (SIZE(p_divided_int_array_out,1) /= nproma) .OR.  &
      &  (SIZE(p_divided_int_array_out,2) >  chk_blocks) ) THEN
      CALL finish(routine, "Internal error!")
    END IF

    n = 0
    DO jb = 1, nblks

      IF (jb /= nblks) THEN
        nlen = nproma
      ELSE
        nlen = npromz
      END IF

      DO jl = 1, nlen
        n = n+1
        p_divided_int_array_out(jl,jb) = p_int_array_in(glb_index(n))
      END DO

    END DO

  END SUBROUTINE divide_int
  !-------------------------------------------------------------------------

  !-------------------------------------------------------------------------
  !>
  !! Divide and reshape (for blocking) a index array
  !!
  !! @par Revision History
  !! Developed  by Rainer Johanni (2011-12-04)
  !!
  SUBROUTINE divide_idx( p_idx_array_in, nvals, glb_index, glb2loc_index, &
    & idx_array_out, blk_array_out )

    ! input array
    INTEGER, INTENT(in):: p_idx_array_in(:)
    ! number of values
    INTEGER, INTENT(in) :: nvals
    ! global index of values
    INTEGER, INTENT(in) :: glb_index(:)
    ! decomposition information
    TYPE(t_glb2loc_index_lookup), INTENT(in) :: glb2loc_index
    ! output array
    INTEGER, INTENT(inout) :: idx_array_out(:,:), blk_array_out(:,:)

    INTEGER :: j, jb, jl, j_g, j_l

    DO j = 1, nvals
      jb = (j - 1) / nproma + 1
      jl = MOD(j - 1, nproma) + 1

      ! get global index in divided array
      j_g = p_idx_array_in(glb_index(j))
      j_l = get_valid_local_index(glb2loc_index, j_g, .TRUE.)
      ! handle values outside local domain in the same way as get_local_idx_blk
      idx_array_out(jl,jb) = idx_no(j_l)
      blk_array_out(jl,jb) = blk_no(j_l)
    END DO

  END SUBROUTINE divide_idx
  !-------------------------------------------------------------------------

  !-------------------------------------------------------------------------
  !>
  !!               reshape an integer index array for the blocking.
  !!
  !! @par Revision History
  !! Developed  by  Jochen Foerstner, DWD (2008-10-21)
  !!
  SUBROUTINE reshape_idx( p_idx_array_in, nblks, npromz,  &
    & p_reshaped_idx_array_out,       &
    & p_reshaped_blk_array_out )



    ! input index array
    INTEGER, INTENT(in) :: p_idx_array_in(:)
    ! number of blocks
    INTEGER, INTENT(in) :: nblks
    ! chunk length
    INTEGER, INTENT(in) :: npromz

    ! output line index array
    INTEGER, INTENT(inout) :: p_reshaped_idx_array_out(:,:)
    ! output block index array
    INTEGER, INTENT(inout) :: p_reshaped_blk_array_out(:,:)

    INTEGER :: nlen
    INTEGER :: jl, jb
    INTEGER :: il, idx_in, idx, blk

    !-----------------------------------------------------------------------

    DO jb = 1, nblks

      IF (jb /= nblks) THEN
        nlen = nproma
      ELSE
        nlen = npromz
        DO jl = npromz+1, nproma
          p_reshaped_idx_array_out(jl,nblks) = 0
          p_reshaped_blk_array_out(jl,nblks) = 0
        END DO
      END IF

      DO jl = 1, nlen
        il  = jl + ( jb - 1 )*nproma
        idx_in = p_idx_array_in(il)
        IF (idx_in /= 0) THEN
          blk = ( ABS(idx_in) - 1 ) / nproma + 1
          idx = SIGN( ABS(idx_in) - ( blk - 1 )*nproma, idx_in )
        ELSE
          blk = 0
          idx = 0
        ENDIF
        p_reshaped_idx_array_out(jl,jb) = idx
        p_reshaped_blk_array_out(jl,jb) = blk
      END DO

    END DO

  END SUBROUTINE reshape_idx
  !-------------------------------------------------------------------------

  !-------------------------------------------------------------------------
  !>
  !!               reshape the start_idx / end_idx fields for blocking.
  !!
  !! @par Revision History
  !! Developed  by Guenther Zaengl, DWD (2009-07-22)
  !!
  SUBROUTINE reshape_idx_list( indlist_in, idx_out, blk_out )



    ! input index array
    INTEGER, INTENT(in) :: indlist_in(:,:)

    ! output line index array
    INTEGER, INTENT(inout) :: idx_out(:,:)
    ! output block index array
    INTEGER, INTENT(inout) :: blk_out(:,:)

    INTEGER :: jg

    !-----------------------------------------------------------------------

    blk_out(:,1) = (indlist_in(:,1) - 1) / nproma + 1
    idx_out(:,1) =  indlist_in(:,1) - (blk_out(:,1) - 1) * nproma
    IF (max_childdom > 1) THEN
      DO jg = 2, max_childdom
        blk_out(:,jg) = blk_out(:,1)
        idx_out(:,jg) = idx_out(:,1)
      ENDDO
    ENDIF

  END SUBROUTINE reshape_idx_list

  SUBROUTINE reshape_index_list( indlist_in, idx_out, blk_out )



    ! input index array
    INTEGER, INTENT(in) :: indlist_in(:)

    ! output line index array
    INTEGER, INTENT(inout) :: idx_out(:)
    ! output block index array
    INTEGER, INTENT(inout) :: blk_out(:)

    !-----------------------------------------------------------------------

    blk_out(:) = (indlist_in(:) - 1) / nproma + 1
    idx_out(:) =  indlist_in(:) - (blk_out(:) - 1) * nproma

  END SUBROUTINE reshape_index_list
  !-------------------------------------------------------------------------

  !-------------------------------------------------------------------------
  SUBROUTINE nf(STATUS, warnonly, silent)

    INTEGER, INTENT(in)           :: STATUS
    LOGICAL, INTENT(in), OPTIONAL :: warnonly
    LOGICAL, INTENT(in), OPTIONAL :: silent

    LOGICAL :: lwarnonly, lsilent

    lwarnonly = .FALSE.
    lsilent   = .FALSE.
    IF(PRESENT(warnonly)) lwarnonly = .TRUE.
    IF(PRESENT(silent))   lsilent   = silent

    IF (lsilent) RETURN
    IF (STATUS /= nf_noerr) THEN
      IF (lwarnonly) THEN
        CALL message('mo_model_domain_import netCDF error', nf_strerror(STATUS), &
          & level=em_warn)
      ELSE
        CALL finish('mo_model_domain_import netCDF error', nf_strerror(STATUS))
      ENDIF
    ENDIF

  END SUBROUTINE nf

END MODULE mo_model_domimp_patches


