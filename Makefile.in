# This makefile sets up the building environment and calls icon.mk.

SHELL= @SHELL@
BUILD_ENV= @BUILD_ENV_MAKE@

DELEGATEE_FILE= icon.mk

.SUFFIXES:
.NOTPARALLEL:
.PHONY: all distclean help dist snapshot force-delegate

# Default target:
all:
	@$(BUILD_ENV) $(MAKE) -f $(DELEGATEE_FILE) $@

# A rule for targets that are unknown to this makefile. The dependency on a
# phony target 'force-delegate' enforces running make with $(DELEGATEE_FILE)
# even if the requested target already exists. The fact that the rule is
# terminal (i.e. declared with double colon) allows for building targets that
# are normally not matched by "match-anything" pattern rules (e.g. generated
# source files like version.c):
%:: force-delegate
	@$(BUILD_ENV) $(MAKE) -f $(DELEGATEE_FILE) $@

# Disable attempts to build this makefile with the previous
# "match-anything" pattern rule:
Makefile:;

distclean:
	@$(BUILD_ENV) $(MAKE) -f $(DELEGATEE_FILE) $@
	rm -f Makefile

help:
	@echo "Usage:"; \
	echo "    make -j <jobs> <target>"; \
	echo "where <jobs> is the number of simultaneous building jobs and <target> is one of"; \
	echo "the following:"; \
	echo "  'all' (default) build ICON"; \
	echo "  'check'         build ICON and check whether the bundled libraries are built"; \
	echo "                  correctly"; \
	echo "  'check-bundled' skip building ICON and check whether the bundled libraries are"; \
	echo "                  built correctly"; \
	echo "  'install'       install ICON"; \
	echo "  'depend'        generate dependency files"; \
	echo "  'preprocess'    run source file preprocessing"; \
	echo "  'mostlyclean'   delete files generated by the compilers"; \
	echo "  'clean'         delete files generated by 'make'"; \
	echo "  'distclean'     delete files generated by 'make' and 'configure'"; \
	echo "  'srclist'       generate file './srclist' containing a list of ICON source"; \
	echo "                  files to be compiled in the current configuration"; \
	echo "  'dist'          create a tarball containing files from the current HEAD of"; \
	echo "                  the ICON git repository and its git submodules"; \
	echo "  'snapshot'      create a tarball containing all files in the source directory"; \
	echo "                  that are not ignored by git in their current state"

GIT= git
TAR= tar
BZIP2= bzip2

# Includes only commited versions of the files:
dist:
	@if test ! -d @top_srcdir@/.git; then echo "'@top_srcdir@' is not a git repository" >&2; exit 1; fi
	$(GIT) -C @top_srcdir@ archive --prefix=@PACKAGE_TARNAME@/ --format tar -o @abs_top_builddir@/@PACKAGE_TARNAME@.tar HEAD
	$(GIT) -C @top_srcdir@ submodule foreach '$(GIT) archive --prefix=@PACKAGE_TARNAME@/$$path/ --format tar -o @abs_top_builddir@/$$sha1.tar HEAD && $(TAR) -Af @abs_top_builddir@/@PACKAGE_TARNAME@.tar @abs_top_builddir@/$$sha1.tar && rm @abs_top_builddir@/$$sha1.tar'
	rm -f @PACKAGE_TARNAME@.tar.bz2 && BZIP2=$${BZIP2--9} $(BZIP2) @PACKAGE_TARNAME@.tar

# Includes all non-ignored files with uncommitted changes:
snapshot:
	@if test ! -d @top_srcdir@/.git; then echo "'@top_srcdir@' is not a git repository" >&2; exit 1; fi; \
	GIT_DIR=; unset GIT_DIR; if $(GIT) -C @top_srcdir@ ls-files --recurse-submodules >/dev/null 2>&1; then :; \
          else echo "'$(GIT)' is not found or too old (at least version 2.11 is required)" >&2; exit 1; fi; \
	if test '@LN_S@' != 'ln -s'; then echo "'ln -s' is not supported" >&2; exit 1; fi
	snapshot=@PACKAGE_TARNAME@-snapshot-$(shell date -uI); \
	rm -f "$$snapshot" && @LN_S@ @top_srcdir@ "$$snapshot"; \
	GIT_DIR=; unset GIT_DIR; ($(GIT) -C @top_srcdir@ ls-files --recurse-submodules && $(GIT) -C @top_srcdir@ ls-files -o --exclude-standard -x "/$$snapshot") | sed "s%^%$$snapshot/%" | $(TAR) chf - -T - | BZIP2=$${BZIP2--9} $(BZIP2) -c > "$$snapshot.tar.bz2"; \
	rm -f "$$snapshot"

